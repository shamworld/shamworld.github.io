(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{347:function(t,s,n){"use strict";n.r(s);var a=n(12),e=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"javascript-基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-基础"}},[t._v("#")]),t._v(" JavaScript 基础")]),t._v(" "),s("h2",{attrs:{id:"javascript-有哪些数据类型-它们的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-有哪些数据类型-它们的区别"}},[t._v("#")]),t._v(" JavaScript 有哪些数据类型，它们的区别？")]),t._v(" "),s("p",[t._v("JavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、\nNumber、String、Object、Symbol、BigInt。")]),t._v(" "),s("p",[t._v("其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：")]),t._v(" "),s("ul",[s("li",[t._v("Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了\n解决可能出现的全局变量冲突的问题。")]),t._v(" "),s("li",[t._v("BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，\n使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了\nNumber 能够表示的安全整数范围。")])]),t._v(" "),s("p",[t._v("这些数据可以分为原始数据类型和引用数据类型：")]),t._v(" "),s("ul",[s("li",[t._v("栈：原始数据类型（Undefined、Null、Boolean、Number、String）")]),t._v(" "),s("li",[t._v("堆：引用数据类型（对象、数组和函数）")])]),t._v(" "),s("p",[t._v("两种类型的区别在于存储位置的不同：")]),t._v(" "),s("ul",[s("li",[t._v("原始数据类型直接存储在栈（stack）中的简单数据段，占据空间\n小、大小固定，属于被频繁使用数据，所以放入栈中存储；")]),t._v(" "),s("li",[t._v("引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固\n定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈\n中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引\n用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：")]),t._v(" "),s("li",[t._v("在数据结构中，栈中数据的存取方式为先进后出。")]),t._v(" "),s("li",[t._v("堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大\n小来规定。")])]),t._v(" "),s("p",[t._v("在操作系统中，内存被分为栈区和堆区：")]),t._v(" "),s("ul",[s("li",[t._v("栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的\n值等。其操作方式类似于数据结构中的栈。")]),t._v(" "),s("li",[t._v("堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可\n能由垃圾回收机制回收。")])]),t._v(" "),s("h2",{attrs:{id:"数据类型检测的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型检测的方式有哪些"}},[t._v("#")]),t._v(" 数据类型检测的方式有哪些？")]),t._v(" "),s("h3",{attrs:{id:"typeof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#typeof"}},[t._v("#")]),t._v(" typeof")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// number")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// boolean")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"str"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// string")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// object")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// object")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// object")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\n")])])]),s("p",[t._v("其中数组、对象、null 都会被判断为 object，其他判断都正确。")]),t._v(" "),s("h3",{attrs:{id:"instanceof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#instanceof"}},[t._v("#")]),t._v(" instanceof")]),t._v(" "),s("p",[t._v("instanceof 可以正确判断对象的类型，其内部运行机制是判断在其\n原型链中能否找到该类型的原型。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Number")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Boolean")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"str"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),s("p",[t._v("instanceof 只能正确判断引用数据类型，而不能判断基\n本数据类型。instanceof 运算符可以用来测试一个对象在其原型链\n中是否存在一个构造函数的 prototype 属性。")]),t._v(" "),s("h3",{attrs:{id:"constructor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" Number"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" Boolean"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"str"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" Array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" Function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),s("p",[t._v("constructor 有两个作用，一是判断数据的类型，二是对象实例通过\nconstrcutor 对象访问它的构造函数。需要注意，如果创建一个对象\n来改变它的原型，constructor 就不能用来判断数据类型了：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Fn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("constructor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" Array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),s("h3",{attrs:{id:"object-prototype-tostring-call"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-tostring-call"}},[t._v("#")]),t._v(" Object.prototype.toString.call()")]),t._v(" "),s("p",[t._v("Object.prototype.toString.call() 使用 Object 对象的原型方法\ntoString 来判断数据类型：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("toString"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object Number]")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object Boolean]")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"str"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object String]")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object Array]")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object Object]")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object Null]")]),t._v("\nconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// [object Undefined]")]),t._v("\n")])])]),s("p",[t._v("同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和\nObject.prototype.toString.call(obj)的结果不一样，这是为什\n么？")]),t._v(" "),s("p",[t._v("这是因为 toString 是 Object 的原型方法，而 Array、function 等类\n型作为 Object 的实例，都重写了 toString 方法。不同的对象类型调\n用 toString 方法时，根据原型链的知识，调用的是对应的重写之后")]),t._v(" "),s("p",[t._v("的 toString 方法（function 类型返回内容为函数体的字符串，Array\n类型返回元素组成的字符串…），而不会去调用 Object 上原型\ntoString 方法（返回对象的具体类型），所以采用 obj.toString()\n不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要\n得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。")]),t._v(" "),s("h2",{attrs:{id:"null-和-undefined-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-区别"}},[t._v("#")]),t._v(" null 和 undefined 区别")]),t._v(" "),s("p",[t._v("Undefined 和 Null 都是基本数据类型，这两个基本数据类型\n分别都只有一个值，就是 undefined 和 null。")]),t._v(" "),s("p",[t._v("undefined 代表的含义是未定义，null 代表的含义是空对象。一般\n变量声明了但还没有定义的时候会返回 undefined，null 主要用于\n赋值给一些可能会返回对象的变量，作为初始化。")]),t._v(" "),s("p",[t._v("undefined 在 JavaScript 中不是一个保留字，这意味着可以使用\nundefined 来作为一个变量名，但是这样的做法是非常危险的，它会\n影响对 undefined 值的判断。我们可以通过一些方法获得安全的\nundefined 值，比如说 void 0。")]),t._v(" "),s("p",[t._v("当对这两种类型使用 typeof 进行判断时，Null 类型化会返回\n“object”，这是一个历史遗留的问题。当使用双等号对两种类型的\n值进行比较时会返回 true，使用三个等号时会返回 false。")]),t._v(" "),s("h2",{attrs:{id:"intanceof-操作符的实现原理及实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#intanceof-操作符的实现原理及实现"}},[t._v("#")]),t._v(" intanceof 操作符的实现原理及实现")]),t._v(" "),s("p",[t._v("instanceof 运算符用于判断构造函数的 prototype 属性是否出现\n在对象的原型链中的任何位置。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("myInstanceof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" right")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"function"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"not function"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"object"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"function"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" leftVal "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" rightVal "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("leftVal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("leftVal "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" rightVal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    leftVal "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" leftVal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__proto__"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"object-is-与比较操作符-、-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-is-与比较操作符-、-的区别"}},[t._v("#")]),t._v(" Object.is() 与比较操作符 “===”、“==” 的区别")]),t._v(" "),s("p",[t._v("使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进\n行强制类型转化后再进行比较。")]),t._v(" "),s("p",[t._v("使用三等号（===）进行相等判断时，如果两边的类型不一致时，不\n会做强制类型准换，直接返回 false。")]),t._v(" "),s("p",[t._v("使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相\n同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN\n是相等的。")]),t._v(" "),s("h2",{attrs:{id:"如何判断一个对象是空对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何判断一个对象是空对象"}},[t._v("#")]),t._v(" 如何判断一个对象是空对象")]),t._v(" "),s("p",[t._v("使用 JSON 自带的.stringify 方法来判断：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"{}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"空对象"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("使用 ES6 新增的方法 Object.keys()来判断：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("keys"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"空对象"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"const-对象的属性可以修改吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const-对象的属性可以修改吗"}},[t._v("#")]),t._v(" const 对象的属性可以修改吗")]),t._v(" "),s("p",[t._v("const 保证的并不是变量的值不能改动，而是变量指向的那个内存地\n址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值\n就保存在变量指向的那个内存地址，因此等同于常量。")]),t._v(" "),s("p",[t._v("但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的\n内存地址，保存的只是一个指针，const 只能保证这个指针是固定不\n变的，至于它指向的数据结构是不是可变的，就完全不能控制了。")]),t._v(" "),s("h2",{attrs:{id:"如果-new-一个箭头函数的会怎么样"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果-new-一个箭头函数的会怎么样"}},[t._v("#")]),t._v(" 如果 new 一个箭头函数的会怎么样")]),t._v(" "),s("p",[t._v("箭头函数是 ES6 中的提出来的，它没有 prototype，也没有自己的 this\n指向，更不可以使用 arguments 参数，所以不能 New 一个箭头函数。\nnew 操作符的实现步骤如下：")]),t._v(" "),s("ul",[s("li",[t._v("创建一个对象")]),t._v(" "),s("li",[t._v("将构造函数的作用域赋给新对象（也就是将对象的"),s("strong",[t._v("proto")]),t._v("属性指向构造函数的 prototype 属性）")]),t._v(" "),s("li",[t._v("指向构造函数中的代码，构造函数中的 this 指向该对象（也就是为这个对象添加属性和方法）")]),t._v(" "),s("li",[t._v("返回新的对象")])]),t._v(" "),s("p",[t._v("所以，上面的第二、三步，箭头函数都是没有办法执行的。")]),t._v(" "),s("h2",{attrs:{id:"箭头函数的-this-指向哪里"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数的-this-指向哪里"}},[t._v("#")]),t._v(" 箭头函数的 this 指向哪⾥？")]),t._v(" "),s("p",[t._v("箭头函数不同于传统 JavaScript 中的函数，箭头函数并没有属于⾃\n⼰的 this，它所谓的 this 是捕获其所在上下⽂的 this 值，作为⾃\n⼰的 this 值，并且由于没有属于⾃⼰的 this，所以是不会被 new\n调⽤的，这个所谓的 this 也不会被改变。")]),t._v(" "),s("h2",{attrs:{id:"javascript-脚本延迟加载的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-脚本延迟加载的方式有哪些"}},[t._v("#")]),t._v(" JavaScript 脚本延迟加载的方式有哪些？")]),t._v(" "),s("p",[t._v("延迟加载就是等页面加载完成之后再加载 JavaScript 文件。js 延\n迟加载有助于提高页面加载速度。")]),t._v(" "),s("p",[t._v("一般有以下几种方式：")]),t._v(" "),s("p",[t._v("defer 属性：给 js 脚本添加 defer 属性，这个属性会让脚本的加\n载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文\n件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性\n的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是\n这样。")]),t._v(" "),s("p",[t._v("async 属性：给 js 脚本添加 async 属性，这个属性会使脚本异步\n加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js\n脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async\n属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次\n执行。")]),t._v(" "),s("p",[t._v("动态创建 DOM 方式：动态创建 DOM 标签的方式，可以对文档的加载\n事件进行监听，当文档加载完成后再动态的创建 script 标签来引入\njs 脚本。")]),t._v(" "),s("p",[t._v("使用 setTimeout 延迟方法：设置一个定时器来延迟加载 js 脚本文件。")]),t._v(" "),s("p",[t._v("让 JS 最后加载：将 js 脚本放在文档的底部，来使 js 脚本尽可能\n的在最后来加载执行。")]),t._v(" "),s("h2",{attrs:{id:"什么是-dom-和-bom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-dom-和-bom"}},[t._v("#")]),t._v(" 什么是 DOM 和 BOM？")]),t._v(" "),s("p",[t._v("DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象\n主要定义了处理网页内容的方法和接口。")]),t._v(" "),s("p",[t._v("BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，\n这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是\nwindow，而 window 对象具有双重角色，它既是通过 js 访问浏览器\n窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页\n中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方\n法存在。window 对象含有 location 对象、navigator 对象、screen\n对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM\n的 window 对象的子对象。")]),t._v(" "),s("h2",{attrs:{id:"escape、encodeuri、encodeuricomponent-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#escape、encodeuri、encodeuricomponent-的区别"}},[t._v("#")]),t._v(" escape、encodeURI、encodeURIComponent 的区别")]),t._v(" "),s("p",[t._v("encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合\n法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。")]),t._v(" "),s("p",[t._v("encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊\n字符也会得到转义。")]),t._v(" "),s("p",[t._v("escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为\n0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode\n编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，\n再在每个字节前加上 %。")]),t._v(" "),s("h2",{attrs:{id:"什么是尾调用-使用尾调用有什么好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是尾调用-使用尾调用有什么好处"}},[t._v("#")]),t._v(" 什么是尾调用，使用尾调用有什么好处？")]),t._v(" "),s("p",[t._v("尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行\n栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上\n下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，\n因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上\n下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优\n化只在严格模式下开启，正常模式是无效的。")]),t._v(" "),s("h2",{attrs:{id:"es6-模块与-commonjs-模块有什么异同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-模块与-commonjs-模块有什么异同"}},[t._v("#")]),t._v(" ES6 模块与 CommonJS 模块有什么异同？")]),t._v(" "),s("p",[t._v("ES6 Module 和 CommonJS 模块的区别：")]),t._v(" "),s("p",[t._v("CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6\nModule 只存只读，不能改变其值，也就是指针指向不能变，类似 const；\nimport 的接⼝是 read-only（只读状态），不能修改其变量值。 即\n不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对\ncommonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会\n编译报错。")]),t._v(" "),s("p",[t._v("ES6 Module 和 CommonJS 模块的共同点：")]),t._v(" "),s("p",[t._v("CommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内\n部属性的值进⾏改变。")]),t._v(" "),s("h2",{attrs:{id:"for-in-和-for-of-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#for-in-和-for-of-的区别"}},[t._v("#")]),t._v(" for...in 和 for...of 的区别")]),t._v(" "),s("p",[t._v("for…of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口\n的数据结构（数组、对象等）并且返回各项的值，和 for…in 的区别如下:")]),t._v(" "),s("p",[t._v("for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；")]),t._v(" "),s("p",[t._v("for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而\nfor … of 只遍历当前对象不会遍历原型链；")]),t._v(" "),s("p",[t._v("对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原\n型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；")]),t._v(" "),s("p",[t._v("总结：for...in 循环主要是为了遍历对象而生，不适用于遍历数组；\nfor...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以\n及 Generator 对象。")]),t._v(" "),s("h2",{attrs:{id:"原型链的终点是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型链的终点是什么"}},[t._v("#")]),t._v(" 原型链的终点是什么？")]),t._v(" "),s("p",[t._v("由于 Object 是构造函数，原型链终点 Object.prototype."),s("strong",[t._v("proto")]),t._v("，\n而 Object.prototype."),s("strong",[t._v("proto")]),t._v("=== null // true，所以，原型链\n的终点是 null。原型链上的所有原型都是对象，所有的对象最终都\n是由 Object 构造的，而 Object.prototype 的下一级是\nObject.prototype."),s("strong",[t._v("proto")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"对作用域、作用域链的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对作用域、作用域链的理解"}},[t._v("#")]),t._v(" 对作用域、作用域链的理解")]),t._v(" "),s("p",[t._v("1）全局作用域和函数作用域")]),t._v(" "),s("p",[t._v("（1）全局作用域")]),t._v(" "),s("p",[t._v("最外层函数和最外层函数外面定义的变量拥有全局作用域")]),t._v(" "),s("p",[t._v("所有未定义直接赋值的变量自动声明为全局作用域")]),t._v(" "),s("p",[t._v("所有 window 对象的属性拥有全局作用域")]),t._v(" "),s("p",[t._v("全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空\n间，容易引起命名冲突。")]),t._v(" "),s("p",[t._v("（2）函数作用域")]),t._v(" "),s("p",[t._v("函数作用域声明在函数内部的变量，一般只有固定的代码片段可以访问到")]),t._v(" "),s("p",[t._v("作用域是分层的，内层作用域可以访问外层作用域，反之不行")]),t._v(" "),s("p",[t._v("2）块级作用域")]),t._v(" "),s("p",[t._v("使用 ES6 中新增的 let 和 const 指令可以声明块级作用域，块级作用\n域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）")]),t._v(" "),s("p",[t._v("let 和 const 声明的变量不会有变量提升，也不可以重复声明")]),t._v(" "),s("p",[t._v("在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量\n限制在循环内部。")]),t._v(" "),s("p",[t._v("作用域链：")]),t._v(" "),s("p",[t._v("在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个\n变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域\n查找，依次向上级作用域查找，直到访问到 window 对象就被终止，\n这一层层的关系就是作用域链。")]),t._v(" "),s("p",[t._v("作用域链的作用是保证对执行环境有权访问的所有变量和函数的有\n序访问，通过作用域链，可以访问到外层环境的变量和函数。\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个\n包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是\n当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全\n局对象）始终是作用域链的最后一个对象。")]),t._v(" "),s("p",[t._v("当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域\n链向后查找。")]),t._v(" "),s("h2",{attrs:{id:"对-this-对象的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对-this-对象的理解"}},[t._v("#")]),t._v(" 对 this 对象的理解")]),t._v(" "),s("p",[t._v("this 是执行上下文中的一个属性，它指向最后一次调用这个方法的\n对象。在实际开发中，this 的指向可以通过四种调用模式来判断。")]),t._v(" "),s("p",[t._v("第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作\n为函数来调用时，this 指向全局对象。")]),t._v(" "),s("p",[t._v("第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，\nthis 指向这个对象。")]),t._v(" "),s("p",[t._v("第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行\n前会新创建一个对象，this 指向这个新创建的对象。")]),t._v(" "),s("p",[t._v("第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显\n示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：\n一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，\n第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。\n也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举\n出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对\n象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其\n他情况下都不会改变。")]),t._v(" "),s("p",[t._v("这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call\n和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。")]),t._v(" "),s("h2",{attrs:{id:"call-和-apply-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call-和-apply-的区别"}},[t._v("#")]),t._v(" call() 和 apply() 的区别？")]),t._v(" "),s("p",[t._v("它们的作用一模一样，区别仅在于传入参数的形式的不同。")]),t._v(" "),s("p",[t._v("apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，\n第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类\n数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。")]),t._v(" "),s("p",[t._v("call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是\n代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依\n次传入函数。")]),t._v(" "),s("h2",{attrs:{id:"异步编程的实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步编程的实现方式"}},[t._v("#")]),t._v(" 异步编程的实现方式？")]),t._v(" "),s("p",[t._v("JavaScript 中的异步机制可以分为以下几种：")]),t._v(" "),s("p",[t._v("回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函\n数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦\n合度太高，不利于代码的可维护。")]),t._v(" "),s("p",[t._v("Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为\n链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，\n可能会造成代码的语义不够明确。")]),t._v(" "),s("p",[t._v("generator 的方式，它可以在函数的执行过程中，将函数的执行权转\n移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行\n的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权\n给转移回来。因此在 generator 内部对于异步操作的方式，可以以\n同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控\n制权转移回来，因此需要有一个自动执行 generator 的机制，比如\n说 co 模块等方式来实现 generator 的自动执行。")]),t._v(" "),s("p",[t._v("async 函数的方式，async 函数是 generator 和 promise 实现的\n一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个\nawait 语句的时候，如果语句返回一个 promise 对象，那么函数将\n会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此\n可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动\n执行。")]),t._v(" "),s("h2",{attrs:{id:"对-promise-的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对-promise-的理解"}},[t._v("#")]),t._v(" 对 Promise 的理解")]),t._v(" "),s("p",[t._v("Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步\n操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，\n它比传统的解决方案回调函数和事件更合理和更强大。")]),t._v(" "),s("p",[t._v("所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束\n的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一\n个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，\n各种异步操作都可以用同样的方法进行处理。")]),t._v(" "),s("p",[t._v("（1）Promise 的实例有三个状态:")]),t._v(" "),s("p",[t._v("Pending（进行中）")]),t._v(" "),s("p",[t._v("Resolved（已完成）")]),t._v(" "),s("p",[t._v("Rejected（已拒绝）")]),t._v(" "),s("p",[t._v("当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了\n状态就变成了 Resolved、没有完成失败了就变成了 Rejected。")]),t._v(" "),s("p",[t._v("（2）Promise 的实例有两个过程：")]),t._v(" "),s("p",[t._v("pending -> fulfilled : Resolved（已完成）")]),t._v(" "),s("p",[t._v("pending -> rejected：Rejected（已拒绝）")]),t._v(" "),s("p",[t._v("注意：一旦从进行状态变成为其他状态就永远不能更改状态了。")]),t._v(" "),s("p",[t._v("Promise 的特点：")]),t._v(" "),s("p",[t._v("对象的状态不受外界影响。promise 对象代表一个异步操作，有三种\n状态，pending（进行中）、fulfilled（已成功）、rejected（已失\n败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他\n操作都无法改变这个状态，这也是 promise 这个名字的由来——“承\n诺”；")]),t._v(" "),s("p",[t._v("一旦状态改变就不会再变，任何时候都可以得到这个结果。promise\n对象的状态改变，只有两种可能：从 pending 变为 fulfilled，从\npending 变为 rejected。这时就称为 resolved（已定型）。如果改\n变已经发生了，你再对 promise 对象添加回调函数，也会立即得到这\n个结果。这与事件（event）完全不同，事件的特点是：如果你错过\n了它，再去监听是得不到结果的。")]),t._v(" "),s("p",[t._v("Promise 的缺点：")]),t._v(" "),s("p",[t._v("无法取消 Promise，一旦新建它就会立即执行，无法中途取消。\n如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。\n当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始\n还是即将完成）。")]),t._v(" "),s("p",[t._v("总结：")]),t._v(" "),s("p",[t._v("Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise\n是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。\n一个 Promise 实例有三种状态，分别是 pending、resolved 和\nrejected，分别代表了进行中、已成功和已失败。实例的状态只能由\npending 转变 resolved 或者 rejected 状态，并且状态一经改变，\n就凝固了，无法再被改变了。")]),t._v(" "),s("p",[t._v("状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在\n异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原\n型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的\n改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的\n末尾执行。")]),t._v(" "),s("p",[t._v("注意：在构造 Promise 的时候，构造函数内部的代码是立即执行的")]),t._v(" "),s("h2",{attrs:{id:"对-async-await-的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对-async-await-的理解"}},[t._v("#")]),t._v(" 对 async/await 的理解")]),t._v(" "),s("p",[t._v("async/await 其实是 Generator 的语法糖，它能实现的效果都能用\nthen 链来实现，它是为优化 then 链而开发出来的。从字面上来看，\nasync 是“异步”的简写，await 则为等待，所以很好理解 async 用\n于申明一个 function 是异步的，而 await 用于等待一个异步方法\n执行完成。")]),t._v(" "),s("p",[t._v("优势：")]),t._v(" "),s("p",[t._v("单一的 Promise 链并不能发现 async/await 的优势，但是，如果需\n要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。")]),t._v(" "),s("h2",{attrs:{id:"async-await-对比-promise-的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-await-对比-promise-的优势"}},[t._v("#")]),t._v(" async/await 对比 Promise 的优势")]),t._v(" "),s("p",[t._v("代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的\n链式调⽤也会带来额外的阅读负担")]),t._v(" "),s("p",[t._v("Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅")]),t._v(" "),s("p",[t._v("错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的\n错误捕获⾮常冗余")]),t._v(" "),s("p",[t._v("调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返\n回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤\n调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代\n码块，因为调试器只能跟踪同步代码的每⼀步。")]),t._v(" "),s("h2",{attrs:{id:"对象创建的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象创建的方式有哪些"}},[t._v("#")]),t._v(" 对象创建的方式有哪些？")]),t._v(" "),s("p",[t._v("一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大\n量相似对象的时候，会产生大量的重复代码。但 js 和一般的面向对\n象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来\n进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：")]),t._v(" "),s("ul",[s("li",[t._v("（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装\n创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一\n个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是\n简单的封装了复用代码，而没有建立起对象和类型间的关系。")]),t._v(" "),s("li",[t._v("（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，\n只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。\n执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数\n的 prototype 属性，然后将执行上下文中的 this 指向这个对象，\n最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因\n为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。\n构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建\n立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存\n在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函\n数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次\n都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有\n的实例都可以通用的。")]),t._v(" "),s("li",[t._v("（3）第三种模式是原型模式，因为每一个函数都有一个 prototype\n属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例\n都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方\n法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决\n了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有\n办法通过传入参数来初始化值，另一个是如果存在一个引用类型如\nArray 这样的值，那么所有的实例将共享一个对象，一个实例对引用\n类型值的改变会影响所有的实例。")]),t._v(" "),s("li",[t._v("（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自\n定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存\n在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化\n对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的\n解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使\n用了两种不同的模式，所以对于代码的封装性不够好。")]),t._v(" "),s("li",[t._v("（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创\n建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以\n实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式\n很好地对上面的混合模式进行了封装。")]),t._v(" "),s("li",[t._v("（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实\n现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，\n在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函\n数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法\n实现对象的识别。")])]),t._v(" "),s("h2",{attrs:{id:"对象继承的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象继承的方式有哪些"}},[t._v("#")]),t._v(" 对象继承的方式有哪些？")]),t._v(" "),s("ul",[s("li",[t._v("（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在\n的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，\n容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传\n递参数。")]),t._v(" "),s("li",[t._v("（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子\n类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不\n能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函\n数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。")]),t._v(" "),s("li",[t._v("（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数\n组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属\n性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继\n承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我\n们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构\n造函数，造成了子类型的原型中多了很多不必要的属性。")]),t._v(" "),s("li",[t._v("（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已\n有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，\n然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为\n了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5\n中定义的 Object.create() 方法就是原型式继承的实现。缺点与原\n型链方式相同。")]),t._v(" "),s("li",[t._v("（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于\n封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，\n然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解\n是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这\n个对象不是自定义类型时。缺点是没有办法实现函数的复用。")]),t._v(" "),s("li",[t._v("（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类\n型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式\n组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这\n样就避免了创建不必要的属性")])]),t._v(" "),s("h2",{attrs:{id:"哪些情况会导致内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哪些情况会导致内存泄漏"}},[t._v("#")]),t._v(" 哪些情况会导致内存泄漏")]),t._v(" "),s("ul",[s("li",[t._v("意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局\n变量，而使这个变量一直留在内存中无法被回收。")]),t._v(" "),s("li",[t._v("被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记\n取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被\n一直留在内存中，而无法被回收。")]),t._v(" "),s("li",[t._v("脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删\n除，由于一直保留了对这个元素的引用，所以它也无法被回收。")]),t._v(" "),s("li",[t._v("闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中")])])])}),[],!1,null,null,null);s.default=e.exports}}]);