(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{412:function(t,e,n){"use strict";n.r(e);var s=n(12),a=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"webpack从入门到精通-四"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack从入门到精通-四"}},[t._v("#")]),t._v(" webpack从入门到精通(四)")]),t._v(" "),e("p",[t._v("今天我们来学习webpack的其他配置----module")]),t._v(" "),e("h2",{attrs:{id:"module"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#module"}},[t._v("#")]),t._v(" module")]),t._v(" "),e("p",[t._v("这个module有什么用呢，它可以让我们把webpack里的模块通过配置，定义的规则变成我们想要的东西，因为webpack只知道js文件，其他的如less，sass，es6等等其他的文件那就无法识别，所以就需要我们去定义规则让webpack可以识别去编译对应的文件让生成浏览器可以识别的html，css，js，而想要编译打包这些文件就需要借助loader，官方的介绍也是这样:")]),t._v(" "),e("p",[e("img",{attrs:{src:"/webpacks/20200321093938279.png",alt:""}})]),t._v(" "),e("p",[t._v("现在我们就来试试从样式开始，从之前的配置我们可以看到，我们没有样式css，那要什么引入呢，这里就是要通过import来注入对应的样式，不过之前我们也说过，webpack只是别js文件，所以为了让webpack可以正确的编译css，我们需要两个插件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("style-loader   //把处理完的css放到style标签里\ncss-loader     //处理css\n")])])]),e("p",[t._v("第一步还是通过安装包:")]),t._v(" "),e("p",[e("code",[t._v("npm i style-loader css-loader -D")])]),t._v(" "),e("p",[t._v("然后添加css文件，并写样式:")]),t._v(" "),e("p",[e("img",{attrs:{src:"/webpacks/1602511654150.jpg",alt:""}})]),t._v(" "),e("p",[t._v("在webpack.config.js配置解析CSS文件:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("module: {\n\trules: [{\n\t\ttest: /\\.css$/, //以点开始css结尾的文件\n\t\tuse: ['style-loader', 'css-loader'] //顺序不能搞错\n\t}]\n},\n\n")])])]),e("p",[t._v("在前面讲到，入口文件在entry指定的文件里，在入口文件里引入样式，路径对应自己创建的css文件路径")]),t._v(" "),e("p",[e("code",[t._v("import '../css/index.css';")])]),t._v(" "),e("p",[t._v("最后我们只需一下 npm run dev 就会看见 我们写的样式会被编译在html文件里面了")]),t._v(" "),e("p",[e("img",{attrs:{src:"/webpacks/1602515613543.jpg",alt:""}})]),t._v(" "),e("p",[t._v("这里我们会发现webpack把所有的css都直接引入到头部了，如果样式少的话那还可以，但如果样式太多了话就会导致加载缓慢，样式冲突，命名重叠等问题，这样我们可以使用"),e("a",{attrs:{href:"https://www.cnblogs.com/blackgan/p/10590540.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("mini-css-extract-plugin"),e("OutboundLink")],1),t._v("它将css单独打包成一个文件的插件，它为每个包含css的js文件都创建了一个css文件。它支持css和sourceMaps的按需加载。目前只有在webpack v4版本才支持使用的该插件")]),t._v(" "),e("p",[t._v("引入插件 mini-css-extract-plugin")]),t._v(" "),e("p",[e("code",[t._v("npm i mini-css-extract-plugin -D")])]),t._v(" "),e("p",[t._v("在webpack.config.js配置:")]),t._v(" "),e("p",[e("code",[t._v('const MiniCssExtractPlugin=require("mini-css-extract-plugin");')])]),t._v(" "),e("p",[t._v("在plugins里面写入，要在生成html之前，不然不会生效:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("plugins: [\n \n\tnew MiniCssExtractPlugin({\n\t\tfilename: 'css/index.css' //文件目录会放入output.path里\n\t}),\n],\n\n")])])]),e("p",[t._v("修改之前的module:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('module: {\n\trules: [{\n\t\ttest: /\\.css$/,\n\t\tuse: [MiniCssExtractPlugin.loader, "css-loader"] //代替style-loader\n\t}]\n},\n')])])]),e("p",[t._v("完整的代码：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const path = require('path'); //nodejs的语法，引入路径模块，为了输出的时候找绝对路径\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst webpack=require('webpack');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin'); //引入清除文件插件\nmodule.exports = {\n\t// entry: ['./js/index.js', './js/two.js', ],\n\tentry: {\n\t\tone: './js/index.js',\n\t\ttwo: ['./js/two.js', ],\n\t}, //入口文件为main.js  \n\toutput: { //输出\n\t\tpath: path.resolve(__dirname, 'dist'), //path.resolve为nodejs的固定语法，用于找到当前文件的绝对路径\n\t\t// filename: 'bundle.js' ,//输出的文件名\n\t\tfilename: '[name].bundle.js' //可以以name/id/hash放在中括号里区分文件名\n\t},\n\tdevServer:{//开发服务器的配置\n        open:true,//自动打开\n        port:3000,//端口\n        progress:true,\n        contentBase:path.join(__dirname, \"dist\"),//指向资源函数，默认是指向配置dist文件\n        compress:true,\n        headers:{\n            'token':'231'\n        },//请求头\n        historyApiFallback:true,\n        ////devServer默认行为是在发行源代码被更新后通过自动刷新整个页面来做到实时预览的，\n        //开启模块热替换功能后,它是通过在不刷新整个页面的情况下通过使用新模块替换旧模块来做到实时预览的 \n        //在package.json 配置 --hot 或者引入webpack的HotModuleReplacementPlugin热更新\n\t\t//使用后module里面的MiniCssExtractPlugin.loader改成\"style-loader\",仅限开发环境用\n        //hot:true,\n\t\t//即便HMR没有生效，浏览器也不会自动刷新\n        //hotOnly: true\n    },\n\tplugins: [\n\t\tnew CleanWebpackPlugin(), //位置放在最上面，作用是先删除dist目录再创建新的dist目录。参数在npm官网上有 默认会去清除output.path里的路径，webpack的output.path目录中的所有文件将被删除一次，但是目录本身不会被删除\n\t\tnew MiniCssExtractPlugin({\n\t\t\tfilename: 'css/index.css' //文件目录会放入output.path里\n\t\t}),\n\t\tnew HtmlWebpackPlugin({\n\t\t\ttitle: '贪吃的猫',\n\t\t\t/*这个值对应html里的title值 配置该项，它并不会替换指定模板文件中的title元素的内容，除非html模板文件中使用了模板引擎语法来获取该配置项值， <title><%= htmlWebpackPlugin.options.title %></title>*/\n\t\t\ttemplate: path.join(__dirname, 'default_index.ejs'), //模板文件地址。可以自定义模板\n\t\t\tfilename: 'index.html', //文件名，默认为index.html（路径相对于output.path的值）   还可以为输出文件指定目录位置（例如'html/index.html'）\n\t\t\thash: false, //true|false，是否为所有注入的静态资源添加webpack每次编译产生的唯一hash值，添加hash形式如下所示：html <script type=\"text/javascript\" src=\"common.js?a3e1396b501cdd9041be\"><\/script>\n\t\t\t/* \n\t\t\t 允许插入到模板中的一些chunk，不配置此项默认会将entry中所有的thunk注入到模板中。在配置多个页面时，每个页面注入的thunk应该是不相同的，需要通过该配置为不同页面注入不同的thunk；\n\t\t\t chunks: 'all', 所有的都引入\n\t\t\t chunks: ['one'],  引入对应的JS 如果有多个相同的  可以通过 entry的 key : array 引入 如 \n\t\t\t entry: {\n\t\t\t \tone: './js/index.js',\n\t\t\t \ttwo: ['./js/index.js', './js/two.js', ],\n\t\t\t },\n\t\t\t */\n\t\t\tchunks: 'all',\n\t\t\texcludeChunks: [], //这个与chunks配置项正好相反，用来配置不允许注入的thunk。 \t\t\t\n\t\t\txhtml: false, //true|fasle, 默认false；是否渲染link为自闭合的标签，true则为自闭合标签\n\t\t\tinject: true, //向template或者templateContent中注入所有静态资源，不同的配置值注入的位置不经相同 1、true或者body：所有JavaScript资源插入到body元素的底部 2、head: 所有JavaScript资源插入到head元素中 3、false： 所有静态资源css和JavaScript都不会注入到模板文件中\n\t\t\tminify: { //html-webpack-plugin内部集成了html-minifier\n\t\t\t\tcollapseWhitespace: true, //压缩空格\n\t\t\t\tremoveAttributeQuotes: true, //移除引号\n\t\t\t\tremoveComments: true, //移除注释\n\t\t\t},\n\t\t}),\n\t\t//new webpack.HotModuleReplacementPlugin(),    //引入热更新插件\n\t],\n\tmodule: {\n\t\trules: [{\n\t\t\ttest: /\\.css$/,\n\t\t\tuse: [MiniCssExtractPlugin.loader, \"css-loader\"] //代替style-loader\n\t\t}]\n\t},\n}\n")])])]),e("p",[t._v("执行一下 npm run build会发现在dist会生成一个新的css文件，而我们的HMLT也增加了新的LINK标签")]),t._v(" "),e("p",[t._v("更多配置 "),e("a",{attrs:{href:"https://github.com/webpack-contrib/mini-css-extract-plugin",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/webpack-contrib/mini-css-extract-plugin"),e("OutboundLink")],1),t._v(" 去GitHub上查看")]),t._v(" "),e("h2",{attrs:{id:"图片的处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图片的处理"}},[t._v("#")]),t._v(" 图片的处理")]),t._v(" "),e("p",[t._v("上面处理CSS用到了插件，所以处理图片我们也要用到插件 这次我们用的是:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("file-loader   //解析地址\nurl-loader    //把图片地址解析成base64\n")])])]),e("p",[t._v("引入插件:")]),t._v(" "),e("p",[e("code",[t._v("npm i file-loader url-loader -D")])]),t._v(" "),e("p",[t._v("在webpack.config.js的module配置规则编译")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("module: {\n\trules: [\n\t\t{\n\t\t\ttest: /\\.(jpg|png|gif)$/, // 在jpg,png,gif找其中  也可以添加多个\n\t\t\tuse: {\n\t\t\t\t\"loader\" : 'file-loader',\n\t\t\t\toptions : {\n\t\t\t\t\toutputPath : 'img/', //会在dist文件生成对应的图片文件夹\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t]\n},\n\n")])])]),e("p",[t._v("完整的配置:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const path = require('path'); //nodejs的语法，引入路径模块，为了输出的时候找绝对路径\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\nconst webpack=require('webpack');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin'); //引入清除文件插件\nmodule.exports = {\n\t// entry: ['./js/index.js', './js/two.js', ],\n\tentry: {\n\t\tone: './js/index.js',\n\t\ttwo: ['./js/two.js', ],\n\t}, //入口文件为main.js  \n\toutput: { //输出\n\t\tpath: path.resolve(__dirname, 'dist'), //path.resolve为nodejs的固定语法，用于找到当前文件的绝对路径\n\t\t// filename: 'bundle.js' ,//输出的文件名\n\t\tfilename: '[name].bundle.js' //可以以name/id/hash放在中括号里区分文件名\n\t},\n\tdevServer:{//开发服务器的配置\n        open:true,//自动打开\n        port:3000,//端口\n        progress:true,\n        contentBase:path.join(__dirname, \"dist\"),//指向资源函数，默认是指向配置dist文件\n        compress:true,\n        headers:{\n            'token':'231'\n        },//请求头\n        historyApiFallback:true,\n        ////devServer默认行为是在发行源代码被更新后通过自动刷新整个页面来做到实时预览的，\n        //开启模块热替换功能后,它是通过在不刷新整个页面的情况下通过使用新模块替换旧模块来做到实时预览的 \n        //在package.json 配置 --hot 或者引入webpack的HotModuleReplacementPlugin热更新\n\t\t//使用后module里面的MiniCssExtractPlugin.loader改成\"style-loader\",仅限开发环境用\n        //hot:true,\n\t\t//即便HMR没有生效，浏览器也不会自动刷新\n        //hotOnly: true\n    },\n\tplugins: [\n\t\tnew CleanWebpackPlugin(), //位置放在最上面，作用是先删除dist目录再创建新的dist目录。参数在npm官网上有 默认会去清除output.path里的路径，webpack的output.path目录中的所有文件将被删除一次，但是目录本身不会被删除\n\t\tnew MiniCssExtractPlugin({\n\t\t\tfilename: 'css/index.css' //文件目录会放入output.path里\n\t\t}),\n\t\tnew HtmlWebpackPlugin({\n\t\t\ttitle: '贪吃的猫',\n\t\t\t/*这个值对应html里的title值 配置该项，它并不会替换指定模板文件中的title元素的内容，除非html模板文件中使用了模板引擎语法来获取该配置项值， <title><%= htmlWebpackPlugin.options.title %></title>*/\n\t\t\ttemplate: path.join(__dirname, 'default_index.ejs'), //模板文件地址。可以自定义模板\n\t\t\tfilename: 'index.html', //文件名，默认为index.html（路径相对于output.path的值）   还可以为输出文件指定目录位置（例如'html/index.html'）\n\t\t\thash: false, //true|false，是否为所有注入的静态资源添加webpack每次编译产生的唯一hash值，添加hash形式如下所示：html <script type=\"text/javascript\" src=\"common.js?a3e1396b501cdd9041be\"><\/script>\n\t\t\t/* \n\t\t\t 允许插入到模板中的一些chunk，不配置此项默认会将entry中所有的thunk注入到模板中。在配置多个页面时，每个页面注入的thunk应该是不相同的，需要通过该配置为不同页面注入不同的thunk；\n\t\t\t chunks: 'all', 所有的都引入\n\t\t\t chunks: ['one'],  引入对应的JS 如果有多个相同的  可以通过 entry的 key : array 引入 如 \n\t\t\t entry: {\n\t\t\t \tone: './js/index.js',\n\t\t\t \ttwo: ['./js/index.js', './js/two.js', ],\n\t\t\t },\n\t\t\t */\n\t\t\tchunks: 'all',\n\t\t\texcludeChunks: [], //这个与chunks配置项正好相反，用来配置不允许注入的thunk。 \t\t\t\n\t\t\txhtml: false, //true|fasle, 默认false；是否渲染link为自闭合的标签，true则为自闭合标签\n\t\t\tinject: true, //向template或者templateContent中注入所有静态资源，不同的配置值注入的位置不经相同 1、true或者body：所有JavaScript资源插入到body元素的底部 2、head: 所有JavaScript资源插入到head元素中 3、false： 所有静态资源css和JavaScript都不会注入到模板文件中\n\t\t\tminify: { //html-webpack-plugin内部集成了html-minifier\n\t\t\t\tcollapseWhitespace: true, //压缩空格\n\t\t\t\tremoveAttributeQuotes: true, //移除引号\n\t\t\t\tremoveComments: true, //移除注释\n\t\t\t},\n\t\t}),\n\t\t//new webpack.HotModuleReplacementPlugin(),    //引入热更新插件\n\t],\n\tmodule: {\n\t\trules: [\n\t\t\t{\n\t\t\t\ttest: /\\.css$/,\n\t\t\t\tuse: [MiniCssExtractPlugin.loader, \"css-loader\"] //代替style-loader\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest: /\\.(jpg|png|gif)$/, // 在jpg,png,gif找其中  也可以添加多个\n\t\t\t\tuse: {\n\t\t\t\t\t\"loader\" : 'file-loader',\n\t\t\t\t\toptions : {\n\t\t\t\t\t\toutputPath : 'img/', //会在dist文件生成对应的图片文件夹\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t]\n\t},\n}\n")])])]),e("p",[t._v("我们执行一下npm run build 会看见在dist文件夹生成一个 img的文件夹  里面放着对应的图片")]),t._v(" "),e("p",[e("img",{attrs:{src:"/webpacks/1602517128635.jpg",alt:""}})]),t._v(" "),e("p",[t._v("一些相关的配置，更多配置去webpack官网插件查看 "),e("a",{attrs:{href:"https://www.webpackjs.com/loaders/file-loader/",target:"_blank",rel:"noopener noreferrer"}},[t._v("file-loader"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:"/webpacks/1602517216166.jpg",alt:""}})]),t._v(" "),e("p",[t._v("用了file-loader，我们还有一个url-loader，这个的话 就可以把对于的图片转换成base64图片，因为在前几步我们已经引入了。所以这里我们直接引用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("module: {\n\trules: [\n\t\n\t\t/* 转换图片的 \n\t\turl-loader */\n\t\t{\n\t\t\ttest: /\\.(jpg|png|gif)$/,\n\t\t\t//use:['file-loader']\n\t\t\tuse: [{\n\t\t\t\tloader: 'url-loader', //把图片转成base64\n\t\t\t\toptions: {\n\t\t\t\t\tlimit: 50 * 1024, //小于50k就会转成base64\n\t\t\t\t\toutputPath: 'img'\n\t\t\t\t}\n\t\t\t}]\n\t\t}\n\t]\n},\n\n")])])]),e("p",[t._v("我们在执行一下 npm run build 会发现引入的图片已经变成base64编码的图片了。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/webpacks/1602517357096.jpg",alt:""}})]),t._v(" "),e("p",[t._v("这里用了url-loader，并没有用file-loader，说明url-loader里已经包含了file-loader的功能")]),t._v(" "),e("p",[t._v("一些相关的配置，更多配置去webpack官网插件查看 "),e("a",{attrs:{href:"https://www.webpackjs.com/loaders/url-loader/",target:"_blank",rel:"noopener noreferrer"}},[t._v("url-loader"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);