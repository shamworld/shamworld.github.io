(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{338:function(t,v,_){"use strict";_.r(v);var a=_(12),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http-基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-基础"}},[t._v("#")]),t._v(" http 基础")]),t._v(" "),v("h2",{attrs:{id:"浏览器输入-url-按回车背后经历了哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器输入-url-按回车背后经历了哪些"}},[t._v("#")]),t._v(" 浏览器输入 url 按回车背后经历了哪些?")]),t._v(" "),v("ul",[v("li",[t._v("在浏览器地址栏输入 url，先解析 ulr，检测 url 地址是否合法")]),t._v(" "),v("li",[t._v("浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。\n"),v("ul",[v("li",[t._v("浏览器缓存:浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；")]),t._v(" "),v("li",[t._v("操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的 DNS 查询缓存)；")]),t._v(" "),v("li",[t._v("路由器缓存:如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存")]),t._v(" "),v("li",[t._v("ISP 缓存:若上述均失败，继续向 ISP 搜索。")])])]),t._v(" "),v("li",[t._v("在发送 http 请求前，需要域名解析(DNS 解析)，解析获取响应的 IP 地址")]),t._v(" "),v("li",[t._v("浏览器向服务器发送 tcp 链接，与浏览器简历 tcp 三次握手。")]),t._v(" "),v("li",[t._v("握手成功后，浏览器向服务器发送 http 请求，请求数据包。")]),t._v(" "),v("li",[t._v("服务器处理收到的请求，将数据返回至浏览器。")]),t._v(" "),v("li",[t._v("浏览器收到 http 响应。")]),t._v(" "),v("li",[t._v("浏览器解码响应，如果响应可以缓存，则存入缓存。")]),t._v(" "),v("li",[t._v("浏览器发送请求获取嵌入在 HTML 中的资源(html，css，JavaScript，图片，音乐......)。")]),t._v(" "),v("li",[t._v("浏览器发送异步请求。")]),t._v(" "),v("li",[t._v("页面全部渲染结束。")])]),t._v(" "),v("h2",{attrs:{id:"get-和-post-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[t._v("#")]),t._v(" GET 和 POST 的区别")]),t._v(" "),v("ul",[v("li",[t._v("GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。")]),t._v(" "),v("li",[t._v("GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。")]),t._v(" "),v("li",[t._v("GET 请求只能进行 url 编码，而 POST 支持多种编码方式。")]),t._v(" "),v("li",[t._v("GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。")]),t._v(" "),v("li",[t._v("GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。")]),t._v(" "),v("li",[t._v("对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。")]),t._v(" "),v("li",[t._v("GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。")]),t._v(" "),v("li",[t._v("GET 参数通过 URL 传递，POST 放在 Request body 中。")])]),t._v(" "),v("p",[t._v("GET 和 POST 有一个重大区别，简单的说：")]),t._v(" "),v("p",[v("strong",[t._v("GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。")])]),t._v(" "),v("p",[t._v("长的说：")]),t._v(" "),v("p",[v("strong",[t._v("对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；\n而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。")])]),t._v(" "),v("h3",{attrs:{id:"localstorage-与-sessionstorage-与-cookie-的区别总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#localstorage-与-sessionstorage-与-cookie-的区别总结"}},[t._v("#")]),t._v(" localStorage 与 sessionStorage 与 cookie 的区别总结")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("共同点")]),t._v(": 都保存在浏览器端, 且同源")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("在同一浏览器下生命周期不同")])]),t._v(" "),v("p",[t._v("Cookie 生命周期: 默认是关闭浏览器后失效, 但是也可以设置过期时间")]),t._v(" "),v("p",[t._v("SessionStorage 生命周期: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间")]),t._v(" "),v("p",[t._v("LocalStorage 生命周期:除非被清除，否则永久保存")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("容量不同")])]),t._v(" "),v("p",[t._v("Cookie 容量限制: 大小(4KB 左右)和个数(20~50)")]),t._v(" "),v("p",[t._v("SessionStorage 和 LocalStorage 容量限制: 大小(5M 左右)")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("网络请求不同")])]),t._v(" "),v("p",[t._v("Cookie 网络请求:每次都会携带在 HTTP 请求头中，如果使用 cookie 保存过多数据会带来性能问题")]),t._v(" "),v("p",[t._v("SessionStorage 和 LocalStorage 网络请求: 仅在浏览器中保存，不参与和服务器的通信")])])]),t._v(" "),v("h2",{attrs:{id:"http-状态码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[t._v("#")]),t._v(" HTTP 状态码")]),t._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),t._v(" 请求已成功，请求所希望的响应头或数据体将随此响应返回。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("201")]),t._v(" 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 "),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("URI")]),t._v(" 已经随Location 头信息返回\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("202")]),t._v(" 服务器已接受请求，但尚未处理\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("301")]),t._v(" （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 "),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" 或 "),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HEAD")]),t._v(" 请求的响应）时，会自动将请求者转到新位置。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("302")]),t._v(" （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("303")]),t._v(" （查看其他位置） 请求者应当对不同的位置使用单独的 "),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v(" 请求来检索响应时，服务器返回此代码。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("304")]),t._v(" （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("305")]),t._v(" （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("307")]),t._v(" （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("401")]),t._v(" 当前请求需要用户验证。如果当前请求已经包含了 Authorization 证书，那么"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("401")]),t._v("响应代表着服务器验证已经拒绝了那些证书\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("403")]),t._v(" 服务器已经理解请求，但是拒绝执行它。与"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("401")]),t._v("响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("404")]),t._v(" 请求失败，请求所希望得到的资源未被在服务器上发现\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),t._v(" 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("501")]),t._v(" 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("502")]),t._v(" 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n"),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("503")]),t._v(" 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。\n")])])]),v("h2",{attrs:{id:"http-和-https-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https-区别"}},[t._v("#")]),t._v(" http 和 https 区别？")]),t._v(" "),v("p",[t._v("HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是王景公司设计了 SSL 协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单的说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输，身份认证的网络协议，要比 http 协议安全。")]),t._v(" "),v("p",[t._v("主要区别如下:")]),t._v(" "),v("p",[t._v("HTTPS = SSL + HTTP")]),t._v(" "),v("ul",[v("li",[t._v("https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。")]),t._v(" "),v("li",[t._v("http 是超文本传输协议，信息是明文传输，https 是具有安全性的 ssl 加密传输协议。")]),t._v(" "),v("li",[t._v("http 和 https 使用的完全不同的链接方式，用的端口也不一样，前者是 80，后者是 443。")]),t._v(" "),v("li",[t._v("http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+ HTTP 协议构建的可进行加密传输，身份认证的网络协议，比如 http 协议安全。")])]),t._v(" "),v("h2",{attrs:{id:"什么是-http-协议无状态协议-怎么解决-http-协议无状态协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-http-协议无状态协议-怎么解决-http-协议无状态协议"}},[t._v("#")]),t._v(" 什么是 Http 协议无状态协议?怎么解决 Http 协议无状态协议?")]),t._v(" "),v("ul",[v("li",[t._v("无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息")]),t._v(" "),v("li",[t._v("无状态协议解决办法： 通过 1、Cookie 2、通过 Session 会话保存")])]),t._v(" "),v("h2",{attrs:{id:"三次握手和四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手和四次挥手"}},[t._v("#")]),t._v(" 三次握手和四次挥手")]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/note/knowledge/tcp.html"}},[t._v("三次握手和四次挥手")])],1),t._v(" "),v("h2",{attrs:{id:"为什么连接的时候是三次握手-关闭的时候却是四次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么连接的时候是三次握手-关闭的时候却是四次握手"}},[t._v("#")]),t._v(" 为什么连接的时候是三次握手，关闭的时候却是四次握手？")]),t._v(" "),v("p",[t._v('因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，"你发的 FIN 报文我收到了"。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。')]),t._v(" "),v("h2",{attrs:{id:"为什么-time-wait-状态需要经过-2msl-最大报文段生存时间-才能返回到-close-状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么-time-wait-状态需要经过-2msl-最大报文段生存时间-才能返回到-close-状态"}},[t._v("#")]),t._v(" 为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？")]),t._v(" "),v("p",[t._v("虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。在 Client 发送出最后的 ACK 回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送 FIN 片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出 ACK 之后进入到 TIME_WAIT 状态。Client 会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。")]),t._v(" "),v("h2",{attrs:{id:"为什么不能用两次握手进行连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能用两次握手进行连接"}},[t._v("#")]),t._v(" 为什么不能用两次握手进行连接？")]),t._v(" "),v("p",[t._v("3 次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。")]),t._v(" "),v("p",[t._v("现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机 S 和 C 之间的通信，假定 C 给 S 发送一个连接请求分组，S 收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S 认为连接已经成功地建立了，可以开始发送数据分组。可是，C 在 S 的应答分组在传输中被丢失的情况下，将不知道 S 是否已准备好，不知道 S 建立什么样的序列号，C 甚至怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分 组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。")]),t._v(" "),v("h2",{attrs:{id:"如果已经建立了连接-但是客户端突然出现故障了怎么办"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如果已经建立了连接-但是客户端突然出现故障了怎么办"}},[t._v("#")]),t._v(" 如果已经建立了连接，但是客户端突然出现故障了怎么办？")]),t._v(" "),v("p",[t._v("TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。")]),t._v(" "),v("h2",{attrs:{id:"什么是-xss-攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-xss-攻击"}},[t._v("#")]),t._v(" 什么是 XSS 攻击？")]),t._v(" "),v("h3",{attrs:{id:"概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),v("p",[t._v("XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在\n网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信\n息如 cookie 等。")]),t._v(" "),v("p",[t._v("XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合\n在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意\n代码的执行。")]),t._v(" "),v("p",[t._v("攻击者可以通过这种攻击方式可以进行以下操作：")]),t._v(" "),v("ul",[v("li",[t._v("获取页面的数据，如 DOM、cookie、localStorage；")]),t._v(" "),v("li",[t._v("DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；")]),t._v(" "),v("li",[t._v("破坏页面结构；")]),t._v(" "),v("li",[t._v("流量劫持（将链接指向某网站）；")])]),t._v(" "),v("h3",{attrs:{id:"攻击类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#攻击类型"}},[t._v("#")]),t._v(" 攻击类型")]),t._v(" "),v("p",[t._v("XSS 可以分为存储型、反射型和 DOM 型：\n存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，\n脚本从服务器传回并执行。")]),t._v(" "),v("p",[t._v("反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服\n务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，\n浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。")]),t._v(" "),v("p",[t._v("DOM 型指的通过修改页面的 DOM 节点形成的 XSS。")]),t._v(" "),v("h4",{attrs:{id:"存储型-xss-的攻击步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#存储型-xss-的攻击步骤"}},[t._v("#")]),t._v(" 存储型 XSS 的攻击步骤：")]),t._v(" "),v("ul",[v("li",[t._v("攻击者将恶意代码提交到⽬标⽹站的数据库中。")]),t._v(" "),v("li",[t._v("⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接\n在 HTML 中返回给浏览器。")]),t._v(" "),v("li",[t._v("⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。")]),t._v(" "),v("li",[t._v("恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏\n为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评\n论、⽤户私信等。")])]),t._v(" "),v("h4",{attrs:{id:"反射型-xss-的攻击步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#反射型-xss-的攻击步骤"}},[t._v("#")]),t._v(" 反射型 XSS 的攻击步骤：")]),t._v(" "),v("ul",[v("li",[t._v("攻击者构造出特殊的 URL，其中包含恶意代码。")]),t._v(" "),v("li",[t._v("⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL\n中取出，拼接在 HTML 中返回给浏览器。")]),t._v(" "),v("li",[t._v("⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。")]),t._v(" "),v("li",[t._v("恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏\n为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在\n数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。")])]),t._v(" "),v("p",[t._v("反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳\n转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会\n结合多种⼿段诱导⽤户点击。")]),t._v(" "),v("h4",{attrs:{id:"dom-型-xss-的攻击步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dom-型-xss-的攻击步骤"}},[t._v("#")]),t._v(" DOM 型 XSS 的攻击步骤：")]),t._v(" "),v("ul",[v("li",[t._v("攻击者构造出特殊的 URL，其中包含恶意代码。")]),t._v(" "),v("li",[t._v("⽤户打开带有恶意代码的 URL。")]),t._v(" "),v("li",[t._v("⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL\n中的恶意代码并执⾏。")]),t._v(" "),v("li",[t._v("恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏\n为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。")])]),t._v(" "),v("p",[t._v("DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执\n⾏恶意代码由浏览器端完成，属于前端 JavaScript ⾃身的安全漏洞，\n⽽其他两种 XSS 都属于服务端的安全漏洞。")]),t._v(" "),v("h2",{attrs:{id:"如何防御-xss-攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何防御-xss-攻击"}},[t._v("#")]),t._v(" 如何防御 XSS 攻击？")]),t._v(" "),v("p",[t._v("可以看到 XSS 危害如此之大，那么在开发网站时就要做好防御措施，\n具体措施如下：")]),t._v(" "),v("p",[t._v("可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服\n务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到\nHTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚\n本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对\n可能出现的恶意代码情况进行判断。")]),t._v(" "),v("p",[t._v("使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资\n源可以加载和执行，从而防止恶意代码的注入攻击。")]),t._v(" "),v("p",[t._v("1.CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览\n器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由\n浏览器自己来实现。")]),t._v(" "),v("p",[t._v("2.通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的\nContent-Security-Policy，一种是设置 meta 标签的方式 ")]),v("meta",{attrs:{"http-equiv":"Content-Security-Policy"}}),t._v("\n对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本\n无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。"),v("p"),t._v(" "),v("h2",{attrs:{id:"什么是-csrf-攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-csrf-攻击"}},[t._v("#")]),t._v(" 什么是 CSRF 攻击？")]),t._v(" "),v("h3",{attrs:{id:"概念-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概念-2"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),v("p",[t._v("CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三\n方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击\n网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过\n后台的用户验证，冒充用户向服务器执行一些操作。")]),t._v(" "),v("p",[t._v("CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器\n的特点，以此来实现用户的冒充。")]),t._v(" "),v("h3",{attrs:{id:"攻击类型-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#攻击类型-2"}},[t._v("#")]),t._v(" 攻击类型")]),t._v(" "),v("p",[t._v("常见的 CSRF 攻击有三种：")]),t._v(" "),v("ul",[v("li",[t._v("GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个\n请求，当用户打开这个网站的时候就会自动发起提交。")]),t._v(" "),v("li",[t._v("POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户\n进入页面时，自动提交这个表单。")]),t._v(" "),v("li",[t._v("链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请\n求，然后诱导用户去点击。")])]),t._v(" "),v("h2",{attrs:{id:"有哪些可能引起前端安全的问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#有哪些可能引起前端安全的问题"}},[t._v("#")]),t._v(" 有哪些可能引起前端安全的问题?")]),t._v(" "),v("p",[t._v("跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了\n与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没\n有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖\n⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不\n限于 JavaScript / CSS / Flash 等；")]),t._v(" "),v("p",[t._v("iframe 的滥⽤: iframe 中的内容是由第三⽅来提供的，默认情况下\n他们不受控制，他们可以在 iframe 中运⾏ JavaScirpt 脚本、Flash\n插件、弹出对话框等等，这可能会破坏前端⽤户体验；")]),t._v(" "),v("p",[t._v("跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击\n者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信\n息或设定信息等某些状态更新，属于被动攻击；")]),t._v(" "),v("p",[t._v("恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数\n时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被\n植⼊恶意代码很容易引起安全问题。")]),t._v(" "),v("h2",{attrs:{id:"网络劫持有哪几种-如何防范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络劫持有哪几种-如何防范"}},[t._v("#")]),t._v(" 网络劫持有哪几种，如何防范？")]),t._v(" "),v("p",[t._v("⽹络劫持分为两种:")]),t._v(" "),v("p",[t._v("（1）DNS 劫持: (输⼊京东被强制跳转到淘宝这就属于 dns 劫持)")]),t._v(" "),v("p",[t._v("DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导⽤户流量到缓存服务器")]),t._v(" "),v("p",[t._v("302 跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可\n以进⾏劫持处理的,再对劫持的内存发起 302 跳转的回复，引导⽤户\n获取内容")]),t._v(" "),v("p",[t._v("（2）HTTP 劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于 http\n明⽂传输,运营商会修改你的 http 响应内容(即加⼴告)")]),t._v(" "),v("p",[t._v("（3）DNS 劫持由于涉嫌违法，已经被监管起来，现在很少会有 DNS\n劫持，⽽ http 劫持依然⾮常盛⾏，最有效的办法就是全站 HTTPS，将\nHTTP 加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。")]),t._v(" "),v("h2",{attrs:{id:"浏览器渲染进程的线程有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染进程的线程有哪些"}},[t._v("#")]),t._v(" 浏览器渲染进程的线程有哪些")]),t._v(" "),v("p",[t._v("浏览器的渲染进程的线程总共有五种：")]),t._v(" "),v("p",[t._v("（1）GUI 渲染线程")]),t._v(" "),v("p",[t._v("负责渲染浏览器页面，解析 HTML、CSS，构建 DOM 树、构建 CSSOM 树、\n构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，\n该线程就会执行。")]),t._v(" "),v("p",[t._v("注意：GUI 渲染线程和 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI\n线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时\n立即被执行。")]),t._v(" "),v("p",[t._v("（2）JS 引擎线程")]),t._v(" "),v("p",[t._v("JS 引擎线程也称为 JS 内核，负责处理 Javascript 脚本程序，解析\nJavascript 脚本，运行代码；JS 引擎线程一直等待着任务队列中任\n务的到来，然后加以处理，一个 Tab 页中无论什么时候都只有一个\nJS 引擎线程在运行 JS 程序；")]),t._v(" "),v("p",[t._v("注意：GUI 渲染线程与 JS 引擎线程的互斥关系，所以如果 JS 执行的\n时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。")]),t._v(" "),v("p",[t._v("（3）时间触发线程")]),t._v(" "),v("p",[t._v("时间触发线程属于浏览器而不是 JS 引擎，用来控制事件循环；当 JS\n引擎执行代码块如 setTimeOut 时（也可是来自浏览器内核的其他线\n程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件触发\n线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加\n到待处理队列的队尾，等待 JS 引擎的处理；")]),t._v(" "),v("p",[t._v("注意：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排\n队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）；")]),t._v(" "),v("p",[t._v("（4）定时器触发进程")]),t._v(" "),v("p",[t._v("定时器触发进程即 setInterval 与 setTimeout 所在线程；浏览器定\n时计数器并不是由 JS 引擎计数的，因为 JS 引擎是单线程的，如果处\n于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时\n并触发定时器，计时完毕后，添加到事件队列中，等待 JS 引擎空闲\n后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，\n定时器只是在指定时间点将任务添加到事件队列中；")]),t._v(" "),v("p",[t._v("注意：W3C 在 HTML 标准中规定，定时器的定时时间不能小于 4ms，如\n果是小于 4ms，则默认为 4ms。")]),t._v(" "),v("p",[t._v("（5）异步 http 请求线程")]),t._v(" "),v("p",[t._v("XMLHttpRequest 连接后通过浏览器新开一个线程请求；")]),t._v(" "),v("p",[t._v("检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更\n事件，将回调函数放入事件队列中，等待 JS 引擎空闲后执行；")]),t._v(" "),v("h2",{attrs:{id:"僵尸进程和孤儿进程是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#僵尸进程和孤儿进程是什么"}},[t._v("#")]),t._v(" 僵尸进程和孤儿进程是什么？")]),t._v(" "),v("p",[t._v("孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些\n子进程都会成为孤儿进程。孤儿进程将被 init 进程(进程号为 1)所\n收养，并由 init 进程对它们完成状态收集工作。")]),t._v(" "),v("p",[t._v("僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用\n的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之\n为僵死进程。")]),t._v(" "),v("h2",{attrs:{id:"如何实现浏览器内多个标签页之间的通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何实现浏览器内多个标签页之间的通信"}},[t._v("#")]),t._v(" 如何实现浏览器内多个标签页之间的通信?")]),t._v(" "),v("p",[t._v("实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。\n因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让\n标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通\n信方法如下：")]),t._v(" "),v("p",[t._v("使用 websocket 协议，因为 websocket 协议可以实现服务器推送，\n所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数\n据，然后由服务器向其他标签页推送转发。")]),t._v(" "),v("p",[t._v("使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期\n内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。\n这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个\n线程，然后通过这个共享的线程来实现数据的交换。")]),t._v(" "),v("p",[t._v("使用 localStorage 的方式，我们可以在一个标签页对 localStorage\n的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就\n可以通过这个监听事件来获取到数据。这个时候 localStorage 对象\n就是充当的中介者的角色。")]),t._v(" "),v("p",[t._v("使用 postMessage 方法，如果我们能够获得对应标签页的引用，就\n可以使用 postMessage 方法，进行通信。")]),t._v(" "),v("h2",{attrs:{id:"对浏览器的缓存机制的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对浏览器的缓存机制的理解"}},[t._v("#")]),t._v(" 对浏览器的缓存机制的理解")]),t._v(" "),v("p",[t._v("浏览器缓存的全过程：")]),t._v(" "),v("p",[t._v("浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源\n文件，并缓存资源文件与 response header，以供下次加载时对比使用；")]),t._v(" "),v("p",[t._v("下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上\n一次返回 200 时的时间差，如果没有超过 cache-control 设置的\nmax-age，则没有过期，并命中强缓存，直接从本地读取资源。如果\n浏览器不支持 HTTP1.1，则使用 expires 头判断是否过期；")]),t._v(" "),v("p",[t._v("如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向\n服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；\n服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做\n修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不\n一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；\n如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和\n被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；\n不一致则返回新的 last-modified 和文件并返回 200；")]),t._v(" "),v("p",[v("img",{attrs:{src:"/http/cache.png",alt:"cache.png"}})]),t._v(" "),v("p",[t._v("很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS\n或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户\n端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时\n获得网站的最新更新。")]),t._v(" "),v("h2",{attrs:{id:"协商缓存和强缓存的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存和强缓存的区别"}},[t._v("#")]),t._v(" 协商缓存和强缓存的区别")]),t._v(" "),v("p",[t._v("（1）强缓存")]),t._v(" "),v("p",[t._v("使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必\n再向服务器发起请求。")]),t._v(" "),v("p",[t._v("强缓存策略可以通过两种方式来设置，分别是 http 头信息中的\nExpires 属性和 Cache-Control 属性")]),t._v(" "),v("p",[t._v("（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期\n时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发\n送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存\n在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用\n户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。")]),t._v(" "),v("p",[t._v("（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP\n1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供\n了对资源的缓存的更精确的控制。它有很多不同的值，Cache-Control 可设置的字段：")]),t._v(" "),v("p",[t._v("public：设置了该字段值的资源表示可以被任何对象（包括：发送请\n求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是\n使用 max-age=来精确控制；")]),t._v(" "),v("p",[t._v("private：设置了该字段值的资源只能被用户浏览器缓存，不允许任\n何代理服务器缓存。在实际开发当中，对于一些含有用户信息的 HTML，\n通常都要设置这个字段值，避免代理服务器(CDN)缓存；")]),t._v(" "),v("p",[t._v("no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了\n变化，如果资源未发生变化，则直接使用缓存好的资源；")]),t._v(" "),v("p",[t._v("no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起\n新的请求，拉取最新的资源；")]),t._v(" "),v("p",[t._v("max-age=：设置缓存的最大有效期，单位为秒；")]),t._v(" "),v("p",[t._v("s-maxage=：优先级高于 max-age=，仅适用于共享缓存(CDN)，优先\n级高于 max-age 或者 Expires 头；")]),t._v(" "),v("p",[t._v("max-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，\n但是不能超过给定的时间限制。")]),t._v(" "),v("p",[t._v("一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方\n式一起使用时，Cache-Control 的优先级要高于 Expires。\nno-cache 和 no-store 很容易混淆：")]),t._v(" "),v("p",[t._v("no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也\n就是说没有强缓存，但是会有协商缓存；")]),t._v(" "),v("p",[t._v("no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。")]),t._v(" "),v("p",[t._v("（2）协商缓存")]),t._v(" "),v("p",[t._v("如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如\n果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会\n发挥作用了。")]),t._v(" "),v("p",[t._v("上面已经说到了，命中协商缓存的条件有两个：")]),t._v(" "),v("p",[t._v("max-age=xxx 过期了")]),t._v(" "),v("p",[t._v("值为 no-store")]),t._v(" "),v("p",[t._v("使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发\n生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如\n果资源发生了修改，则返回修改后的资源。")]),t._v(" "),v("p",[t._v("协商缓存也可以通过两种方式来设置，分别是 http 头信息中的\nEtag 和 Last-Modified 属性。")]),t._v(" "),v("p",[t._v("（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最\n后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加\n一个 If-Modified-Since 的属性，属性值为上一次资源返回时的\nLast-Modified 的值。当请求发送到服务器后服务器会通过这个属性\n来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做\n了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本\n地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种\n方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精\n确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，那么文件\n已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中\n的不准确。")]),t._v(" "),v("p",[t._v("（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提\n供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，\n在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，\n当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，\n浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值\n就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值\n来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改\n变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式\n更加精确。")]),t._v(" "),v("p",[t._v("当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更\n高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多\n个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器\n上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。")]),t._v(" "),v("p",[t._v("总结：")]),t._v(" "),v("p",[t._v("强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存\n副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命\n中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强\n缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求\n的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命\n中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命\n中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如\n果协商缓存不命中，则浏览器返回最新的资源给浏览器。")]),t._v(" "),v("h2",{attrs:{id:"点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别"}},[t._v("#")]),t._v(" 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？")]),t._v(" "),v("p",[t._v("点击刷新按钮或者按 F5：浏览器直接对本地的缓存文件过期，但是\n会带上 If-Modifed-Since，If-None-Match，这就意味着服务器会对\n文件检查新鲜度，返回结果可能是 304，也有可能是 200。")]),t._v(" "),v("p",[t._v("用户按 Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，而且\n不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有\n请求过，返回结果是 200。")]),t._v(" "),v("p",[t._v("地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，\n然后服务器检查新鲜度，最后返回内容。")]),t._v(" "),v("h2",{attrs:{id:"浏览器的渲染过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染过程"}},[t._v("#")]),t._v(" 浏览器的渲染过程")]),t._v(" "),v("p",[t._v("浏览器渲染主要有以下步骤：")]),t._v(" "),v("p",[t._v("首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由\nDOM 元素及属性节点组成的。")]),t._v(" "),v("p",[t._v("然后对 CSS 进行解析，生成 CSSOM 规则树。")]),t._v(" "),v("p",[t._v("根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染\n对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和\nDOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元\n素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们\n一般是一些具有复杂结构的元素，无法用一个矩形来描述。")]),t._v(" "),v("p",[t._v("当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏\n览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。\n这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位\n置和大小。通常这一行为也被称为“自动重排”。")]),t._v(" "),v("p",[t._v("布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint\n方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。")]),t._v(" "),v("p",[t._v("注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会\n尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完\n成之后再去构建和布局 render 树。它是解析完一部分内容就显示一\n部分内容，同时，可能还在通过网络下载其余内容。")]),t._v(" "),v("h2",{attrs:{id:"渲染过程中遇到-js-文件如何处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程中遇到-js-文件如何处理"}},[t._v("#")]),t._v(" 渲染过程中遇到 JS 文件如何处理？")]),t._v(" "),v("p",[t._v("JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在\n构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文\n档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎\n运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如\n果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是\n都建议将 script 标签放在 body 标签底部的原因。当然在当下，并\n不是说 script 标签必须放在底部，因为你可以给 script 标签添加\ndefer 或者 async 属性。")]),t._v(" "),v("h2",{attrs:{id:"前端储存的方式有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前端储存的方式有哪些"}},[t._v("#")]),t._v(" 前端储存的⽅式有哪些？")]),t._v(" "),v("p",[t._v("cookies： 在 HTML5 标准前本地储存的主要⽅式，优点是兼容性好，\n请求头⾃带 cookie ⽅便，缺点是⼤⼩只有 4k，⾃动请求头加⼊ cookie\n浪费流量，每个 domain 限制 20 个 cookie，使⽤起来麻烦，需要⾃⾏封装；")]),t._v(" "),v("p",[t._v("localStorage：HTML5 加⼊的以键值对(Key-Value)为标准的⽅式，\n优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为 5M，兼容 IE8+ ；")]),t._v(" "),v("p",[t._v("sessionStorage：与 localStorage 基本类似，区别是 sessionStorage\n当⻚⾯关闭后会被清理，⽽且与 cookie、localStorage 不同，他不\n能在所有同源窗⼝中共享，是会话级别的储存⽅式；")]),t._v(" "),v("p",[t._v("Web SQL：2010 年被 W3C 废弃的本地数据库数据存储⽅案，但是主流\n浏览器（⽕狐除外）都已经有了相关的实现，web sql 类似于 SQLite，\n是真正意义上的关系型数据库，⽤ sql 进⾏操作，当我们⽤ JavaScript\n时要进⾏转换，较为繁琐；")]),t._v(" "),v("p",[t._v("IndexedDB：是被正式纳⼊ HTML5 标准的数据库储存⽅案，它是 NoSQL\n数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合 web\n场景，同时⽤ JavaScript 进⾏操作会⾮常便。")]),t._v(" "),v("h2",{attrs:{id:"对事件循环的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对事件循环的理解"}},[t._v("#")]),t._v(" 对事件循环的理解")]),t._v(" "),v("p",[t._v("因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上\n下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果\n遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个\n事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，\n再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列\n可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕\n后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有\n就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行\n完成后再去执行宏任务队列中的任务。")]),t._v(" "),v("p",[t._v("Event Loop 执行顺序如下所示：")]),t._v(" "),v("p",[t._v("首先执行同步代码，这属于宏任务")]),t._v(" "),v("p",[t._v("当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行")]),t._v(" "),v("p",[t._v("执行所有微任务")]),t._v(" "),v("p",[t._v("当执行完所有微任务后，如有必要会渲染页面")]),t._v(" "),v("p",[t._v("然后开始下一轮 Event Loop，执行宏任务中的异步代码")]),t._v(" "),v("h2",{attrs:{id:"get-和-post-的请求的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的请求的区别"}},[t._v("#")]),t._v(" GET 和 POST 的请求的区别")]),t._v(" "),v("p",[t._v("Post 和 Get 是 HTTP 请求的两种方法，其区别如下：")]),t._v(" "),v("p",[t._v("应用场景：GET 请求是一个幂等的请求，一般 Get 请求用于对服务\n器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post\n不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比\n如注册用户这一类的操作。")]),t._v(" "),v("p",[t._v("是否缓存：因为两者应用场景不同，浏览器一般会对 Get 请求缓存，\n但很少对 Post 请求缓存。")]),t._v(" "),v("p",[t._v("发送的报文格式：Get 请求的报文中实体部分为空，Post 请求的报\n文中实体部分一般为向服务器发送的数据。")]),t._v(" "),v("p",[t._v("安全性：Get 请求可以将请求的参数放入 url 中向服务器发送，这\n样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会\n被保留在历史记录中。")]),t._v(" "),v("p",[t._v("请求长度：浏览器由于对 url 长度的限制，所以会影响 get 请求发\n送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。")]),t._v(" "),v("p",[t._v("参数类型：post 的参数传递支持更多的数据类型")]),t._v(" "),v("p",[t._v("从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue), 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)")]),t._v(" "),v("h2",{attrs:{id:"post-和-put-请求的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#post-和-put-请求的区别"}},[t._v("#")]),t._v(" POST 和 PUT 请求的区别")]),t._v(" "),v("p",[t._v("PUT 请求是向服务器端发送数据，从而修改数据的内容，但是不会增\n加数据的种类等，也就是说无论进行多少次 PUT 操作，其结果并没有\n不同。（可以理解为时更新数据）")]),t._v(" "),v("p",[t._v("POST 请求是向服务器端发送数据，该请求会改变数据的种类等资源，\n它会创建新的内容。（可以理解为是创建数据）")]),t._v(" "),v("h2",{attrs:{id:"常见的-http-请求方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的-http-请求方法"}},[t._v("#")]),t._v(" 常见的 HTTP 请求方法")]),t._v(" "),v("p",[t._v("GET: 向服务器获取数据；")]),t._v(" "),v("p",[t._v("POST：将实体提交到指定的资源，通常会造成服务器资源的修改；")]),t._v(" "),v("p",[t._v("PUT：上传文件，更新数据；")]),t._v(" "),v("p",[t._v("DELETE：删除服务器上的对象；")]),t._v(" "),v("p",[t._v("HEAD：获取报文首部，与 GET 相比，不返回报文主体部分；")]),t._v(" "),v("p",[t._v("OPTIONS：询问支持的请求方法，用来跨域请求；")]),t._v(" "),v("p",[t._v("CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行 TCP 通信；")]),t._v(" "),v("p",[t._v("TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。")]),t._v(" "),v("h2",{attrs:{id:"http-1-1-和-http-2-0-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-和-http-2-0-的区别"}},[t._v("#")]),t._v(" HTTP 1.1 和 HTTP 2.0 的区别")]),t._v(" "),v("p",[t._v('二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文\n的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是\n二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是\n二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念\n是它实现多路复用的基础。')]),t._v(" "),v("p",[t._v('多路复用：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，\n但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，\n而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。')]),t._v(" "),v("p",[t._v("数据流：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不\n按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。\n因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每\n个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个\n独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分\n它属于哪个数据流。")]),t._v(" "),v("p",[t._v("头信息压缩：HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带\n状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重\n复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都\n必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了\n优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或\ncompress 压缩后再发送；另一方面，客户端和服务器同时维护一张\n头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发\n送同样字段了，只发送索引号，这样就能提高速度了。")]),t._v(" "),v("p",[t._v("服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，\n这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，\n这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服\n务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向\n客户端发送即时数据的推送是不同的。")]),t._v(" "),v("h2",{attrs:{id:"http-和-https-协议的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https-协议的区别"}},[t._v("#")]),t._v(" HTTP 和 HTTPS 协议的区别")]),t._v(" "),v("p",[t._v("HTTP 和 HTTPS 协议的主要区别如下：")]),t._v(" "),v("ul",[v("li",[t._v("HTTPS 协议需要 CA 证书，费用较高；而 HTTP 协议不需要；")]),t._v(" "),v("li",[t._v("HTTP 协议是超文本传输协议，信息是明文传输的，HTTPS 则是具有安\n全性的 SSL 加密传输协议；")]),t._v(" "),v("li",[t._v("使用不同的连接方式，端口也不同，HTTP 协议端口是 80，HTTPS 协\n议端口是 443；")]),t._v(" "),v("li",[t._v("HTTP 协议连接很简单，是无状态的；HTTPS 协议是有 SSL 和 HTTP 协\n议构建的可进行加密传输、身份认证的网络协议，比 HTTP 更加安全。")])]),t._v(" "),v("h2",{attrs:{id:"说一下-http-3-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#说一下-http-3-0"}},[t._v("#")]),t._v(" 说一下 HTTP 3.0")]),t._v(" "),v("p",[t._v("HTTP/3 基于 UDP 协议实现了类似于 TCP 的多路复用数据流、传输可\n靠性等功能，这套功能被称为 QUIC 协议。")]),t._v(" "),v("p",[t._v("1.流量控制、传输可靠性功能：QUIC 在 UDP 的基础上增加了一层来\n保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一\n些 TCP 中的特性。")]),t._v(" "),v("p",[t._v("2.集成 TLS 加密功能：目前 QUIC 使用 TLS1.3，减少了握手所花费的 RTT 数。")]),t._v(" "),v("p",[t._v("3.多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了\n数据流的单独传输，解决了 TCP 的队头阻塞问题")]),t._v(" "),v("p",[t._v("4.快速握手：由于基于 UDP，可以实现使用 0 ~ 1 个 RTT 来建立连接。")]),t._v(" "),v("h2",{attrs:{id:"什么是-https-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-https-协议"}},[t._v("#")]),t._v(" 什么是 HTTPS 协议？")]),t._v(" "),v("p",[t._v("超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：\nHTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经\n由 HTTP 进行通信，利用 SSL/TLS 来加密数据包。HTTPS 的主要目的\n是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。")]),t._v(" "),v("p",[t._v("HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持\n的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功\n能，可以避免此类问题发生。")]),t._v(" "),v("p",[t._v("安全层的主要职责就是对发起的 HTTP 请求的数据进行加密操作 和\n对接收到的 HTTP 的内容进行解密操作。")]),t._v(" "),v("h2",{attrs:{id:"https-通信-握手-过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-通信-握手-过程"}},[t._v("#")]),t._v(" HTTPS 通信（握手）过程")]),t._v(" "),v("p",[t._v("HTTPS 的通信过程如下：")]),t._v(" "),v("p",[t._v("1.客户端向服务器发起请求，请求中包含使用的协议版本号、生成的\n一个随机数、以及客户端支持的加密方法。")]),t._v(" "),v("p",[t._v("2.服务器端接收到请求后，确认双方使用的加密方法、并给出服务器\n的证书、以及一个服务器生成的随机数。")]),t._v(" "),v("p",[t._v("3.客户端确认服务器证书有效后，生成一个新的随机数，并使用数字\n证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供\n一个前面所有内容的 hash 的值，用来供服务器检验。")]),t._v(" "),v("p",[t._v("4.服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供\n前面所有内容的 hash 值来供客户端检验。")]),t._v(" "),v("p",[t._v("5.客户端和服务器端根据约定的加密方法使用前面的三个随机数，生\n成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。")]),t._v(" "),v("h2",{attrs:{id:"dns-完整的查询过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dns-完整的查询过程"}},[t._v("#")]),t._v(" DNS 完整的查询过程")]),t._v(" "),v("p",[t._v("DNS 服务器解析域名的过程：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("首先会在浏览器的缓存中查找对应的 IP 地址，如果查找到直接返回，\n若找不到继续下一步")])]),t._v(" "),v("li",[v("p",[t._v("将请求发送给本地 DNS 服务器，在本地域名服务器缓存中查询，如果\n查找到，就直接将查找结果返回，若找不到继续下一步")])]),t._v(" "),v("li",[v("p",[t._v("本地 DNS 服务器向根域名服务器发送请求，根域名服务器会返回一个\n所查询域的顶级域名服务器地址")])]),t._v(" "),v("li",[v("p",[t._v("本地 DNS 服务器向顶级域名服务器发送请求，接受请求的服务器查询\n自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的\n下一级的权威域名服务器的地址")])]),t._v(" "),v("li",[v("p",[t._v("本地 DNS 服务器向权威域名服务器发送请求，域名服务器返回对应的结果")])]),t._v(" "),v("li",[v("p",[t._v("本地 DNS 服务器将返回结果保存在缓存中，便于下次使用")])]),t._v(" "),v("li",[v("p",[t._v("本地 DNS 服务器将返回结果返回给浏览器")])])]),t._v(" "),v("p",[t._v("比如要查询 www.baidu.com 的 IP 地址，首先会在浏览器的缓存中\n查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS\n服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，如果不存\n在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com\n的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其\n中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶\n级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。\n然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，\n最后权威域名服务器返回一个对应的主机名的 IP 地址列表。")]),t._v(" "),v("h2",{attrs:{id:"osi-七层模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#osi-七层模型"}},[t._v("#")]),t._v(" OSI 七层模型")]),t._v(" "),v("p",[v("img",{attrs:{src:"/http/1691746187661.jpg",alt:""}})]),t._v(" "),v("h3",{attrs:{id:"应用层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用层"}},[t._v("#")]),t._v(" 应用层")]),t._v(" "),v("p",[t._v("OSI 参考模型中最靠近用户的一层，是为计算机用户提供应用接口，\n也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：\nHTTP，HTTPS，FTP，POP3、SMTP 等。")]),t._v(" "),v("p",[t._v("在客户端与服务器中经常会有数据的请求，这个时候就是会用到\nhttp(hyper text transfer protocol)(超文本传输协议)或者 https. 在后端设计数据接口时，我们常常使用到这个协议。\nFTP 是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，\n在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。")]),t._v(" "),v("p",[t._v("SMTP 是 simple mail transfer protocol（简单邮件传输协议）。在\n一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。")]),t._v(" "),v("h3",{attrs:{id:"表示层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表示层"}},[t._v("#")]),t._v(" 表示层")]),t._v(" "),v("p",[t._v("表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的\n应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可\n提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通\n信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。")]),t._v(" "),v("p",[t._v("在项目开发中，为了方便数据传输，可以使用 base64 对数据进行编\n解码。如果按功能来划分，base64 应该是工作在表示层。")]),t._v(" "),v("h3",{attrs:{id:"会话层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#会话层"}},[t._v("#")]),t._v(" 会话层")]),t._v(" "),v("p",[t._v("会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层\n的通信由不同设备中的应用程序之间的服务请求和响应组成。")]),t._v(" "),v("h3",{attrs:{id:"传输层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传输层"}},[t._v("#")]),t._v(" 传输层")]),t._v(" "),v("p",[t._v("传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端\n到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等\n问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只\n是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、\n可靠的数据通路。我们通常说的，TCP UDP 就是在这一层。端口号既\n是这里的“端”。")]),t._v(" "),v("h3",{attrs:{id:"网络层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络层"}},[t._v("#")]),t._v(" 网络层")]),t._v(" "),v("p",[t._v("本层通过 IP 寻址来建立两个节点之间的连接，为源端的运输层送来\n的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目\n的端的运输层。就是通常说的 IP 层。这一层就是我们经常说的 IP 协\n议层。IP 协议是 Internet 的基础。我们可以这样理解，网络层规定\n了数据包的传输路线，而传输层则规定了数据包的传输方式。")]),t._v(" "),v("h3",{attrs:{id:"数据链路层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层"}},[t._v("#")]),t._v(" 数据链路层")]),t._v(" "),v("p",[t._v("将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使\n用 MAC 地址)来访问介质,并进行差错检测。")]),t._v(" "),v("p",[t._v("网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理\n解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。\n不过，在数据链路层上还增加了差错控制的功能。")]),t._v(" "),v("h3",{attrs:{id:"物理层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#物理层"}},[t._v("#")]),t._v(" 物理层")]),t._v(" "),v("p",[t._v("实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。\n规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、\n中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。")]),t._v(" "),v("p",[t._v("OSI 七层模型通信特点：对等通信，为了使数据分组从源传送到目的地，源端 OSI 模型的每一\n层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。\n在每一层通信过程中，使用本层自己协议进行通信。")])])}),[],!1,null,null,null);v.default=s.exports}}]);