(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{330:function(t,e,a){"use strict";a.r(e);var r=a(12),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"flutter知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter知识"}},[t._v("#")]),t._v(" Flutter知识")]),t._v(" "),e("h2",{attrs:{id:"flutter-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter-是什么"}},[t._v("#")]),t._v(" Flutter 是什么？")]),t._v(" "),e("p",[t._v("Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter完全免费，开源的。")]),t._v(" "),e("h2",{attrs:{id:"flutter特性有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter特性有哪些"}},[t._v("#")]),t._v(" Flutter特性有哪些？")]),t._v(" "),e("p",[t._v("快速开发(毫秒级热重载)")]),t._v(" "),e("ul",[e("li",[t._v("绚丽UI(内建漂亮的质感设计Material Design和Cupertino Widget和丰富平滑的动画效果和平台感知)")]),t._v(" "),e("li",[t._v("响应式(Reactive,用强大而灵活的API解决2D，动画，手势，效果等难题)")]),t._v(" "),e("li",[t._v("原生访问功能")]),t._v(" "),e("li",[t._v("堪比原生性能")])]),t._v(" "),e("h2",{attrs:{id:"flutter的优点是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter的优点是什么"}},[t._v("#")]),t._v(" Flutter的优点是什么？")]),t._v(" "),e("ul",[e("li",[t._v("跨平台开发：此功能使Flutter可以编写一次代码, 进行维护并可以在不同平台上运行。它节省了开发人员的时间, 精力和金钱。")]),t._v(" "),e("li",[t._v("更快的开发：Flutter应用程序的性能很快。 Flutter使用arm C / C ++库编译应用程序, 该库使其更接近于机器代码, 并为应用程序提供了更好的本机性能。")]),t._v(" "),e("li",[t._v("良好的社区：Flutter具有良好的社区支持, 开发人员可以在其中提出问题并快速获得结果。")]),t._v(" "),e("li",[t._v("实时和热重载：它使应用程序开发过程非常快速。此功能使我们能够在更改后立即更改或更新反映的代码。")]),t._v(" "),e("li",[t._v("最少的代码：Flutter应用程序是由Dart编程语言开发的, 它使用JIT和AOT编译来缩短总体启动时间, 发挥作用并加速性能。 JIT增强了开发系统并刷新了UI, 而无需花费更多精力来构建新的。")]),t._v(" "),e("li",[t._v("专注于UI：它具有出色的用户界面, 因为它使用了以设计为中心的小部件, 高级开发工具, 高级API和许多其他功能。")]),t._v(" "),e("li",[t._v("文档：Flutter具有很好的文档支持。它井井有条, 内容更丰富。我们可以将所有想要编写的东西都放在一个地方。")])]),t._v(" "),e("h2",{attrs:{id:"flutter和dart的关系是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter和dart的关系是什么"}},[t._v("#")]),t._v(" Flutter和Dart的关系是什么？")]),t._v(" "),e("p",[t._v("Flutter是一个使用Dart语言开发的跨平台移动UI框架，通过自建绘制引擎，能高性能，高保真的进行移动开发。Dart囊括了多数编程语言的优点，它更符合Flutter构建界面的方式。")]),t._v(" "),e("h2",{attrs:{id:"dart语言的特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dart语言的特性"}},[t._v("#")]),t._v(" Dart语言的特性？")]),t._v(" "),e("ul",[e("li",[t._v("Productive(生产力高，Dart的语法清晰明了，工具简单但功能强大)")]),t._v(" "),e("li",[t._v("Fast(执行速度快，Dart提供前优化编译，以在移动设备和Web上获得可预测的高性能和快速启动。)")]),t._v(" "),e("li",[t._v("Protable(易于移植，Dart可编译成ARM和X86代码，这样Dart移动应用程序可以再iOS，Android和其他地方运行)")]),t._v(" "),e("li",[t._v("Approachable(容易上手，充分吸收了高级语言特性，如果你已经知道C++，C语言，或者Java，你可以在短短几天内用Dart来开发)")]),t._v(" "),e("li",[t._v("Reactive(响应式编程)")])]),t._v(" "),e("h2",{attrs:{id:"dart的一些重要概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dart的一些重要概念"}},[t._v("#")]),t._v(" Dart的一些重要概念？")]),t._v(" "),e("ul",[e("li",[t._v("在Dart中，一切都是对象，所有的对象都继承自Object")]),t._v(" "),e("li",[t._v("Dart是强类型语言，但可以用var或dynamic来声明一个变量，Dart会自动推断其数据类型，dynamic类似c#")]),t._v(" "),e("li",[t._v("没有赋初值的变量都会有默认值null")]),t._v(" "),e("li",[t._v("Dart支持顶层方法，如main方法，可以在方法内部创建方法")]),t._v(" "),e("li",[t._v("Dart支持顶层变量，也支持变量或对象变量")]),t._v(" "),e("li",[t._v("Dart没有public protected private等关键字，如果某个变量以下划线(_)开头，代表这个变量在库中是私有的")])]),t._v(" "),e("h2",{attrs:{id:"dart是值传递还是引用传递"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dart是值传递还是引用传递"}},[t._v("#")]),t._v(" dart是值传递还是引用传递？")]),t._v(" "),e("p",[t._v("dart中，基本数据类型是传值，类传引用。我们每次调用函数，传递过去的都是对象的内存地址，而不是这个对象的复制。")]),t._v(" "),e("h2",{attrs:{id:"widget和element和renderobject之间的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#widget和element和renderobject之间的关系"}},[t._v("#")]),t._v(" Widget和element和RenderObject之间的关系？")]),t._v(" "),e("ul",[e("li",[t._v("Widget是用户界面的一部分，并且是不可变得。")]),t._v(" "),e("li",[t._v("Element是在树中特定位置Widget的实例。")]),t._v(" "),e("li",[t._v("RenderObject是渲染树中的一个对象，它的层次结构是渲染库的核心。")])]),t._v(" "),e("p",[t._v("Widget会被inflate(填充)到Element，并由Element管理底层渲染树。Widget并不会直接管理状态及渲染，而是通过State这个对象来管理状态。Flutter创建Element的可见树，相对于Widget来说，是可变的，通常界面开发中，我们不用直接操作Element，而是由框架层实现内部逻辑。就如一个UI视图树中，可能包含有多个TextWidget(Widget被使用多次)，但是放在内部视图树的视角，这些TextWidget都是填充到一个个独立的Element中。Element会持有renderObject和widget的实例。记住，Widget只是一个配置，RenderObject负责管理布局，绘制等操作。")]),t._v(" "),e("p",[t._v("在第一次创建Widget的时候，会创建一个Element，然后将该元素插入树中。如果之后Widget发生了变化，则将其与旧的Widget进行比较，并且相应的更新Element。重要的是，Element不会被重建，只是更新而已。")]),t._v(" "),e("h2",{attrs:{id:"mixin-extends-implement之间的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mixin-extends-implement之间的关系"}},[t._v("#")]),t._v(" mixin extends implement之间的关系？")]),t._v(" "),e("p",[t._v("继承(关键字extends),混入mixins(关键字with),接口实现(关键字implements)。这三者可以同时存在，前后顺序是extends->mixins->implements。")]),t._v(" "),e("p",[t._v("Flutter中的继承是单继承，子类重写超类的方法要用@Override,子类调用超类的方法要用super。")]),t._v(" "),e("p",[t._v("在Flutter中，Mixins是一种在多个类层结构中复用类代码的方法。mixins的对象是类，mixins绝不继承，也不是接口，而是一种全新的特性，可以mixins多个类，mixins的使用需要满足一定条件。")]),t._v(" "),e("h2",{attrs:{id:"使用mixins的条件是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用mixins的条件是什么"}},[t._v("#")]),t._v(" 使用mixins的条件是什么？")]),t._v(" "),e("p",[t._v("因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.1中使用mixins的条件:")]),t._v(" "),e("ul",[e("li",[t._v("mixins类只能继承自object")]),t._v(" "),e("li",[t._v("mixins类不能有构造函数")]),t._v(" "),e("li",[t._v("一个类可以mixins多个mixins类")]),t._v(" "),e("li",[t._v("可以mixins多个类，不破坏Flutter的单继承")])]),t._v(" "),e("h2",{attrs:{id:"flutter-main-future-mirotask的执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter-main-future-mirotask的执行顺序"}},[t._v("#")]),t._v(" Flutter main future mirotask的执行顺序？")]),t._v(" "),e("p",[t._v("普通代码都是同步执行的，结束后会开始检查microtask中是否有任务，若有则执行，执行完继续检查microtask，直到microtask列队为空。最后会去执行event队列(future)。")]),t._v(" "),e("h2",{attrs:{id:"future和isolate有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#future和isolate有什么区别"}},[t._v("#")]),t._v(" Future和isolate有什么区别？")]),t._v(" "),e("p",[t._v("future是异步编程，调用本身立即返回，并在稍后的某个时候执行完成时在获得返回结果。在普通代码中可以使用await等待一个异步调用结束。")]),t._v(" "),e("p",[t._v("isolate是并发变成，Dart有并发时的共享状态，所有Dart代码都在isolate中运行，包括最初的main()。每个isolate都有它自己的堆内存，意味着其中所有内存数据，包括全局数据，都仅对该isolate可见，它们之间的通信只能通过传递消息的机制，消息则通过端口(port)收发。isolate只是一个概念，具体取决于如何实现，比如在Dart VM中一个isolate可能会是一个线程，在Web中可能会是一个Web Worker。")]),t._v(" "),e("h2",{attrs:{id:"stream-与-future是什么关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stream-与-future是什么关系"}},[t._v("#")]),t._v(" Stream 与 Future是什么关系？")]),t._v(" "),e("p",[t._v("Stream 和 Future 是 Dart 异步处理的核心 API。Future 表示稍后获得的一个数据，所有异步的操作的返回值都用 Future 来表示。但是 Future 只能表示一次异步获得的数据。而 Stream 表示多次异步获得的数据。比如界面上的按钮可能会被用户点击多次，所以按钮上的点击事件（onClick）就是一个 Stream 。简单地说，Future将返回一个值，而Stream将返回多次值。Dart 中统一使用 Stream 处理异步事件流。Stream 和一般的集合类似，都是一组数据，只不过一个是异步推送，一个是同步拉取。")]),t._v(" "),e("h2",{attrs:{id:"stream-两种订阅模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stream-两种订阅模式"}},[t._v("#")]),t._v(" Stream 两种订阅模式")]),t._v(" "),e("p",[t._v("Stream有两种订阅模式：单订阅(single) 和 多订阅（broadcast）。单订阅就是只能有一个订阅者，而广播是可以有多个订阅者。这就有点类似于消息服务（Message Service）的处理模式。单订阅类似于点对点，在订阅者出现之前会持有数据，在订阅者出现之后就才转交给它。而广播类似于发布订阅模式，可以同时有多个订阅者，当有数据时就会传递给所有的订阅者，而不管当前是否已有订阅者存在。")]),t._v(" "),e("p",[t._v("Stream 默认处于单订阅模式，所以同一个 stream 上的 listen 和其它大多数方法只能调用一次，调用第二次就会报错。但 Stream 可以通过 transform() 方法（返回另一个 Stream）进行连续调用。通过 Stream.asBroadcastStream() 可以将一个单订阅模式的 Stream 转换成一个多订阅模式的 Stream，isBroadcast 属性可以判断当前 Stream 所处的模式。")]),t._v(" "),e("h2",{attrs:{id:"await-for-如何使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#await-for-如何使用"}},[t._v("#")]),t._v(" await for 如何使用?")]),t._v(" "),e("p",[t._v("await for是不断获取stream流中的数据，然后执行循环体中的操作。它一般用在直到stream什么时候完成，并且必须等待传递完成之后才能使用，不然就会一直阻塞。")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("Stream"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("String"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" stream "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stream")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("String"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("fromIterable")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'不开心'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'面试'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'没'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'过'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" async"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'上午被开水烫了脚'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("String s "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" stream"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'晚上还没吃饭'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h2",{attrs:{id:"flutter中的widget、state、context-的核心概念-是为了解决什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter中的widget、state、context-的核心概念-是为了解决什么问题"}},[t._v("#")]),t._v(" Flutter中的Widget、State、Context 的核心概念？是为了解决什么问题？")]),t._v(" "),e("p",[e("strong",[t._v("Widget")]),t._v(" : 在Flutter中，几乎所有东西都是Widget。将一个Widget想象为一个可视化的组件（或与应用可视化方面交互的组件），当你需要构建与布局直接或间接相关的任何内容时，你正在使用Widget。")]),t._v(" "),e("p",[e("strong",[t._v("Widget树")]),t._v(" : Widget以树结构进行组织。包含其他Widget的widget被称为父Widget(或widget容器)。包含在父widget中的widget被称为子Widget。")]),t._v(" "),e("p",[e("strong",[t._v("Context")]),t._v(" : 仅仅是已创建的所有Widget树结构中的某个Widget的位置引用。简而言之，将context作为widget树的一部分，其中context所对应的widget被添加到此树中。一个context只从属于一个widget，它和widget一样是链接在一起的，并且会形成一个context树。")]),t._v(" "),e("p",[e("strong",[t._v("State")]),t._v(" : 定义了StatefulWidget实例的行为，它包含了用于”交互/干预“Widget信息的行为和布局。应用于State的任何更改都会强制重建Widget。")]),t._v(" "),e("p",[t._v("这些状态的引入，主要是为了解决多个部件之间的交互和部件自身状态的维护。")]),t._v(" "),e("h2",{attrs:{id:"widget的两种类型是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#widget的两种类型是什么"}},[t._v("#")]),t._v(" Widget的两种类型是什么？")]),t._v(" "),e("p",[e("strong",[t._v("StatelessWidget")]),t._v(" : 一旦创建就不关心任何变化，在下次构建之前都不会改变。它们除了依赖于自身的配置信息（在父节点构建时提供）外不再依赖于任何其他信息。比如典型的Text、Row、Column、Container等，都是StatelessWidget。它的生命周期相当简单：初始化、通过build()渲染。")]),t._v(" "),e("p",[e("strong",[t._v("StatefulWidget")]),t._v(" : 在生命周期内，该类Widget所持有的数据可能会发生变化，这样的数据被称为State，这些拥有动态内部数据的Widget被称为StatefulWidget。比如复选框、Button等。State会与Context相关联，并且此关联是永久性的，State对象将永远不会改变其Context，即使可以在树结构周围移动，也仍将与该context相关联。当state与context关联时，state被视为已挂载。StatefulWidget由两部分组成，在初始化时必须要在createState()时初始化一个与之相关的State对象。")]),t._v(" "),e("h2",{attrs:{id:"state-对象的初始化流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#state-对象的初始化流程"}},[t._v("#")]),t._v(" State 对象的初始化流程？")]),t._v(" "),e("p",[e("strong",[t._v("initState()")]),t._v(" : 一旦State对象被创建，initState方法是第一个（构造函数之后）被调用的方法。可通过重写来执行额外的初始化，如初始化动画、控制器等。重写该方法时，应该首先调用super.initState()。在initState中，无法真正使用context，因为框架还没有完全将其与state关联。initState在该State对象的生命周期内将不会再次调用。")]),t._v(" "),e("p",[e("strong",[t._v("didChangeDependencies()")]),t._v(" : 这是第二个被调用的方法。在这一阶段，context已经可用。如果你的Widget链接到了一个InheritedWidget并且/或者你需要初始化一些listeners（基于context），通常会重写该方法。")]),t._v(" "),e("p",[e("strong",[t._v("build(BuildContext context)")]),t._v(" : 此方法在didChangeDependencies()、didUpdateWidget()之后被调用。每次State对象更新（或当InheritedWidget有新的通知时）都会调用该方法！我们一般都在build中来编写真正的功能代码。为了强制重建，可以在需要的时候调用setState((){...})方法。")]),t._v(" "),e("p",[e("strong",[t._v("dispose()")]),t._v(" : 此方法在Widget被废弃时调用。可重写该方法来执行一些清理操作（如解除listeners），并在此之后立即调用super.dispose()。")]),t._v(" "),e("h2",{attrs:{id:"widget-唯一标识key有那几种"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#widget-唯一标识key有那几种"}},[t._v("#")]),t._v(" Widget 唯一标识Key有那几种？")]),t._v(" "),e("p",[t._v("在flutter中，每个widget都是被唯一标识的。这个唯一标识在build或rendering阶段由框架定义。该标识对应于可选的Key参数，如果省略，Flutter将会自动生成一个。")]),t._v(" "),e("p",[t._v("在flutter中，主要有4种类型的Key：GlobalKey（确保生成的Key在整个应用中唯一，是很昂贵的，允许element在树周围移动或变更父节点而不会丢失状态）、LocalKey、UniqueKey、ObjectKey。")]),t._v(" "),e("h2",{attrs:{id:"什么是navigator-materialapp做了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是navigator-materialapp做了什么"}},[t._v("#")]),t._v(" 什么是Navigator? MaterialApp做了什么？")]),t._v(" "),e("p",[t._v("Navigator是在Flutter中负责管理维护页面堆栈的导航器。MaterialApp在需要的时候，会自动为我们创建Navigator。Navigator.of(context)，会使用context来向上遍历Element树，找到MaterialApp提供的_NavigatorState再调用其push/pop方法完成导航操作。")]),t._v(" "),e("h2",{attrs:{id:"statefulwidget的声明周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#statefulwidget的声明周期"}},[t._v("#")]),t._v(" StatefulWidget的声明周期")]),t._v(" "),e("ul",[e("li",[t._v("initState():Widget初始化当前State，在当前方法中是不能获取到Context的，如果想要获取，可以事Flutter.delaved()。")]),t._v(" "),e("li",[t._v("didChangeDependencies():在initState()后调用，State对象依赖关系发生变化的时候也会调用。")]),t._v(" "),e("li",[t._v("deactivate():当state被暂时从视图树中移除时会调用这个方法，页面切换时也会调用该方法，和Android里的onPause差不多。")]),t._v(" "),e("li",[t._v("dispose():Widget销毁时调用。")]),t._v(" "),e("li",[t._v("didUpdateWidget:Widget状态发生变化的时候调用。")])]),t._v(" "),e("h2",{attrs:{id:"flutter如何与android和ios通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#flutter如何与android和ios通信"}},[t._v("#")]),t._v(" Flutter如何与Android和iOS通信？")]),t._v(" "),e("p",[t._v("Flutter通过PlatformChannel与原生进行交互，其中PlatformChannel分为三种:")]),t._v(" "),e("ul",[e("li",[t._v("BasicNessageChannel:用于产地字符串和半结构化的信息。")]),t._v(" "),e("li",[t._v("MethodChannel:用于传递方法调用。Flutter主动调用Native的方法，并获取相应的返回值。")]),t._v(" "),e("li",[t._v("EventChannel：用于数据流(event streams)的通信。")])]),t._v(" "),e("p",[t._v("具体可以查看 "),e("a",{attrs:{href:"https://www.jianshu.com/p/39575a90e820",target:"_blank",rel:"noopener noreferrer"}},[t._v("闲鱼技术：深入理解 Flutter Platform Channe"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"什么是-widgets、renderobjects-和-elements"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-widgets、renderobjects-和-elements"}},[t._v("#")]),t._v(" 什么是 Widgets、RenderObjects 和 Elements?")]),t._v(" "),e("ul",[e("li",[t._v("Widget 仅用于存储渲染所需要的信息。")]),t._v(" "),e("li",[t._v("RenderObject 负责管理布局、绘制等操作。")]),t._v(" "),e("li",[t._v("Element 才是这颗巨大的控件树上的实体。")])]),t._v(" "),e("p",[t._v("具体可以查看"),e("a",{attrs:{href:"https://juejin.cn/post/6844903639119560711",target:"_blank",rel:"noopener noreferrer"}},[t._v("Flutter，什么是 Widgets、RenderObjects 和 Elements?"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"说一下什么是状态管理-为什么需要它"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说一下什么是状态管理-为什么需要它"}},[t._v("#")]),t._v(" 说一下什么是状态管理，为什么需要它？")]),t._v(" "),e("p",[t._v("首先状态其实是一个概念上的东西，区分全局状态和局部状态。")]),t._v(" "),e("p",[t._v("局部状态比如说一个控件中输入的信息，全局状态比如是登陆后从后台请求回来的 userId。")]),t._v(" "),e("p",[t._v("当全局状态越来越多，多个页面共享一个状态时，我们就需要管理它。")]),t._v(" "),e("p",[t._v("常用的状态管理有：")]),t._v(" "),e("ul",[e("li",[t._v("ScopedModel")]),t._v(" "),e("li",[t._v("BLoC")]),t._v(" "),e("li",[t._v("Redux / FishRedux")]),t._v(" "),e("li",[t._v("Provider")])]),t._v(" "),e("h2",{attrs:{id:"如何统一管理错误页面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何统一管理错误页面"}},[t._v("#")]),t._v(" 如何统一管理错误页面？")]),t._v(" "),e("p",[t._v("我们都知道，如果在 Flutter 当中出错的话，那就是一片红。")]),t._v(" "),e("p",[t._v("可以使用 ErrorWidget.builder 来自定义一个 Widget 就 ok 了。")]),t._v(" "),e("p",[t._v("具体可以看一下 "),e("a",{attrs:{href:"https://juejin.cn/post/6844903762398560270",target:"_blank",rel:"noopener noreferrer"}},[t._v("小德 - 教你自定义Flutter错误页面"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"什么是scopedmodel-bloc模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是scopedmodel-bloc模式"}},[t._v("#")]),t._v(" 什么是ScopedModel / BLoC模式？")]),t._v(" "),e("p",[t._v("ScopedModel和BLoC（业务逻辑组件）是常见的Flutter应用程序架构模式，可帮助将业务逻辑与UI代码分离，并使用更少的状态窗口小部件。")]),t._v(" "),e("h2",{attrs:{id:"dart当中的-标识什么意思"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dart当中的-标识什么意思"}},[t._v("#")]),t._v(" Dart当中的[..]标识什么意思？")]),t._v(" "),e("p",[t._v("Dart当中的"),e("code",[t._v("[..]")]),t._v("意思是"),e("code",[t._v("[级联操作符]")]),t._v("，为了方便配置而使用。"),e("code",[t._v("[..]")]),t._v("和"),e("code",[t._v("[.]")]),t._v("不同的是调用"),e("code",[t._v("[..]")]),t._v("后返回的相当于是this，而"),e("code",[t._v("[.]")]),t._v("返回的则是该方法返回的值。")]),t._v(" "),e("h2",{attrs:{id:"dart的作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dart的作用域"}},[t._v("#")]),t._v(" Dart的作用域")]),t._v(" "),e("p",[t._v("Dart没有public,private等关键字，默认就是公开的，私有变量使用下划线_开头。")]),t._v(" "),e("h2",{attrs:{id:"dart是不是单线程模型-是如何运行的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dart是不是单线程模型-是如何运行的"}},[t._v("#")]),t._v(" Dart是不是单线程模型？是如何运行的？")]),t._v(" "),e("p",[t._v("Dart是单线程模型，如图")]),t._v(" "),e("p",[e("img",{attrs:{src:"/flutter/1608220395606.jpg",alt:""}})]),t._v(" "),e("p",[t._v('Dart在单线程中是以消息循环机制来运行的，其中包含两个任务队列，一个是"微任务队列"microtask queue,另一个叫做"事件队列"event queue。')]),t._v(" "),e("p",[t._v("入口函数main()执行完后，消息循环机制便启动了。首先会按照先进先出的顺序逐个执行微任务队列中的任务，当所有微任务队列执行完后便开始执行事件队列中的任务，事件任务执行完毕后再去执行微任务，如此循环往复，生生不息。")])])}),[],!1,null,null,null);e.default=s.exports}}]);