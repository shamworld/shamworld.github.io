(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{337:function(a,e,t){"use strict";t.r(e);var n=t(12),s=Object(n.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"前端基础题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端基础题"}},[a._v("#")]),a._v(" 前端基础题")]),a._v(" "),e("h2",{attrs:{id:"第1题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第1题"}},[a._v("#")]),a._v(" 第1题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("if(false){\n    var a=1;\n    let b=2;\n}\nconsole.log(a);\nconsole.log(b);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("undefined\n\nReferenceError: b is not defined\n")])])]),e("p",[a._v("var 不会产生块级作用域，let会产生块级作用域。")]),a._v(" "),e("p",[a._v("伪代码相当于:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a;\nif(false){\n    a = 1;\n    let b = 2;\n}\nconsole.log(a); \nconsole.log(b);\n复制代码\n\n")])])]),e("h2",{attrs:{id:"第2题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第2题"}},[a._v("#")]),a._v(" 第2题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 1;\nif(true){\n    console.log(a);\n    let a = 2;\n}\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("ReferenceError: Cannot access 'a' before initialization\n")])])]),e("p",[a._v("let声明不会变量提升，并且会产生暂存死区。在let声明变量之前访问变量会抛出错误。")]),a._v(" "),e("h2",{attrs:{id:"第3题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第3题"}},[a._v("#")]),a._v(" 第3题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = {n: 1}\nvar b = a\na.x = a = {n: 2}\n\nconsole.log(a.n, b.n);\nconsole.log(a.x, b.x);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("2 1\n\nundefined {n: 2}\n")])])]),e("p",[a._v("解析:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var b=a,此时a和b指向同一个对象\n.运算符比=远算符高，先计算`a.x`，此时\nb={\n    n:1,\n    x:undefined\n}\n相当于给对象添加了x属性。\na.x=a={n:2};\n计算完a.x，在计算=，赋值是从右向左，此时a指向一个对象。\na={\n    n:2\n}\na.x已经执行过了，此时对象的x属性赋值为a，此时\n对象={\n    n:1,\n    x:{\n        n:2\n    }\n}\n即:\na={\n    n:2\n}\n\nb={\n    n:1,\n    x:{\n        n:2\n    }\n}\n\n")])])]),e("h2",{attrs:{id:"第4题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第4题"}},[a._v("#")]),a._v(" 第4题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(c);\nvar c;\nfunction c(a) {\n    console.log(a);\n    var a = 3;\n    function a(){\n    }\n}\nc(2);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function c(a){\n    console.log(a);\n    var a = 3;\n    function a(){\n    }\n}\n\nfunction a(){\n}\n")])])]),e("p",[a._v("变量提升也有优先级, 函数声明 > arguments > 变量声明")]),a._v(" "),e("h2",{attrs:{id:"第5题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第5题"}},[a._v("#")]),a._v(" 第5题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var c = 1;\nfunction c(c) {\n    console.log(c);\n    var c = 3;\n}\nconsole.log(c);\nc(2);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1\n\nTypeError: c is not a function\n")])])]),e("p",[a._v("由于函数声明会提升,当函数外的console.log(c)执行时,c已经被赋值为1。因此,执行c(2)时会抛出TypeError,因为1不是函数。")]),a._v(" "),e("h2",{attrs:{id:"第6题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第6题"}},[a._v("#")]),a._v(" 第6题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var name = 'erdong';\n(function () {\n    if (typeof name === 'undefined') {\n        var name = 'chen';\n        console.log(name);\n    } else {\n        console.log(name);\n    }\n})();\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("chen\n")])])]),e("p",[a._v("自执行函数执行时，会先进行变量提升(这里涉及到执行上下文,一定要搞懂执行上下文)，在自执行函数执行时，伪代码为:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var name = 'erdong';\n(function () {\n    var name;  // 变量name会提升到当前作用域顶部\n    if (typeof name === 'undefined') {\n        name = 'chen'\n        console.log(name)\n    } else {\n        console.log(name)\n    }\n})();\n")])])]),e("p",[a._v("所以会执行if中的console.log(name)")]),a._v(" "),e("h2",{attrs:{id:"第7题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第7题"}},[a._v("#")]),a._v(" 第7题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 10;  \nfunction test() {  \n    a = 100;  \n    console.log(a);  \n    console.log(this.a);  \n    var a;  \n    console.log(a); \n}\ntest();\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("100\n10\n100\n")])])]),e("p",[a._v("test()为函数独立调用,作用域中的this绑定为全局对象window。")]),a._v(" "),e("p",[a._v("test函数执行时,var a被提升到了作用域顶部,因此函数作用域中存在一个变量a。所以在函数中访问的a都是局部作用域中的a。")]),a._v(" "),e("h2",{attrs:{id:"第8题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第8题"}},[a._v("#")]),a._v(" 第8题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("if (!('a' in window)) {\n    var a = 1;\n}\nconsole.log(a);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("undefined\n")])])]),e("p",[a._v("由于if后的{}不会产生块级作用域(不包含let,const时),此时的伪代码为:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a;\nif (!(a in window)) {\n    a = 1;\n}\nconsole.log(a);\n")])])]),e("p",[a._v("var a相当于window.a。因此!(a in window)转成布尔值为false,不会执行a = 1。所有console.log(a)输出undefined。")]),a._v(" "),e("h2",{attrs:{id:"第9题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第9题"}},[a._v("#")]),a._v(" 第9题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 1;\n\nfunction c(a, b) {\n    console.log(a);\n    a = 2;\n    console.log(a);\n}\nc();\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("undefined \n\n2\n")])])]),e("h2",{attrs:{id:"第10题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第10题"}},[a._v("#")]),a._v(" 第10题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var val=1;\nvar obj={\n    val:2,\n    del:function(){\n        console.log(this);                    \n        this.val*=2;\n        console.log(val);\n    }\n}\n\nobj.del();\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("obj(指向的值)\n\n1\n")])])]),e("p",[a._v("当通过obj.del()调用del函数时,del函数作用域中的this绑定为obj。")]),a._v(" "),e("p",[a._v("在函数作用域中访问val时,由于函数中并没有变量val,因此实际上访问的是全局作用域中的val,即 1。")]),a._v(" "),e("p",[a._v("这里考察的是this的指向,一定要熟练掌握。")]),a._v(" "),e("h2",{attrs:{id:"第11题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第11题"}},[a._v("#")]),a._v(" 第11题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var name = "erdong";\nvar object = {\n    name: "chen",\n    getNameFunc: function () {\n        return function () {\n            return this.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()());\n')])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("erdong\n")])])]),e("p",[a._v("object.getNameFunc()()先执行object.getNameFunc()返回一个函数:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function(){\n    return this.name;\n}\n")])])]),e("p",[a._v("返回的函数在执行，相当于")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("(function(){\n    return this.name;\n})();\n")])])]),e("p",[a._v("此时的this绑定的window。因此输出全局变量name的值erdong。")]),a._v(" "),e("h2",{attrs:{id:"第12题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第12题"}},[a._v("#")]),a._v(" 第12题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var name = "erdong";\nvar object = {\n    name: "chen",\n    getNameFunc: function () {\n        var that = this;\n        return function () {\n            return that.name;\n        }\n    }\n}\nconsole.log(object.getNameFunc()());\n')])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("chen\n")])])]),e("p",[a._v("object.getNameFunc()执行时，此时getNameFunc中的this绑定为object，因此that=object。object.getNameFunc()返回的函数在执行时，产生闭包，因此返回的函数也能访问到外层作用域中的变量that，因此object.name为obejct.name，即chen。")]),a._v(" "),e("h2",{attrs:{id:"第13题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第13题"}},[a._v("#")]),a._v(" 第13题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("(function() {\n  var a = b = 3;\n})();\nconsole.log(typeof a === 'undefined');\nconsole.log(typeof b === 'undefined');\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("true\n\nfalse\n")])])]),e("p",[a._v("首先要明白var a=b=3是怎样执行的，伪代码:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("b=3;\nvar a=b;\n")])])]),e("p",[a._v("因此在自执行函数执行时,b由于未经var等操作符声明,为全局变量。a为函数作用域中的局部变量。因此在外面访问a和b时,其值分别为ReferenceError: a is not defined和3。但是typeof检测未声明的变量不会抛出错误,会返回'undefined'。因此typeof a和typeof b分别返回'undefined'和'number'")]),a._v(" "),e("h2",{attrs:{id:"第14题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第14题"}},[a._v("#")]),a._v(" 第14题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 6;\nsetTimeout(function () {\n    a = 666;\n}, 0)\nconsole.log(a);\n")])])]),e("p",[a._v("输出：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("6\n")])])]),e("p",[a._v("setTimeout为宏任务。即使设置延迟为0ms，也是等待同步代码执行完才会执行。因此console.log(a)输出6。")]),a._v(" "),e("h2",{attrs:{id:"第15题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第15题"}},[a._v("#")]),a._v(" 第15题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function fn1() {\n    var a = 2;\n    function fn2 () {\n      a++;\n      console.log(a);\n    }\n    return fn2;\n}\nvar f = fn1();\nf();\nf();\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("3\n4\n")])])]),e("p",[a._v("由于fn1函数执行后返回函数fn2,此时fn2中a访问的是fn1作用域中的变量a，因此第一次a++，之后a为3，第二次之后a为4。")]),a._v(" "),e("h2",{attrs:{id:"第16题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第16题"}},[a._v("#")]),a._v(" 第16题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = (function(foo){\n    return typeof foo.bar;\n})({foo:{bar:1}});\n\nconsole.log(a);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("undefined\n")])])]),e("p",[a._v("实参foo的值为{foo:{bar:1}}，因此typeof foo.bar为undefined。")]),a._v(" "),e("p",[a._v("typeof foo.foo.bar 为number。")]),a._v(" "),e("h2",{attrs:{id:"第17题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第17题"}},[a._v("#")]),a._v(" 第17题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function f(){\n    return f;\n}\nconsole.log(new f() instanceof f);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("false\n")])])]),e("p",[a._v("由于构造函数f的返回值为f。因此new f()的值为f。所以console.log(new f() instanceof f)为console.log(f instanceof f)，即false。")]),a._v(" "),e("h2",{attrs:{id:"第18题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第18题"}},[a._v("#")]),a._v(" 第18题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function A () {\n}\nA.prototype.n = 1;\n\nvar b = new A();\n\nA.prototype = {\n    n: 2,\n    m: 3\n}\nvar c = new A();\n\nconsole.log(b.n, b.m);\nconsole.log(c.n, c.m);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1,undefined\n\n2,3\n")])])]),e("p",[a._v("var b = new A(); 实例化b时,A的prototype为")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("A.prototype = {\n    constructor:A,\n    n:1\n}\n")])])]),e("p",[a._v("当访问b.n和b.m时，通过原型链找到A.prototype指向的对象上，即b.n=1,b.m=undefined。")]),a._v(" "),e("p",[a._v("var c=new A();实例化c时，A的prototype为")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("A.prototype = {\n    n:2,\n    m:3\n}\n")])])]),e("p",[a._v("当访问a.n和a.m时，通过原型链找到A.prototype指向的对象上，此时A.prototype重写，因此a.n=2,b.m=3。")]),a._v(" "),e("h2",{attrs:{id:"第19题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第19题"}},[a._v("#")]),a._v(" 第19题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var F = function(){};\nvar O = {};\nObject.prototype.a = function(){\n    console.log('a')\n}\nFunction.prototype.b = function(){\n    console.log('b')\n}\nvar f = new F();\n\nF.a();  \nF.b();  \nO.a();\nO.b();\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("a\nb\na\nTypeError: O.b is not a function\n")])])]),e("p",[a._v("F为函数,它也能访问Object原型上的方法,O为对象,不能访问Function原型上的方法。")]),a._v(" "),e("p",[a._v("F的原型链为:")]),a._v(" "),e("p",[e("code",[a._v("F => F.__proto__ => Function.prototype => Function.prototype.__proto__ => Object.prototype")])]),a._v(" "),e("p",[a._v("由于Object.prototype在F的原型链上,所以F能访问Object.prototype上的属性和方法。即: F.a(),F.b()能正常访问。")]),a._v(" "),e("p",[a._v("O的原型链为:")]),a._v(" "),e("p",[e("code",[a._v("O => O.__proto__ => Object.prototype")])]),a._v(" "),e("p",[a._v("由于Function.prototype不在O的原型链上,因此O不能访问Function.prototype上的方法,即O.b()抛出错误。")]),a._v(" "),e("p",[a._v("如果你对原型和原型链掌握的好,试着理解下面的示例:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(Object instanceof Function);\n\nconsole.log(Function instanceof Object);\n\nconsole.log(Function instanceof Function);\n\n")])])]),e("h2",{attrs:{id:"第20题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第20题"}},[a._v("#")]),a._v(" 第20题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function Person() {\n    getAge = function () {\n        console.log(10)\n    }\n    return this;\n}\n\nPerson.getAge = function () {\n    console.log(20)\n}\n\nPerson.prototype.getAge = function () {\n    console.log(30)\n}\n\nvar getAge = function () {\n    console.log(40)\n}\n\nfunction getAge() {\n    console.log(50)\n}\n\n\nPerson.getAge();\ngetAge();\nPerson().getAge();\nnew Person.getAge();\ngetAge();\nnew Person().getAge();\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("20\n40\n10\n20\n10\n30\n")])])]),e("p",[a._v("Person.getAge();此时执行的时Person函数上的getAge方法。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Person.getAge = function () {\n    console.log(20)\n}\n")])])]),e("p",[a._v("所以输出:20.")]),a._v(" "),e("p",[a._v("getAge();此时执行的是全局中的getAge方法。此时全局getAge方法为:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function () {\n    console.log(40)\n}\n")])])]),e("p",[a._v("所以输出:40。")]),a._v(" "),e("p",[a._v("Person().getAge();由于Person()单独执行所以，作用域中的this绑定为window，相当于window.getAge()。同上，执行的都是全局getAge方法，但是Person执行时，内部执行了。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("getAge = function () {\n    console.log(10)\n}\n")])])]),e("p",[a._v("因此全局getAge方法现在为:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function () {\n    console.log(10)\n}\n")])])]),e("p",[a._v("所以输出:10。")]),a._v(" "),e("p",[a._v("new Person.getAge();此时相当于实例化Person.getAge这个函数,伪代码:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var b = Person.getAge;\nnew b();\n")])])]),e("p",[a._v("所以输出:20。")]),a._v(" "),e("p",[a._v("getAge();执行全局getAge方法,由于在Person().getAge()执行时把全局getAge方法赋值为:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function () {\n    console.log(10)\n}\n\n")])])]),e("p",[a._v("所以输出:10。")]),a._v(" "),e("p",[a._v("new Person().getAge();此时调用的是Person原型上的getAge方法:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Person.prototype.getAge = function () {\n    console.log(30)\n}\n")])])]),e("p",[a._v("所以输出:30。")]),a._v(" "),e("p",[a._v("这里要注意:1.变量提升及提升后再赋值。2.调用构造函数时,带()和不带()的区别。")]),a._v(" "),e("h2",{attrs:{id:"第21题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第21题"}},[a._v("#")]),a._v(" 第21题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(false.toString()); \nconsole.log([1, 2, 3].toString()); \nconsole.log(1.toString()); \nconsole.log(5..toString());\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'false'\n'1,2,3'\nUncaught SyntaxError: Invalid or unexpected token\n'5'\n")])])]),e("p",[a._v("当执行1.toString();时,由于1.也是有效数字,因此此时变成(1.)toString()。没有用.调用toString方法,因此抛出错误。")]),a._v(" "),e("p",[a._v("正确的应该是:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1..toString();\n1 .toString();\n(1).toString();\n")])])]),e("h2",{attrs:{id:"第22题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第22题"}},[a._v("#")]),a._v(" 第22题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(typeof NaN === 'number');\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("true\n")])])]),e("p",[a._v("NaN为不是数字的数字。虽然它不是数字,但是它也是数字类型。")]),a._v(" "),e("h2",{attrs:{id:"第23题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第23题"}},[a._v("#")]),a._v(" 第23题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('console.log(1 + "2" + "2");\n\nconsole.log(1 + +"2" + "2");\n\nconsole.log(1 + -"1" + "2");\n\nconsole.log(+"1" + "1" + "2"); \n\nconsole.log( "A" - "B" + "2"); \n\nconsole.log( "A" - "B" + 2); \n')])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('"122"\n"32"\n"02"\n"112"\n"NAN2"\nNAN\n')])])]),e("p",[a._v("首先要明白两点:")]),a._v(" "),e("ul",[e("li",[a._v("+a，会把a转换为数字。-a会把a转换成数字的负值(如果能转换为数字的话，否则为NAN)")]),a._v(" "),e("li",[a._v("字符串于任何想加都是字符串拼接")])]),a._v(" "),e("p",[e("code",[a._v('console.log(1 + "2" + "2");')]),a._v("简单的字符串拼接,即结果为:"),e("code",[a._v("'122'。")])]),a._v(" "),e("p",[e("code",[a._v('console.log(1 + +"2" + "2");')]),a._v("这里相当于 "),e("code",[a._v('console.log(1 + 2 + "2");')]),a._v(",然后再字符串拼接。即结果为:"),e("code",[a._v("'32'")])]),a._v(" "),e("p",[e("code",[a._v('console.log(+"1" + "1" + "2");')]),a._v("这里相当于"),e("code",[a._v('console.log(1 + "1" + "2");')]),a._v(",然后再字符串拼接。即结果为:"),e("code",[a._v("'112'")]),a._v("。\n"),e("code",[a._v('console.log( "A" - "B" + "2");')]),a._v(",由于"),e("code",[a._v("'A' - 'B' = NaN")]),a._v(",所以相当于"),e("code",[a._v('console.log( NaN + "2");')]),a._v(", 然后再字符串拼接。即结果为:"),e("code",[a._v("'NaN2'")]),a._v("。\n"),e("code",[a._v('console.log( "A" - "B" + 2);')]),a._v(" 同上,相当于"),e("code",[a._v("console.log(NaN + 2)")]),a._v(",由于NaN+任何值还是NaN,即结果为:"),e("code",[a._v("NaN")]),a._v("。")]),a._v(" "),e("h2",{attrs:{id:"第24题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第24题"}},[a._v("#")]),a._v(" 第24题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 666;\nconsole.log(++a);\nconsole.log(a++);\nconsole.log(a);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("667\n667\n668\n")])])]),e("p",[a._v("++a先执行+1操作,再执行取值操作。 此时a的值为667。因此输出667。")]),a._v(" "),e("p",[a._v("a++先执行取值操作,再执行+1。 此时输出667,随后a的值变为668。")]),a._v(" "),e("p",[a._v("--a和a--同理。")]),a._v(" "),e("p",[a._v("使用这类运算符时要注意:")]),a._v(" "),e("p",[a._v("1）这里的++、--不能用作于常量。比如")]),a._v(" "),e("p",[e("code",[a._v("1++; // 抛出错误")])]),a._v(" "),e("p",[a._v("2）如果a不是数字类型,会首先通过Number(a),将a转换为数字。再执行++等运算。")]),a._v(" "),e("h2",{attrs:{id:"第25题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第25题"}},[a._v("#")]),a._v(" 第25题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(typeof a);\nfunction a() {}\nvar a;\nconsole.log(typeof a);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'function'\n'function'\n")])])]),e("p",[a._v("函数会优先于变量声明提前。因此会忽略var a。")]),a._v(" "),e("h2",{attrs:{id:"第26题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第26题"}},[a._v("#")]),a._v(" 第26题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a;\nvar b = 'undefined';\nconsole.log(typeof a);\nconsole.log(typeof b);\nconsole.log(typeof c);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'undefined'\n'string'\n'undefined'\n")])])]),e("p",[a._v("a为声明未赋值,默认为undefined,b的值为字符串'undefined',c为未定义。")]),a._v(" "),e("p",[a._v("typeof一个未定义的变量时,不会抛出错误,会返回'undefined'。注意typeof返回的都是字符串类型。")]),a._v(" "),e("h2",{attrs:{id:"第27题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第27题"}},[a._v("#")]),a._v(" 第27题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var x = 1;\nif(function f(){}){\n    x += typeof f;\n}\n \nconsole.log(x);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1undefined\n")])])]),e("p",[a._v("function f(){}当做if条件判断,其隐式转换后为true。但是在()中的函数不会声明提升,因此f函数在外部是不存在的。因此typeof f = 'undefined',所以x += typeof f,相当于x = x + 'undefined'为'1undefined'")]),a._v(" "),e("h2",{attrs:{id:"第28题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第28题"}},[a._v("#")]),a._v(" 第28题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('var str = "123abc";\nconsole.log(typeof str++);\n')])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'number'\n")])])]),e("p",[a._v("使用++运算符时(无论是前置还是后置),如果变量不是数字类型,会首先用Number()转换为数字。因此typeof str++相当于typeof Number(str)++。由于后置的++是先取值后计算,因此相当于typeof Number(\"123abc\")。即typeof NaN,所以输出'number'。")]),a._v(" "),e("h2",{attrs:{id:"第29题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第29题"}},[a._v("#")]),a._v(" 第29题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log('b' + 'a' + +'a'+'a');\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'baNANa'\n")])])]),e("p",[a._v("'b' + 'a' + +'a'+'a'相当于'ba' + +'a'+'a',+'a'会将'a'转换为数字类型,即+'a' = NaN。所以最终得到'ba' + NaN +'a',通过字符串拼接,结果为:baNaNa")]),a._v(" "),e("h2",{attrs:{id:"第30题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第30题"}},[a._v("#")]),a._v(" 第30题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var obj = {n: 1};\nfunction fn2(a) {\n    a.n = 2;\n}\nfn2(obj);\nconsole.log(obj.n);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("2\n")])])]),e("p",[a._v("函数传递参数时,如果是基本类型为值传递,如果是引用类型,为引用地址的值传递。其实都是值传递。因此形参a和obj引用地址相同,都指向同一个对象。当执行a.n,实际上共同指向的对象修改了,添加了个n属性,因此obj.n为2。")]),a._v(" "),e("h2",{attrs:{id:"第31题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第31题"}},[a._v("#")]),a._v(" 第31题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var x = 10;\nfunction fn() {\n    console.log(x);\n}\nfunction show(f) {\n    var x = 20;\n    f();\n}\nshow(fn);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("10\n")])])]),e("p",[a._v("JavaScript采用的是词法作用域,它规定了函数内访问变量时,查找变量是从函数声明的位置向外层作用域中查找,而不是从调用函数的位置开始向上查找。因此fn函数内部访问的x是全局作用域中的x,而不是show函数作用域中的x。")]),a._v(" "),e("h2",{attrs:{id:"第32题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第32题"}},[a._v("#")]),a._v(" 第32题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Object.prototype.bar = 1; \nvar foo = {\n    goo: undefined\n};\n\nconsole.log(foo.bar);\nconsole.log('bar' in foo);\n\nconsole.log(foo.hasOwnProperty('bar'));\nconsole.log(foo.hasOwnProperty('goo'));\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1\ntrue\nfalse\ntrue\n")])])]),e("p",[a._v("in操作符:检测指定对象(右边)原型链上是否有对应的属性值。\nhasOwnProperty方法:检测指定对象自身上是否有对应的属性值。两者的区别在于in会查找原型链,而hasOwnProperty不会。\n示例中对象foo自身上存在goo属性,而它的原型链上存在bar属性。\n通过这个例子要注意如果要判断foo上是否有属性goo,不能简单的通过if(foo.goo){}判断,因为goo的值可能为undefined或者其他可能隐式转换为false的值。")]),a._v(" "),e("h2",{attrs:{id:"第33题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第33题"}},[a._v("#")]),a._v(" 第33题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Object.prototype.bar = 1;\n\nvar foo = {\n    moo: 2\n};\nfor(var i in foo) {\n    console.log(i); \n}\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'moo'\n'bar'\n")])])]),e("p",[a._v("for...in...遍历对象上除了Symbol以外的可枚举属性,包括原型链上的属性。")]),a._v(" "),e("h2",{attrs:{id:"第34题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第34题"}},[a._v("#")]),a._v(" 第34题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('function foo1() {\n    return {\n        bar: "hello"\n    };\n}\nfunction foo2() {\n    return \n    {\n        bar: "hello"\n    };\n}\nconsole.log(foo1());\nconsole.log(foo2());\n')])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('{ bar: "hello" }\n\nundefined\n')])])]),e("p",[a._v("两个函数唯一区别就是return后面跟的值,一个换行一个不换行。")]),a._v(" "),e("p",[a._v("当我们书写代码时忘记在结尾书写;时,JavaScript解析器会根据一定规则自动补上;。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('return\n{\n    bar: "hello"\n}\n=> 会被解析成\nreturn;\n{\n    bar: "hello"\n};\n')])])]),e("p",[a._v("因此函数执行后会返回undefined。")]),a._v(" "),e("h2",{attrs:{id:"第35题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第35题"}},[a._v("#")]),a._v(" 第35题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log((function(){ return typeof arguments; })());\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("'object'\n")])])]),e("p",[a._v("arguments为类数组,类型为object。因此typeof arguments = 'object'。")]),a._v(" "),e("h2",{attrs:{id:"第36题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第36题"}},[a._v("#")]),a._v(" 第36题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(Boolean(false));\nconsole.log(Boolean('0'));\nconsole.log(Boolean(''));\nconsole.log(Boolean(NaN));\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("false\ntrue\nfalse\nfasle\n")])])]),e("p",[a._v("只有下面几种值在转换为布尔值时为false:")]),a._v(" "),e("p",[e("code",[a._v("+0,-0,NaN,false,'',null,undefined。")])]),a._v(" "),e("p",[a._v("除此之外的值在转换为布尔值的时候全部为true。")]),a._v(" "),e("h2",{attrs:{id:"第37题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第37题"}},[a._v("#")]),a._v(" 第37题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(Array(3));\n\nconsole.log(Array(2,3));\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[empty × 3] \n\n[2,3]\n")])])]),e("p",[a._v("使用Array()创建数组时,要注意传入的值的类型和数量。")]),a._v(" "),e("h2",{attrs:{id:"第38题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第38题"}},[a._v("#")]),a._v(" 第38题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(0.1 + 0.2 == 0.3);\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("false\n")])])]),e("h2",{attrs:{id:"第39题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第39题"}},[a._v("#")]),a._v(" 第39题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a=[1, 2, 3];\nconsole.log(a.join());\n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1,2,3\n")])])]),e("p",[a._v("join方法如果省略参数,默认以,分隔。")]),a._v(" "),e("h2",{attrs:{id:"第40题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第40题"}},[a._v("#")]),a._v(" 第40题")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = [3];\nvar b = [1];\nconsole.log(a - b); \n")])])]),e("p",[a._v("输出:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("2\n")])])]),e("p",[a._v("在执行a - b时,a和b都要转换为数字。首先a先转换为字符串,[3] => [3].toString() => '3',然后Number(3) => 3。b同理。因此转换之后为3 - 1 = 2。")])])}),[],!1,null,null,null);e.default=s.exports}}]);