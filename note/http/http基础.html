<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>http 基础 | 码农机器人</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="努力向前">
    
    <link rel="preload" href="/assets/css/0.styles.b8d0645b.css" as="style"><link rel="preload" href="/assets/js/app.61a85b1c.js" as="script"><link rel="preload" href="/assets/js/2.6b359b12.js" as="script"><link rel="preload" href="/assets/js/35.6950ed93.js" as="script"><link rel="prefetch" href="/assets/js/10.6bf522d2.js"><link rel="prefetch" href="/assets/js/100.a249a4e9.js"><link rel="prefetch" href="/assets/js/101.9d2465ad.js"><link rel="prefetch" href="/assets/js/102.5ea0ea92.js"><link rel="prefetch" href="/assets/js/103.ad073f03.js"><link rel="prefetch" href="/assets/js/104.afd1455c.js"><link rel="prefetch" href="/assets/js/105.5429d9b6.js"><link rel="prefetch" href="/assets/js/106.012719c5.js"><link rel="prefetch" href="/assets/js/107.fa002f10.js"><link rel="prefetch" href="/assets/js/108.9c70864a.js"><link rel="prefetch" href="/assets/js/109.ab6712ef.js"><link rel="prefetch" href="/assets/js/11.07adb038.js"><link rel="prefetch" href="/assets/js/110.3496849e.js"><link rel="prefetch" href="/assets/js/111.0708cccd.js"><link rel="prefetch" href="/assets/js/112.3ddda9ff.js"><link rel="prefetch" href="/assets/js/113.a826b4ec.js"><link rel="prefetch" href="/assets/js/114.54f06bf1.js"><link rel="prefetch" href="/assets/js/115.68bd2270.js"><link rel="prefetch" href="/assets/js/116.0e283e33.js"><link rel="prefetch" href="/assets/js/117.10ca7c11.js"><link rel="prefetch" href="/assets/js/118.0f21544b.js"><link rel="prefetch" href="/assets/js/119.3d5cdaf0.js"><link rel="prefetch" href="/assets/js/12.6a633ec9.js"><link rel="prefetch" href="/assets/js/13.2e8873e5.js"><link rel="prefetch" href="/assets/js/14.0ea5ac55.js"><link rel="prefetch" href="/assets/js/15.d24d1240.js"><link rel="prefetch" href="/assets/js/16.bfb99431.js"><link rel="prefetch" href="/assets/js/17.0bf6db21.js"><link rel="prefetch" href="/assets/js/18.f6a16197.js"><link rel="prefetch" href="/assets/js/19.15b1e095.js"><link rel="prefetch" href="/assets/js/20.56746f5a.js"><link rel="prefetch" href="/assets/js/21.5019bb92.js"><link rel="prefetch" href="/assets/js/22.36a83eaf.js"><link rel="prefetch" href="/assets/js/23.c1d826fa.js"><link rel="prefetch" href="/assets/js/24.66437f58.js"><link rel="prefetch" href="/assets/js/25.b5ef9760.js"><link rel="prefetch" href="/assets/js/26.1e34c193.js"><link rel="prefetch" href="/assets/js/27.ea4375e5.js"><link rel="prefetch" href="/assets/js/28.8e440e91.js"><link rel="prefetch" href="/assets/js/29.ffd2070e.js"><link rel="prefetch" href="/assets/js/3.a6d8cb97.js"><link rel="prefetch" href="/assets/js/30.c1451f4e.js"><link rel="prefetch" href="/assets/js/31.a21ecc83.js"><link rel="prefetch" href="/assets/js/32.5d1de9ff.js"><link rel="prefetch" href="/assets/js/33.f9eef1d1.js"><link rel="prefetch" href="/assets/js/34.edb8fde2.js"><link rel="prefetch" href="/assets/js/36.b394a848.js"><link rel="prefetch" href="/assets/js/37.f11aa33f.js"><link rel="prefetch" href="/assets/js/38.e86bdf7f.js"><link rel="prefetch" href="/assets/js/39.dbc9c882.js"><link rel="prefetch" href="/assets/js/4.f3783df1.js"><link rel="prefetch" href="/assets/js/40.470a2b37.js"><link rel="prefetch" href="/assets/js/41.bcffb885.js"><link rel="prefetch" href="/assets/js/42.484ee502.js"><link rel="prefetch" href="/assets/js/43.2a86b409.js"><link rel="prefetch" href="/assets/js/44.2b684e4d.js"><link rel="prefetch" href="/assets/js/45.4e6fb818.js"><link rel="prefetch" href="/assets/js/46.86268f46.js"><link rel="prefetch" href="/assets/js/47.84f7cda3.js"><link rel="prefetch" href="/assets/js/48.fd78be04.js"><link rel="prefetch" href="/assets/js/49.f5a6fc1e.js"><link rel="prefetch" href="/assets/js/5.892f2cf8.js"><link rel="prefetch" href="/assets/js/50.29919944.js"><link rel="prefetch" href="/assets/js/51.c1b5918c.js"><link rel="prefetch" href="/assets/js/52.c4ad64f8.js"><link rel="prefetch" href="/assets/js/53.df154372.js"><link rel="prefetch" href="/assets/js/54.4fee1b96.js"><link rel="prefetch" href="/assets/js/55.18c6e9f2.js"><link rel="prefetch" href="/assets/js/56.d5569485.js"><link rel="prefetch" href="/assets/js/57.9eb74b69.js"><link rel="prefetch" href="/assets/js/58.c8b7968e.js"><link rel="prefetch" href="/assets/js/59.a208d99c.js"><link rel="prefetch" href="/assets/js/6.a9a81823.js"><link rel="prefetch" href="/assets/js/60.c0f7048b.js"><link rel="prefetch" href="/assets/js/61.e06e2c12.js"><link rel="prefetch" href="/assets/js/62.3726a0b9.js"><link rel="prefetch" href="/assets/js/63.53a81692.js"><link rel="prefetch" href="/assets/js/64.ba6af384.js"><link rel="prefetch" href="/assets/js/65.2f165ffa.js"><link rel="prefetch" href="/assets/js/66.8c0a983a.js"><link rel="prefetch" href="/assets/js/67.74bf1c32.js"><link rel="prefetch" href="/assets/js/68.27c15e0b.js"><link rel="prefetch" href="/assets/js/69.5b78d6fb.js"><link rel="prefetch" href="/assets/js/7.a9e85c97.js"><link rel="prefetch" href="/assets/js/70.4772f9bd.js"><link rel="prefetch" href="/assets/js/71.2a2e89e4.js"><link rel="prefetch" href="/assets/js/72.3debedf0.js"><link rel="prefetch" href="/assets/js/73.c9ee93ce.js"><link rel="prefetch" href="/assets/js/74.7ec9495c.js"><link rel="prefetch" href="/assets/js/75.8c828ff5.js"><link rel="prefetch" href="/assets/js/76.986dc0d7.js"><link rel="prefetch" href="/assets/js/77.7e7e3c8e.js"><link rel="prefetch" href="/assets/js/78.200d9828.js"><link rel="prefetch" href="/assets/js/79.ee6b28e9.js"><link rel="prefetch" href="/assets/js/8.448002b9.js"><link rel="prefetch" href="/assets/js/80.93d03d67.js"><link rel="prefetch" href="/assets/js/81.eebcba15.js"><link rel="prefetch" href="/assets/js/82.3b0bb838.js"><link rel="prefetch" href="/assets/js/83.75234d18.js"><link rel="prefetch" href="/assets/js/84.1a897e55.js"><link rel="prefetch" href="/assets/js/85.8267b168.js"><link rel="prefetch" href="/assets/js/86.a7557c20.js"><link rel="prefetch" href="/assets/js/87.4f7e77b3.js"><link rel="prefetch" href="/assets/js/88.9b41f10e.js"><link rel="prefetch" href="/assets/js/89.662b9425.js"><link rel="prefetch" href="/assets/js/9.804860d0.js"><link rel="prefetch" href="/assets/js/90.6d84e2d8.js"><link rel="prefetch" href="/assets/js/91.650a7b6f.js"><link rel="prefetch" href="/assets/js/92.8568032c.js"><link rel="prefetch" href="/assets/js/93.0c300b40.js"><link rel="prefetch" href="/assets/js/94.f7ce23ff.js"><link rel="prefetch" href="/assets/js/95.e6c8272f.js"><link rel="prefetch" href="/assets/js/96.8f51c3ac.js"><link rel="prefetch" href="/assets/js/97.9cc683f5.js"><link rel="prefetch" href="/assets/js/98.6af1269f.js"><link rel="prefetch" href="/assets/js/99.97a09de8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8d0645b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="码农机器人" class="logo"> <span class="site-name can-hide">码农机器人</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>建立前端知识体系</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue源码分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>提效赋能 前端工程化篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>程序员PLUS篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>HTTP</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/http/HTTP协议.html" class="sidebar-link">HTTP简介</a></li><li><a href="/note/http/HTTP缓存.html" class="sidebar-link">HTTP缓存</a></li><li><a href="/note/http/DNS.html" class="sidebar-link">DNS</a></li><li><a href="/note/http/TCP-IP.html" class="sidebar-link">TCP/IP</a></li><li><a href="/note/http/http基础.html" class="active sidebar-link">http 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http/http基础.html#浏览器输入-url-按回车背后经历了哪些" class="sidebar-link">浏览器输入 url 按回车背后经历了哪些?</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#get-和-post-的区别" class="sidebar-link">GET 和 POST 的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http/http基础.html#localstorage-与-sessionstorage-与-cookie-的区别总结" class="sidebar-link">localStorage 与 sessionStorage 与 cookie 的区别总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#http-状态码" class="sidebar-link">HTTP 状态码</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#http-和-https-区别" class="sidebar-link">http 和 https 区别？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#什么是-http-协议无状态协议-怎么解决-http-协议无状态协议" class="sidebar-link">什么是 Http 协议无状态协议?怎么解决 Http 协议无状态协议?</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#三次握手和四次挥手" class="sidebar-link">三次握手和四次挥手</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#为什么连接的时候是三次握手-关闭的时候却是四次握手" class="sidebar-link">为什么连接的时候是三次握手，关闭的时候却是四次握手？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#为什么-time-wait-状态需要经过-2msl-最大报文段生存时间-才能返回到-close-状态" class="sidebar-link">为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#为什么不能用两次握手进行连接" class="sidebar-link">为什么不能用两次握手进行连接？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#如果已经建立了连接-但是客户端突然出现故障了怎么办" class="sidebar-link">如果已经建立了连接，但是客户端突然出现故障了怎么办？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#什么是-xss-攻击" class="sidebar-link">什么是 XSS 攻击？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http/http基础.html#概念" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#攻击类型" class="sidebar-link">攻击类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#如何防御-xss-攻击" class="sidebar-link">如何防御 XSS 攻击？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#什么是-csrf-攻击" class="sidebar-link">什么是 CSRF 攻击？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http/http基础.html#概念-2" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#攻击类型-2" class="sidebar-link">攻击类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#有哪些可能引起前端安全的问题" class="sidebar-link">有哪些可能引起前端安全的问题?</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#网络劫持有哪几种-如何防范" class="sidebar-link">网络劫持有哪几种，如何防范？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#浏览器渲染进程的线程有哪些" class="sidebar-link">浏览器渲染进程的线程有哪些</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#僵尸进程和孤儿进程是什么" class="sidebar-link">僵尸进程和孤儿进程是什么？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#如何实现浏览器内多个标签页之间的通信" class="sidebar-link">如何实现浏览器内多个标签页之间的通信?</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#对浏览器的缓存机制的理解" class="sidebar-link">对浏览器的缓存机制的理解</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#协商缓存和强缓存的区别" class="sidebar-link">协商缓存和强缓存的区别</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别" class="sidebar-link">点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#浏览器的渲染过程" class="sidebar-link">浏览器的渲染过程</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#渲染过程中遇到-js-文件如何处理" class="sidebar-link">渲染过程中遇到 JS 文件如何处理？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#前端储存的方式有哪些" class="sidebar-link">前端储存的⽅式有哪些？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#对事件循环的理解" class="sidebar-link">对事件循环的理解</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#get-和-post-的请求的区别" class="sidebar-link">GET 和 POST 的请求的区别</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#post-和-put-请求的区别" class="sidebar-link">POST 和 PUT 请求的区别</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#常见的-http-请求方法" class="sidebar-link">常见的 HTTP 请求方法</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#http-1-1-和-http-2-0-的区别" class="sidebar-link">HTTP 1.1 和 HTTP 2.0 的区别</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#http-和-https-协议的区别" class="sidebar-link">HTTP 和 HTTPS 协议的区别</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#说一下-http-3-0" class="sidebar-link">说一下 HTTP 3.0</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#什么是-https-协议" class="sidebar-link">什么是 HTTPS 协议？</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#https-通信-握手-过程" class="sidebar-link">HTTPS 通信（握手）过程</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#dns-完整的查询过程" class="sidebar-link">DNS 完整的查询过程</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#osi-七层模型" class="sidebar-link">OSI 七层模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/http/http基础.html#应用层" class="sidebar-link">应用层</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#表示层" class="sidebar-link">表示层</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#会话层" class="sidebar-link">会话层</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#传输层" class="sidebar-link">传输层</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#网络层" class="sidebar-link">网络层</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#数据链路层" class="sidebar-link">数据链路层</a></li><li class="sidebar-sub-header"><a href="/note/http/http基础.html#物理层" class="sidebar-link">物理层</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>忍者秘籍书</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="http-基础"><a href="#http-基础" class="header-anchor">#</a> http 基础</h1> <h2 id="浏览器输入-url-按回车背后经历了哪些"><a href="#浏览器输入-url-按回车背后经历了哪些" class="header-anchor">#</a> 浏览器输入 url 按回车背后经历了哪些?</h2> <ul><li>在浏览器地址栏输入 url，先解析 ulr，检测 url 地址是否合法</li> <li>浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
<ul><li>浏览器缓存:浏览器会记录 DNS 一段时间，因此，只是第一个地方解析 DNS 请求；</li> <li>操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录(保存最近的 DNS 查询缓存)；</li> <li>路由器缓存:如果上述两个步骤均不能成功获取 DNS 记录，继续搜索路由器缓存</li> <li>ISP 缓存:若上述均失败，继续向 ISP 搜索。</li></ul></li> <li>在发送 http 请求前，需要域名解析(DNS 解析)，解析获取响应的 IP 地址</li> <li>浏览器向服务器发送 tcp 链接，与浏览器简历 tcp 三次握手。</li> <li>握手成功后，浏览器向服务器发送 http 请求，请求数据包。</li> <li>服务器处理收到的请求，将数据返回至浏览器。</li> <li>浏览器收到 http 响应。</li> <li>浏览器解码响应，如果响应可以缓存，则存入缓存。</li> <li>浏览器发送请求获取嵌入在 HTML 中的资源(html，css，JavaScript，图片，音乐......)。</li> <li>浏览器发送异步请求。</li> <li>页面全部渲染结束。</li></ul> <h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> GET 和 POST 的区别</h2> <ul><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li> <li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li> <li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li> <li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li> <li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。</li> <li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li> <li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li> <li>GET 参数通过 URL 传递，POST 放在 Request body 中。</li></ul> <p>GET 和 POST 有一个重大区别，简单的说：</p> <p><strong>GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</strong></p> <p>长的说：</p> <p><strong>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；
而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</strong></p> <h3 id="localstorage-与-sessionstorage-与-cookie-的区别总结"><a href="#localstorage-与-sessionstorage-与-cookie-的区别总结" class="header-anchor">#</a> localStorage 与 sessionStorage 与 cookie 的区别总结</h3> <ul><li><p><strong>共同点</strong>: 都保存在浏览器端, 且同源</p></li> <li><p><strong>在同一浏览器下生命周期不同</strong></p> <p>Cookie 生命周期: 默认是关闭浏览器后失效, 但是也可以设置过期时间</p> <p>SessionStorage 生命周期: 仅在当前会话(窗口)下有效，关闭窗口或浏览器后被清除, 不能设置过期时间</p> <p>LocalStorage 生命周期:除非被清除，否则永久保存</p></li> <li><p><strong>容量不同</strong></p> <p>Cookie 容量限制: 大小(4KB 左右)和个数(20~50)</p> <p>SessionStorage 和 LocalStorage 容量限制: 大小(5M 左右)</p></li> <li><p><strong>网络请求不同</strong></p> <p>Cookie 网络请求:每次都会携带在 HTTP 请求头中，如果使用 cookie 保存过多数据会带来性能问题</p> <p>SessionStorage 和 LocalStorage 网络请求: 仅在浏览器中保存，不参与和服务器的通信</p></li></ul> <h2 id="http-状态码"><a href="#http-状态码" class="header-anchor">#</a> HTTP 状态码</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">200</span> 请求已成功，请求所希望的响应头或数据体将随此响应返回。
<span class="token number">201</span> 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 <span class="token constant">URI</span> 已经随Location 头信息返回
<span class="token number">202</span> 服务器已接受请求，但尚未处理
<span class="token number">301</span> （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 <span class="token constant">GET</span> 或 <span class="token constant">HEAD</span> 请求的响应）时，会自动将请求者转到新位置。
<span class="token number">302</span> （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
<span class="token number">303</span> （查看其他位置） 请求者应当对不同的位置使用单独的 <span class="token constant">GET</span> 请求来检索响应时，服务器返回此代码。
<span class="token number">304</span> （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
<span class="token number">305</span> （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
<span class="token number">307</span> （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
<span class="token number">401</span> 当前请求需要用户验证。如果当前请求已经包含了 Authorization 证书，那么<span class="token number">401</span>响应代表着服务器验证已经拒绝了那些证书
<span class="token number">403</span> 服务器已经理解请求，但是拒绝执行它。与<span class="token number">401</span>响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交
<span class="token number">404</span> 请求失败，请求所希望得到的资源未被在服务器上发现
<span class="token number">500</span> 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。
<span class="token number">501</span> 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。
<span class="token number">502</span> 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
<span class="token number">503</span> 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。
</code></pre></div><h2 id="http-和-https-区别"><a href="#http-和-https-区别" class="header-anchor">#</a> http 和 https 区别？</h2> <p>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是王景公司设计了 SSL 协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单的说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输，身份认证的网络协议，要比 http 协议安全。</p> <p>主要区别如下:</p> <p>HTTPS = SSL + HTTP</p> <ul><li>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。</li> <li>http 是超文本传输协议，信息是明文传输，https 是具有安全性的 ssl 加密传输协议。</li> <li>http 和 https 使用的完全不同的链接方式，用的端口也不一样，前者是 80，后者是 443。</li> <li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+ HTTP 协议构建的可进行加密传输，身份认证的网络协议，比如 http 协议安全。</li></ul> <h2 id="什么是-http-协议无状态协议-怎么解决-http-协议无状态协议"><a href="#什么是-http-协议无状态协议-怎么解决-http-协议无状态协议" class="header-anchor">#</a> 什么是 Http 协议无状态协议?怎么解决 Http 协议无状态协议?</h2> <ul><li>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息</li> <li>无状态协议解决办法： 通过 1、Cookie 2、通过 Session 会话保存</li></ul> <h2 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="header-anchor">#</a> 三次握手和四次挥手</h2> <p><a href="/note/knowledge/tcp.html">三次握手和四次挥手</a></p> <h2 id="为什么连接的时候是三次握手-关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手-关闭的时候却是四次握手" class="header-anchor">#</a> 为什么连接的时候是三次握手，关闭的时候却是四次握手？</h2> <p>因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，&quot;你发的 FIN 报文我收到了&quot;。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。</p> <h2 id="为什么-time-wait-状态需要经过-2msl-最大报文段生存时间-才能返回到-close-状态"><a href="#为什么-time-wait-状态需要经过-2msl-最大报文段生存时间-才能返回到-close-状态" class="header-anchor">#</a> 为什么 TIME_WAIT 状态需要经过 2MSL(最大报文段生存时间)才能返回到 CLOSE 状态？</h2> <p>虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个 ACK 丢失。所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。在 Client 发送出最后的 ACK 回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送 FIN 片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该 ACK。Client 会在发送出 ACK 之后进入到 TIME_WAIT 状态。Client 会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么 Client 会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p> <h2 id="为什么不能用两次握手进行连接"><a href="#为什么不能用两次握手进行连接" class="header-anchor">#</a> 为什么不能用两次握手进行连接？</h2> <p>3 次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p> <p>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机 S 和 C 之间的通信，假定 C 给 S 发送一个连接请求分组，S 收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S 认为连接已经成功地建立了，可以开始发送数据分组。可是，C 在 S 的应答分组在传输中被丢失的情况下，将不知道 S 是否已准备好，不知道 S 建立什么样的序列号，C 甚至怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分 组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p> <h2 id="如果已经建立了连接-但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接-但是客户端突然出现故障了怎么办" class="header-anchor">#</a> 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2> <p>TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p> <h2 id="什么是-xss-攻击"><a href="#什么是-xss-攻击" class="header-anchor">#</a> 什么是 XSS 攻击？</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在
网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信
息如 cookie 等。</p> <p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合
在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意
代码的执行。</p> <p>攻击者可以通过这种攻击方式可以进行以下操作：</p> <ul><li>获取页面的数据，如 DOM、cookie、localStorage；</li> <li>DOS 攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li> <li>破坏页面结构；</li> <li>流量劫持（将链接指向某网站）；</li></ul> <h3 id="攻击类型"><a href="#攻击类型" class="header-anchor">#</a> 攻击类型</h3> <p>XSS 可以分为存储型、反射型和 DOM 型：
存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，
脚本从服务器传回并执行。</p> <p>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服
务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，
浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。</p> <p>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</p> <h4 id="存储型-xss-的攻击步骤"><a href="#存储型-xss-的攻击步骤" class="header-anchor">#</a> 存储型 XSS 的攻击步骤：</h4> <ul><li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li> <li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接
在 HTML 中返回给浏览器。</li> <li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li> <li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏
为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评
论、⽤户私信等。</li></ul> <h4 id="反射型-xss-的攻击步骤"><a href="#反射型-xss-的攻击步骤" class="header-anchor">#</a> 反射型 XSS 的攻击步骤：</h4> <ul><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li> <li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL
中取出，拼接在 HTML 中返回给浏览器。</li> <li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li> <li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏
为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。
反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在
数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</li></ul> <p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳
转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会
结合多种⼿段诱导⽤户点击。</p> <h4 id="dom-型-xss-的攻击步骤"><a href="#dom-型-xss-的攻击步骤" class="header-anchor">#</a> DOM 型 XSS 的攻击步骤：</h4> <ul><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li> <li>⽤户打开带有恶意代码的 URL。</li> <li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL
中的恶意代码并执⾏。</li> <li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏
为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ul> <p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执
⾏恶意代码由浏览器端完成，属于前端 JavaScript ⾃身的安全漏洞，
⽽其他两种 XSS 都属于服务端的安全漏洞。</p> <h2 id="如何防御-xss-攻击"><a href="#如何防御-xss-攻击" class="header-anchor">#</a> 如何防御 XSS 攻击？</h2> <p>可以看到 XSS 危害如此之大，那么在开发网站时就要做好防御措施，
具体措施如下：</p> <p>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服
务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到
HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚
本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对
可能出现的恶意代码情况进行判断。</p> <p>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资
源可以加载和执行，从而防止恶意代码的注入攻击。</p> <p>1.CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览
器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由
浏览器自己来实现。</p> <p>2.通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的
Content-Security-Policy，一种是设置 meta 标签的方式 </p><meta http-equiv="Content-Security-Policy">
对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本
无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。<p></p> <h2 id="什么是-csrf-攻击"><a href="#什么是-csrf-攻击" class="header-anchor">#</a> 什么是 CSRF 攻击？</h2> <h3 id="概念-2"><a href="#概念-2" class="header-anchor">#</a> 概念</h3> <p>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三
方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击
网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过
后台的用户验证，冒充用户向服务器执行一些操作。</p> <p>CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器
的特点，以此来实现用户的冒充。</p> <h3 id="攻击类型-2"><a href="#攻击类型-2" class="header-anchor">#</a> 攻击类型</h3> <p>常见的 CSRF 攻击有三种：</p> <ul><li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个
请求，当用户打开这个网站的时候就会自动发起提交。</li> <li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户
进入页面时，自动提交这个表单。</li> <li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请
求，然后诱导用户去点击。</li></ul> <h2 id="有哪些可能引起前端安全的问题"><a href="#有哪些可能引起前端安全的问题" class="header-anchor">#</a> 有哪些可能引起前端安全的问题?</h2> <p>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了
与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没
有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖
⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不
限于 JavaScript / CSS / Flash 等；</p> <p>iframe 的滥⽤: iframe 中的内容是由第三⽅来提供的，默认情况下
他们不受控制，他们可以在 iframe 中运⾏ JavaScirpt 脚本、Flash
插件、弹出对话框等等，这可能会破坏前端⽤户体验；</p> <p>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击
者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信
息或设定信息等某些状态更新，属于被动攻击；</p> <p>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数
时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被
植⼊恶意代码很容易引起安全问题。</p> <h2 id="网络劫持有哪几种-如何防范"><a href="#网络劫持有哪几种-如何防范" class="header-anchor">#</a> 网络劫持有哪几种，如何防范？</h2> <p>⽹络劫持分为两种:</p> <p>（1）DNS 劫持: (输⼊京东被强制跳转到淘宝这就属于 dns 劫持)</p> <p>DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导⽤户流量到缓存服务器</p> <p>302 跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可
以进⾏劫持处理的,再对劫持的内存发起 302 跳转的回复，引导⽤户
获取内容</p> <p>（2）HTTP 劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于 http
明⽂传输,运营商会修改你的 http 响应内容(即加⼴告)</p> <p>（3）DNS 劫持由于涉嫌违法，已经被监管起来，现在很少会有 DNS
劫持，⽽ http 劫持依然⾮常盛⾏，最有效的办法就是全站 HTTPS，将
HTTP 加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p> <h2 id="浏览器渲染进程的线程有哪些"><a href="#浏览器渲染进程的线程有哪些" class="header-anchor">#</a> 浏览器渲染进程的线程有哪些</h2> <p>浏览器的渲染进程的线程总共有五种：</p> <p>（1）GUI 渲染线程</p> <p>负责渲染浏览器页面，解析 HTML、CSS，构建 DOM 树、构建 CSSOM 树、
构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，
该线程就会执行。</p> <p>注意：GUI 渲染线程和 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI
线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时
立即被执行。</p> <p>（2）JS 引擎线程</p> <p>JS 引擎线程也称为 JS 内核，负责处理 Javascript 脚本程序，解析
Javascript 脚本，运行代码；JS 引擎线程一直等待着任务队列中任
务的到来，然后加以处理，一个 Tab 页中无论什么时候都只有一个
JS 引擎线程在运行 JS 程序；</p> <p>注意：GUI 渲染线程与 JS 引擎线程的互斥关系，所以如果 JS 执行的
时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p> <p>（3）时间触发线程</p> <p>时间触发线程属于浏览器而不是 JS 引擎，用来控制事件循环；当 JS
引擎执行代码块如 setTimeOut 时（也可是来自浏览器内核的其他线
程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件触发
线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加
到待处理队列的队尾，等待 JS 引擎的处理；</p> <p>注意：由于 JS 的单线程关系，所以这些待处理队列中的事件都得排
队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）；</p> <p>（4）定时器触发进程</p> <p>定时器触发进程即 setInterval 与 setTimeout 所在线程；浏览器定
时计数器并不是由 JS 引擎计数的，因为 JS 引擎是单线程的，如果处
于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时
并触发定时器，计时完毕后，添加到事件队列中，等待 JS 引擎空闲
后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，
定时器只是在指定时间点将任务添加到事件队列中；</p> <p>注意：W3C 在 HTML 标准中规定，定时器的定时时间不能小于 4ms，如
果是小于 4ms，则默认为 4ms。</p> <p>（5）异步 http 请求线程</p> <p>XMLHttpRequest 连接后通过浏览器新开一个线程请求；</p> <p>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更
事件，将回调函数放入事件队列中，等待 JS 引擎空闲后执行；</p> <h2 id="僵尸进程和孤儿进程是什么"><a href="#僵尸进程和孤儿进程是什么" class="header-anchor">#</a> 僵尸进程和孤儿进程是什么？</h2> <p>孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些
子进程都会成为孤儿进程。孤儿进程将被 init 进程(进程号为 1)所
收养，并由 init 进程对它们完成状态收集工作。</p> <p>僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用
的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之
为僵死进程。</p> <h2 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="header-anchor">#</a> 如何实现浏览器内多个标签页之间的通信?</h2> <p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。
因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让
标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通
信方法如下：</p> <p>使用 websocket 协议，因为 websocket 协议可以实现服务器推送，
所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数
据，然后由服务器向其他标签页推送转发。</p> <p>使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期
内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。
这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个
线程，然后通过这个共享的线程来实现数据的交换。</p> <p>使用 localStorage 的方式，我们可以在一个标签页对 localStorage
的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就
可以通过这个监听事件来获取到数据。这个时候 localStorage 对象
就是充当的中介者的角色。</p> <p>使用 postMessage 方法，如果我们能够获得对应标签页的引用，就
可以使用 postMessage 方法，进行通信。</p> <h2 id="对浏览器的缓存机制的理解"><a href="#对浏览器的缓存机制的理解" class="header-anchor">#</a> 对浏览器的缓存机制的理解</h2> <p>浏览器缓存的全过程：</p> <p>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源
文件，并缓存资源文件与 response header，以供下次加载时对比使用；</p> <p>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上
一次返回 200 时的时间差，如果没有超过 cache-control 设置的
max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果
浏览器不支持 HTTP1.1，则使用 expires 头判断是否过期；</p> <p>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向
服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做
修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不
一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和
被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；
不一致则返回新的 last-modified 和文件并返回 200；</p> <p><img src="/http/cache.png" alt="cache.png"></p> <p>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS
或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户
端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时
获得网站的最新更新。</p> <h2 id="协商缓存和强缓存的区别"><a href="#协商缓存和强缓存的区别" class="header-anchor">#</a> 协商缓存和强缓存的区别</h2> <p>（1）强缓存</p> <p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必
再向服务器发起请求。</p> <p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的
Expires 属性和 Cache-Control 属性</p> <p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期
时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发
送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存
在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用
户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p> <p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP
1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供
了对资源的缓存的更精确的控制。它有很多不同的值，Cache-Control 可设置的字段：</p> <p>public：设置了该字段值的资源表示可以被任何对象（包括：发送请
求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是
使用 max-age=来精确控制；</p> <p>private：设置了该字段值的资源只能被用户浏览器缓存，不允许任
何代理服务器缓存。在实际开发当中，对于一些含有用户信息的 HTML，
通常都要设置这个字段值，避免代理服务器(CDN)缓存；</p> <p>no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了
变化，如果资源未发生变化，则直接使用缓存好的资源；</p> <p>no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起
新的请求，拉取最新的资源；</p> <p>max-age=：设置缓存的最大有效期，单位为秒；</p> <p>s-maxage=：优先级高于 max-age=，仅适用于共享缓存(CDN)，优先
级高于 max-age 或者 Expires 头；</p> <p>max-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源，
但是不能超过给定的时间限制。</p> <p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方
式一起使用时，Cache-Control 的优先级要高于 Expires。
no-cache 和 no-store 很容易混淆：</p> <p>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也
就是说没有强缓存，但是会有协商缓存；</p> <p>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</p> <p>（2）协商缓存</p> <p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如
果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会
发挥作用了。</p> <p>上面已经说到了，命中协商缓存的条件有两个：</p> <p>max-age=xxx 过期了</p> <p>值为 no-store</p> <p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发
生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如
果资源发生了修改，则返回修改后的资源。</p> <p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的
Etag 和 Last-Modified 属性。</p> <p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最
后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加
一个 If-Modified-Since 的属性，属性值为上一次资源返回时的
Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性
来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做
了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本
地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种
方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精
确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，那么文件
已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中
的不准确。</p> <p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提
供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，
在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，
当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，
浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值
就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值
来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改
变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式
更加精确。</p> <p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更
高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多
个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器
上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p> <p>总结：</p> <p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存
副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命
中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强
缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求
的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命
中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命
中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如
果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p> <h2 id="点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别"><a href="#点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别" class="header-anchor">#</a> 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h2> <p>点击刷新按钮或者按 F5：浏览器直接对本地的缓存文件过期，但是
会带上 If-Modifed-Since，If-None-Match，这就意味着服务器会对
文件检查新鲜度，返回结果可能是 304，也有可能是 200。</p> <p>用户按 Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，而且
不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有
请求过，返回结果是 200。</p> <p>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，
然后服务器检查新鲜度，最后返回内容。</p> <h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="header-anchor">#</a> 浏览器的渲染过程</h2> <p>浏览器渲染主要有以下步骤：</p> <p>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由
DOM 元素及属性节点组成的。</p> <p>然后对 CSS 进行解析，生成 CSSOM 规则树。</p> <p>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染
对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和
DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元
素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们
一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p> <p>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏
览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。
这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位
置和大小。通常这一行为也被称为“自动重排”。</p> <p>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint
方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</p> <p>注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会
尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完
成之后再去构建和布局 render 树。它是解析完一部分内容就显示一
部分内容，同时，可能还在通过网络下载其余内容。</p> <h2 id="渲染过程中遇到-js-文件如何处理"><a href="#渲染过程中遇到-js-文件如何处理" class="header-anchor">#</a> 渲染过程中遇到 JS 文件如何处理？</h2> <p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在
构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文
档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎
运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如
果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是
都建议将 script 标签放在 body 标签底部的原因。当然在当下，并
不是说 script 标签必须放在底部，因为你可以给 script 标签添加
defer 或者 async 属性。</p> <h2 id="前端储存的方式有哪些"><a href="#前端储存的方式有哪些" class="header-anchor">#</a> 前端储存的⽅式有哪些？</h2> <p>cookies： 在 HTML5 标准前本地储存的主要⽅式，优点是兼容性好，
请求头⾃带 cookie ⽅便，缺点是⼤⼩只有 4k，⾃动请求头加⼊ cookie
浪费流量，每个 domain 限制 20 个 cookie，使⽤起来麻烦，需要⾃⾏封装；</p> <p>localStorage：HTML5 加⼊的以键值对(Key-Value)为标准的⽅式，
优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为 5M，兼容 IE8+ ；</p> <p>sessionStorage：与 localStorage 基本类似，区别是 sessionStorage
当⻚⾯关闭后会被清理，⽽且与 cookie、localStorage 不同，他不
能在所有同源窗⼝中共享，是会话级别的储存⽅式；</p> <p>Web SQL：2010 年被 W3C 废弃的本地数据库数据存储⽅案，但是主流
浏览器（⽕狐除外）都已经有了相关的实现，web sql 类似于 SQLite，
是真正意义上的关系型数据库，⽤ sql 进⾏操作，当我们⽤ JavaScript
时要进⾏转换，较为繁琐；</p> <p>IndexedDB：是被正式纳⼊ HTML5 标准的数据库储存⽅案，它是 NoSQL
数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合 web
场景，同时⽤ JavaScript 进⾏操作会⾮常便。</p> <h2 id="对事件循环的理解"><a href="#对事件循环的理解" class="header-anchor">#</a> 对事件循环的理解</h2> <p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上
下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果
遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个
事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，
再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列
可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕
后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有
就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行
完成后再去执行宏任务队列中的任务。</p> <p>Event Loop 执行顺序如下所示：</p> <p>首先执行同步代码，这属于宏任务</p> <p>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</p> <p>执行所有微任务</p> <p>当执行完所有微任务后，如有必要会渲染页面</p> <p>然后开始下一轮 Event Loop，执行宏任务中的异步代码</p> <h2 id="get-和-post-的请求的区别"><a href="#get-和-post-的请求的区别" class="header-anchor">#</a> GET 和 POST 的请求的区别</h2> <p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p> <p>应用场景：GET 请求是一个幂等的请求，一般 Get 请求用于对服务
器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post
不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比
如注册用户这一类的操作。</p> <p>是否缓存：因为两者应用场景不同，浏览器一般会对 Get 请求缓存，
但很少对 Post 请求缓存。</p> <p>发送的报文格式：Get 请求的报文中实体部分为空，Post 请求的报
文中实体部分一般为向服务器发送的数据。</p> <p>安全性：Get 请求可以将请求的参数放入 url 中向服务器发送，这
样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会
被保留在历史记录中。</p> <p>请求长度：浏览器由于对 url 长度的限制，所以会影响 get 请求发
送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</p> <p>参数类型：post 的参数传递支持更多的数据类型</p> <p>从 TCP 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue), 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</p> <h2 id="post-和-put-请求的区别"><a href="#post-和-put-请求的区别" class="header-anchor">#</a> POST 和 PUT 请求的区别</h2> <p>PUT 请求是向服务器端发送数据，从而修改数据的内容，但是不会增
加数据的种类等，也就是说无论进行多少次 PUT 操作，其结果并没有
不同。（可以理解为时更新数据）</p> <p>POST 请求是向服务器端发送数据，该请求会改变数据的种类等资源，
它会创建新的内容。（可以理解为是创建数据）</p> <h2 id="常见的-http-请求方法"><a href="#常见的-http-请求方法" class="header-anchor">#</a> 常见的 HTTP 请求方法</h2> <p>GET: 向服务器获取数据；</p> <p>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</p> <p>PUT：上传文件，更新数据；</p> <p>DELETE：删除服务器上的对象；</p> <p>HEAD：获取报文首部，与 GET 相比，不返回报文主体部分；</p> <p>OPTIONS：询问支持的请求方法，用来跨域请求；</p> <p>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行 TCP 通信；</p> <p>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</p> <h2 id="http-1-1-和-http-2-0-的区别"><a href="#http-1-1-和-http-2-0-的区别" class="header-anchor">#</a> HTTP 1.1 和 HTTP 2.0 的区别</h2> <p>二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文
的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是
二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是
二进制，并且统称为&quot;帧&quot;，可以分为头信息帧和数据帧。 帧的概念
是它实现多路复用的基础。</p> <p>多路复用：HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，
但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，
而且不用按照顺序一一发送，这样就避免了&quot;队头堵塞&quot;的问题。</p> <p>数据流：HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不
按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。
因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每
个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个
独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分
它属于哪个数据流。</p> <p>头信息压缩：HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带
状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重
复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都
必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了
优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或
compress 压缩后再发送；另一方面，客户端和服务器同时维护一张
头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发
送同样字段了，只发送索引号，这样就能提高速度了。</p> <p>服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，
这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，
这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服
务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向
客户端发送即时数据的推送是不同的。</p> <h2 id="http-和-https-协议的区别"><a href="#http-和-https-协议的区别" class="header-anchor">#</a> HTTP 和 HTTPS 协议的区别</h2> <p>HTTP 和 HTTPS 协议的主要区别如下：</p> <ul><li>HTTPS 协议需要 CA 证书，费用较高；而 HTTP 协议不需要；</li> <li>HTTP 协议是超文本传输协议，信息是明文传输的，HTTPS 则是具有安
全性的 SSL 加密传输协议；</li> <li>使用不同的连接方式，端口也不同，HTTP 协议端口是 80，HTTPS 协
议端口是 443；</li> <li>HTTP 协议连接很简单，是无状态的；HTTPS 协议是有 SSL 和 HTTP 协
议构建的可进行加密传输、身份认证的网络协议，比 HTTP 更加安全。</li></ul> <h2 id="说一下-http-3-0"><a href="#说一下-http-3-0" class="header-anchor">#</a> 说一下 HTTP 3.0</h2> <p>HTTP/3 基于 UDP 协议实现了类似于 TCP 的多路复用数据流、传输可
靠性等功能，这套功能被称为 QUIC 协议。</p> <p>1.流量控制、传输可靠性功能：QUIC 在 UDP 的基础上增加了一层来
保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一
些 TCP 中的特性。</p> <p>2.集成 TLS 加密功能：目前 QUIC 使用 TLS1.3，减少了握手所花费的 RTT 数。</p> <p>3.多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了
数据流的单独传输，解决了 TCP 的队头阻塞问题</p> <p>4.快速握手：由于基于 UDP，可以实现使用 0 ~ 1 个 RTT 来建立连接。</p> <h2 id="什么是-https-协议"><a href="#什么是-https-协议" class="header-anchor">#</a> 什么是 HTTPS 协议？</h2> <p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：
HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经
由 HTTP 进行通信，利用 SSL/TLS 来加密数据包。HTTPS 的主要目的
是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p> <p>HTTP 协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持
的风险，而协议 TLS/SSL 具有身份验证、信息加密和完整性校验的功
能，可以避免此类问题发生。</p> <p>安全层的主要职责就是对发起的 HTTP 请求的数据进行加密操作 和
对接收到的 HTTP 的内容进行解密操作。</p> <h2 id="https-通信-握手-过程"><a href="#https-通信-握手-过程" class="header-anchor">#</a> HTTPS 通信（握手）过程</h2> <p>HTTPS 的通信过程如下：</p> <p>1.客户端向服务器发起请求，请求中包含使用的协议版本号、生成的
一个随机数、以及客户端支持的加密方法。</p> <p>2.服务器端接收到请求后，确认双方使用的加密方法、并给出服务器
的证书、以及一个服务器生成的随机数。</p> <p>3.客户端确认服务器证书有效后，生成一个新的随机数，并使用数字
证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供
一个前面所有内容的 hash 的值，用来供服务器检验。</p> <p>4.服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供
前面所有内容的 hash 值来供客户端检验。</p> <p>5.客户端和服务器端根据约定的加密方法使用前面的三个随机数，生
成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</p> <h2 id="dns-完整的查询过程"><a href="#dns-完整的查询过程" class="header-anchor">#</a> DNS 完整的查询过程</h2> <p>DNS 服务器解析域名的过程：</p> <ul><li><p>首先会在浏览器的缓存中查找对应的 IP 地址，如果查找到直接返回，
若找不到继续下一步</p></li> <li><p>将请求发送给本地 DNS 服务器，在本地域名服务器缓存中查询，如果
查找到，就直接将查找结果返回，若找不到继续下一步</p></li> <li><p>本地 DNS 服务器向根域名服务器发送请求，根域名服务器会返回一个
所查询域的顶级域名服务器地址</p></li> <li><p>本地 DNS 服务器向顶级域名服务器发送请求，接受请求的服务器查询
自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的
下一级的权威域名服务器的地址</p></li> <li><p>本地 DNS 服务器向权威域名服务器发送请求，域名服务器返回对应的结果</p></li> <li><p>本地 DNS 服务器将返回结果保存在缓存中，便于下次使用</p></li> <li><p>本地 DNS 服务器将返回结果返回给浏览器</p></li></ul> <p>比如要查询 www.baidu.com 的 IP 地址，首先会在浏览器的缓存中
查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS
服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，如果不存
在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com
的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其
中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶
级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。
然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，
最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p> <h2 id="osi-七层模型"><a href="#osi-七层模型" class="header-anchor">#</a> OSI 七层模型</h2> <p><img src="/http/1691746187661.jpg" alt=""></p> <h3 id="应用层"><a href="#应用层" class="header-anchor">#</a> 应用层</h3> <p>OSI 参考模型中最靠近用户的一层，是为计算机用户提供应用接口，
也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：
HTTP，HTTPS，FTP，POP3、SMTP 等。</p> <p>在客户端与服务器中经常会有数据的请求，这个时候就是会用到
http(hyper text transfer protocol)(超文本传输协议)或者 https. 在后端设计数据接口时，我们常常使用到这个协议。
FTP 是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，
在一些资源网站，比如百度网盘``迅雷应该是基于此协议的。</p> <p>SMTP 是 simple mail transfer protocol（简单邮件传输协议）。在
一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</p> <h3 id="表示层"><a href="#表示层" class="header-anchor">#</a> 表示层</h3> <p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的
应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可
提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通
信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p> <p>在项目开发中，为了方便数据传输，可以使用 base64 对数据进行编
解码。如果按功能来划分，base64 应该是工作在表示层。</p> <h3 id="会话层"><a href="#会话层" class="header-anchor">#</a> 会话层</h3> <p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层
的通信由不同设备中的应用程序之间的服务请求和响应组成。</p> <h3 id="传输层"><a href="#传输层" class="header-anchor">#</a> 传输层</h3> <p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端
到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等
问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只
是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、
可靠的数据通路。我们通常说的，TCP UDP 就是在这一层。端口号既
是这里的“端”。</p> <h3 id="网络层"><a href="#网络层" class="header-anchor">#</a> 网络层</h3> <p>本层通过 IP 寻址来建立两个节点之间的连接，为源端的运输层送来
的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目
的端的运输层。就是通常说的 IP 层。这一层就是我们经常说的 IP 协
议层。IP 协议是 Internet 的基础。我们可以这样理解，网络层规定
了数据包的传输路线，而传输层则规定了数据包的传输方式。</p> <h3 id="数据链路层"><a href="#数据链路层" class="header-anchor">#</a> 数据链路层</h3> <p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使
用 MAC 地址)来访问介质,并进行差错检测。</p> <p>网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理
解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。
不过，在数据链路层上还增加了差错控制的功能。</p> <h3 id="物理层"><a href="#物理层" class="header-anchor">#</a> 物理层</h3> <p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。
规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、
中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p> <p>OSI 七层模型通信特点：对等通信，为了使数据分组从源传送到目的地，源端 OSI 模型的每一
层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。
在每一层通信过程中，使用本层自己协议进行通信。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">9/5/2021, 6:55:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/http/TCP-IP.html" class="prev">
        TCP/IP
      </a></span> <span class="next"><a href="/note/webpacks/webpack.html">
        webpack
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.61a85b1c.js" defer></script><script src="/assets/js/2.6b359b12.js" defer></script><script src="/assets/js/35.6950ed93.js" defer></script>
  </body>
</html>
