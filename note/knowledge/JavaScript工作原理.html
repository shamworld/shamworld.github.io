<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript工作原理 | 码农机器人</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="努力向前">
    
    <link rel="preload" href="/assets/css/0.styles.b8d0645b.css" as="style"><link rel="preload" href="/assets/js/app.61a85b1c.js" as="script"><link rel="preload" href="/assets/js/2.6b359b12.js" as="script"><link rel="preload" href="/assets/js/47.84f7cda3.js" as="script"><link rel="prefetch" href="/assets/js/10.6bf522d2.js"><link rel="prefetch" href="/assets/js/100.a249a4e9.js"><link rel="prefetch" href="/assets/js/101.9d2465ad.js"><link rel="prefetch" href="/assets/js/102.5ea0ea92.js"><link rel="prefetch" href="/assets/js/103.ad073f03.js"><link rel="prefetch" href="/assets/js/104.afd1455c.js"><link rel="prefetch" href="/assets/js/105.5429d9b6.js"><link rel="prefetch" href="/assets/js/106.012719c5.js"><link rel="prefetch" href="/assets/js/107.fa002f10.js"><link rel="prefetch" href="/assets/js/108.9c70864a.js"><link rel="prefetch" href="/assets/js/109.ab6712ef.js"><link rel="prefetch" href="/assets/js/11.07adb038.js"><link rel="prefetch" href="/assets/js/110.3496849e.js"><link rel="prefetch" href="/assets/js/111.0708cccd.js"><link rel="prefetch" href="/assets/js/112.3ddda9ff.js"><link rel="prefetch" href="/assets/js/113.a826b4ec.js"><link rel="prefetch" href="/assets/js/114.54f06bf1.js"><link rel="prefetch" href="/assets/js/115.68bd2270.js"><link rel="prefetch" href="/assets/js/116.0e283e33.js"><link rel="prefetch" href="/assets/js/117.10ca7c11.js"><link rel="prefetch" href="/assets/js/118.0f21544b.js"><link rel="prefetch" href="/assets/js/119.3d5cdaf0.js"><link rel="prefetch" href="/assets/js/12.6a633ec9.js"><link rel="prefetch" href="/assets/js/13.2e8873e5.js"><link rel="prefetch" href="/assets/js/14.0ea5ac55.js"><link rel="prefetch" href="/assets/js/15.d24d1240.js"><link rel="prefetch" href="/assets/js/16.bfb99431.js"><link rel="prefetch" href="/assets/js/17.0bf6db21.js"><link rel="prefetch" href="/assets/js/18.f6a16197.js"><link rel="prefetch" href="/assets/js/19.15b1e095.js"><link rel="prefetch" href="/assets/js/20.56746f5a.js"><link rel="prefetch" href="/assets/js/21.5019bb92.js"><link rel="prefetch" href="/assets/js/22.36a83eaf.js"><link rel="prefetch" href="/assets/js/23.c1d826fa.js"><link rel="prefetch" href="/assets/js/24.66437f58.js"><link rel="prefetch" href="/assets/js/25.b5ef9760.js"><link rel="prefetch" href="/assets/js/26.1e34c193.js"><link rel="prefetch" href="/assets/js/27.ea4375e5.js"><link rel="prefetch" href="/assets/js/28.8e440e91.js"><link rel="prefetch" href="/assets/js/29.ffd2070e.js"><link rel="prefetch" href="/assets/js/3.a6d8cb97.js"><link rel="prefetch" href="/assets/js/30.c1451f4e.js"><link rel="prefetch" href="/assets/js/31.a21ecc83.js"><link rel="prefetch" href="/assets/js/32.5d1de9ff.js"><link rel="prefetch" href="/assets/js/33.f9eef1d1.js"><link rel="prefetch" href="/assets/js/34.edb8fde2.js"><link rel="prefetch" href="/assets/js/35.6950ed93.js"><link rel="prefetch" href="/assets/js/36.b394a848.js"><link rel="prefetch" href="/assets/js/37.f11aa33f.js"><link rel="prefetch" href="/assets/js/38.e86bdf7f.js"><link rel="prefetch" href="/assets/js/39.dbc9c882.js"><link rel="prefetch" href="/assets/js/4.f3783df1.js"><link rel="prefetch" href="/assets/js/40.470a2b37.js"><link rel="prefetch" href="/assets/js/41.bcffb885.js"><link rel="prefetch" href="/assets/js/42.484ee502.js"><link rel="prefetch" href="/assets/js/43.2a86b409.js"><link rel="prefetch" href="/assets/js/44.2b684e4d.js"><link rel="prefetch" href="/assets/js/45.4e6fb818.js"><link rel="prefetch" href="/assets/js/46.86268f46.js"><link rel="prefetch" href="/assets/js/48.fd78be04.js"><link rel="prefetch" href="/assets/js/49.f5a6fc1e.js"><link rel="prefetch" href="/assets/js/5.892f2cf8.js"><link rel="prefetch" href="/assets/js/50.29919944.js"><link rel="prefetch" href="/assets/js/51.c1b5918c.js"><link rel="prefetch" href="/assets/js/52.c4ad64f8.js"><link rel="prefetch" href="/assets/js/53.df154372.js"><link rel="prefetch" href="/assets/js/54.4fee1b96.js"><link rel="prefetch" href="/assets/js/55.18c6e9f2.js"><link rel="prefetch" href="/assets/js/56.d5569485.js"><link rel="prefetch" href="/assets/js/57.9eb74b69.js"><link rel="prefetch" href="/assets/js/58.c8b7968e.js"><link rel="prefetch" href="/assets/js/59.a208d99c.js"><link rel="prefetch" href="/assets/js/6.a9a81823.js"><link rel="prefetch" href="/assets/js/60.c0f7048b.js"><link rel="prefetch" href="/assets/js/61.e06e2c12.js"><link rel="prefetch" href="/assets/js/62.3726a0b9.js"><link rel="prefetch" href="/assets/js/63.53a81692.js"><link rel="prefetch" href="/assets/js/64.ba6af384.js"><link rel="prefetch" href="/assets/js/65.2f165ffa.js"><link rel="prefetch" href="/assets/js/66.8c0a983a.js"><link rel="prefetch" href="/assets/js/67.74bf1c32.js"><link rel="prefetch" href="/assets/js/68.27c15e0b.js"><link rel="prefetch" href="/assets/js/69.5b78d6fb.js"><link rel="prefetch" href="/assets/js/7.a9e85c97.js"><link rel="prefetch" href="/assets/js/70.4772f9bd.js"><link rel="prefetch" href="/assets/js/71.2a2e89e4.js"><link rel="prefetch" href="/assets/js/72.3debedf0.js"><link rel="prefetch" href="/assets/js/73.c9ee93ce.js"><link rel="prefetch" href="/assets/js/74.7ec9495c.js"><link rel="prefetch" href="/assets/js/75.8c828ff5.js"><link rel="prefetch" href="/assets/js/76.986dc0d7.js"><link rel="prefetch" href="/assets/js/77.7e7e3c8e.js"><link rel="prefetch" href="/assets/js/78.200d9828.js"><link rel="prefetch" href="/assets/js/79.ee6b28e9.js"><link rel="prefetch" href="/assets/js/8.448002b9.js"><link rel="prefetch" href="/assets/js/80.93d03d67.js"><link rel="prefetch" href="/assets/js/81.eebcba15.js"><link rel="prefetch" href="/assets/js/82.3b0bb838.js"><link rel="prefetch" href="/assets/js/83.75234d18.js"><link rel="prefetch" href="/assets/js/84.1a897e55.js"><link rel="prefetch" href="/assets/js/85.8267b168.js"><link rel="prefetch" href="/assets/js/86.a7557c20.js"><link rel="prefetch" href="/assets/js/87.4f7e77b3.js"><link rel="prefetch" href="/assets/js/88.9b41f10e.js"><link rel="prefetch" href="/assets/js/89.662b9425.js"><link rel="prefetch" href="/assets/js/9.804860d0.js"><link rel="prefetch" href="/assets/js/90.6d84e2d8.js"><link rel="prefetch" href="/assets/js/91.650a7b6f.js"><link rel="prefetch" href="/assets/js/92.8568032c.js"><link rel="prefetch" href="/assets/js/93.0c300b40.js"><link rel="prefetch" href="/assets/js/94.f7ce23ff.js"><link rel="prefetch" href="/assets/js/95.e6c8272f.js"><link rel="prefetch" href="/assets/js/96.8f51c3ac.js"><link rel="prefetch" href="/assets/js/97.9cc683f5.js"><link rel="prefetch" href="/assets/js/98.6af1269f.js"><link rel="prefetch" href="/assets/js/99.97a09de8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8d0645b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="码农机器人" class="logo"> <span class="site-name can-hide">码农机器人</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>建立前端知识体系</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/handwritten/手写.html" class="sidebar-link">手写</a></li><li><a href="/note/knowledge/JS数据类型.html" class="sidebar-link">JS数据类型</a></li><li><a href="/note/knowledge/变量、作用域、内存问题.html" class="sidebar-link">变量、作用域、内存问题</a></li><li><a href="/note/knowledge/复杂数据类型.html" class="sidebar-link">复杂数据类型</a></li><li><a href="/note/knowledge/JS原型-原型链.html" class="sidebar-link">JS原型-原型链</a></li><li><a href="/note/knowledge/函数表达式.html" class="sidebar-link">函数表达式</a></li><li><a href="/note/knowledge/事件循环机制EventLoop.html" class="sidebar-link">事件循环机制EventLoop</a></li><li><a href="/note/knowledge/深拷贝、浅拷贝.html" class="sidebar-link">深拷贝、浅拷贝</a></li><li><a href="/note/knowledge/迭代器.html" class="sidebar-link">迭代器</a></li><li><a href="/note/knowledge/tcp.html" class="sidebar-link">TCP三次握手，四次挥手</a></li><li><a href="/note/knowledge/HTTPS和HTTP2.0.html" class="sidebar-link">HTTPS和HTTP2.0</a></li><li><a href="/note/knowledge/call,apply,bind,new的内部原理实现.html" class="sidebar-link">call,apply,bind,new的内部原理实现</a></li><li><a href="/note/knowledge/JavaScript工作原理.html" class="active sidebar-link">JavaScript工作原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#v8是怎么实现1-2-的-为什么1-tostring会报错" class="sidebar-link">V8是怎么实现1+'2'的，为什么1.toString会报错?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#什么是面向对象" class="sidebar-link">什么是面向对象?</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#javascript-对象的特征" class="sidebar-link">JavaScript 对象的特征</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#javascript-对象的两类属性" class="sidebar-link">JavaScript 对象的两类属性</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#类型系统" class="sidebar-link">类型系统</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#v8是怎么认为字符串和数字相加是有意义" class="sidebar-link">V8是怎么认为字符串和数字相加是有意义？</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#v8怎么实现对象继承" class="sidebar-link">V8怎么实现对象继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#_1-原型继承的概念" class="sidebar-link">1.原型继承的概念</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#_2-构造函数创建对象" class="sidebar-link">2.构造函数创建对象</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#_3-构造函数实现继承" class="sidebar-link">3.构造函数实现继承</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#_4-v8查找变量的方法" class="sidebar-link">4.V8查找变量的方法</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#_5-总结" class="sidebar-link">5.总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#原型和原型链" class="sidebar-link">原型和原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#原型链" class="sidebar-link">原型链</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#闭包会造成内存泄露吗-v8是如何实现闭-包的" class="sidebar-link">闭包会造成内存泄露吗？v8是如何实现闭 包的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#那么-v8-又是怎么执行-javascript-代码的呢" class="sidebar-link">那么 V8 又是怎么执行 JavaScript 代码的呢?</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#解释器的利弊" class="sidebar-link">解释器的利弊</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#编译器的利弊" class="sidebar-link">编译器的利弊</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#反优化" class="sidebar-link">反优化</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#惰性解析的过程" class="sidebar-link">惰性解析的过程</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#闭包给惰性解析带来的问题" class="sidebar-link">闭包给惰性解析带来的问题</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#预解析器如何解决了什么问题" class="sidebar-link">预解析器如何解决了什么问题？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#闭包会造成内存泄漏吗" class="sidebar-link">闭包会造成内存泄漏吗?</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#为什么会流传闭包造成内存泄漏这种说法" class="sidebar-link">为什么会流传闭包造成内存泄漏这种说法？</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#异步编程-v8是如何实现微任务的" class="sidebar-link">异步编程-v8是如何实现微任务的？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#为什么javascript是单线程" class="sidebar-link">为什么JavaScript是单线程？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#什么叫轮询" class="sidebar-link">什么叫轮询？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#宏任务特征" class="sidebar-link">宏任务特征：</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#微任务" class="sidebar-link">微任务</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#微任务特征" class="sidebar-link">微任务特征：</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#题目" class="sidebar-link">题目:</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#jquery-源码分析-数据缓存模块-data详解" class="sidebar-link">jQuery 源码分析 数据缓存模块 data详解</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#jquery-源码分析-队列模块-queue详解" class="sidebar-link">jQuery 源码分析 队列模块 Queue详解</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#jquery-源码分析-事件绑定" class="sidebar-link">jQuery 源码分析 事件绑定</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#事件模型" class="sidebar-link">事件模型</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#事件捕获-事件冒泡-事件委托" class="sidebar-link">事件捕获 &amp; 事件冒泡 &amp; 事件委托</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#事件捕获" class="sidebar-link">事件捕获</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#目标阶段" class="sidebar-link">目标阶段</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#事件冒泡" class="sidebar-link">事件冒泡</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#事件委托" class="sidebar-link">事件委托</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#阻止冒泡" class="sidebar-link">阻止冒泡</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#取消默认事件" class="sidebar-link">取消默认事件</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#jquery-事件-on-方法" class="sidebar-link">jQuery 事件 on() 方法</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#jquery事件处理机制解决了哪些问题" class="sidebar-link">jQuery事件处理机制解决了哪些问题?</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JavaScript工作原理.html#jquery事件原型设计" class="sidebar-link">jQuery事件原型设计</a></li></ul></li></ul></li><li><a href="/note/knowledge/元编程.html" class="sidebar-link">元编程</a></li><li><a href="/note/knowledge/JS基础.html" class="sidebar-link">JavaScript 基础</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue源码分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>提效赋能 前端工程化篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>程序员PLUS篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>忍者秘籍书</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript工作原理"><a href="#javascript工作原理" class="header-anchor">#</a> JavaScript工作原理</h1> <h2 id="v8是怎么实现1-2-的-为什么1-tostring会报错"><a href="#v8是怎么实现1-2-的-为什么1-tostring会报错" class="header-anchor">#</a> V8是怎么实现1+'2'的，为什么1.toString会报错?</h2> <p>大家在学JavaScript面向对象时，往往会有几个疑惑:</p> <ul><li>为什么JavaScript(直到ES6)有对象的概念，但是却没有像其他的语言那样，有类的概念呢；</li> <li>为什么在JavaScript对象里可以自由添加属性，而其他语言却不能呢</li></ul> <p>甚至，在一些争论中，有人强调:JavaScript并非&quot;面向对象的语言&quot;，而是&quot;基于对象的语言&quot;。究竟是面向对象还是基于对象这两派谁都说服不了谁</p> <p>实际上，基于对象和面向对象两个形容词都出现在JavaScript标准的各个版本中。我们先看看JavaScript标准对基于对象的定义，这个定义的具体内容是:&quot;语言和宿主的基础设施由对象提供，并且JavaScript程序即是一些列互通通讯的对象集合&quot;.</p> <p>这里的意思根本不是表达弱化的面向对象的意思，反而是表达对象对于语言的重要性。</p> <h3 id="什么是面向对象"><a href="#什么是面向对象" class="header-anchor">#</a> 什么是面向对象?</h3> <p>在《面向对象分析与设计》这本书中，作者替我们做了总结，他认为，从人类的认知角度来说，对象应该是下列事物之一:</p> <ul><li>一个可以触摸或者可以看见的东西；</li> <li>人的智力可以理解的东西；</li> <li>可以知道思考或行动(进行想象或施加动作)的东西。</li></ul> <p>有了对象的自然定义后，我们就可以描述编程语言中的对象了。在不同的编程语言中，设计者也可以利用各种不同的语言特性来抽象描述对象，最为成功的流派是使用&quot;类&quot;的方式来描述对象，这诞生了诸如C++，Java等流行的编程语言。而JavaScript早年却选择了一个更为冷门的方式:原型。</p> <p>JavaScript 推出之时受管理层之命被要求模仿 Java，所以，JavaScript 创始人 Brendan Eich 在 &quot;原型运行时&quot; 的基础上引入了 new、this 等语言特性，使之&quot;看起来更像 Java&quot;。 这也就造就了JavaScript这个古怪的语言。</p> <p>首先我们来了解一下 JavaScript 是如何设计对象模型的。</p> <h3 id="javascript-对象的特征"><a href="#javascript-对象的特征" class="header-anchor">#</a> JavaScript 对象的特征</h3> <p>对象有如下几个特点:</p> <ul><li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li> <li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li> <li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li></ul> <p>我们先来看第一个特征，对象具有唯一标识性。一般而言，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识。</p> <p>所以我们都应该知道，任何不同的 JavaScript 对象其实是互不相等的，我们可以看下面的代码，o1 和 o2 初看是两个一模一样的对象，但是打印出来的结果却是 false</p> <div class="language- extra-class"><pre class="language-text"><code>var o1 = { a: 1 }; 
var o2 = { a: 1 }; 
console.log(o1 == o2); // false
</code></pre></div><p>关于对象的第二个和第三个特征&quot;状态和行为&quot;，不同语言会使用不同的术语来抽象描述它们，比如 C++ 中称它们为&quot;成员变量&quot;和&quot;成员函数&quot;，Java 中则称它们为&quot;属性&quot;和&quot;方法&quot;。</p> <p>在 JavaScript 中，将状态和行为统一抽象为&quot;属性&quot;,这是因为考虑到 JavaScript 中将函数设计成一种特殊对象所以 JavaScript 中的行为和状态都能用属性来抽象。</p> <p>下面这段代码其实就展示了普通属性和函数作为属性的一个例子，其中 o 是对象，d 是一个属性，而函数 f 也是一个属性，尽管写法不太相同，但是对 JavaScript 来说，d 和 f 就是两个普通属性。</p> <div class="language- extra-class"><pre class="language-text"><code>var o = {        
    d: 1,        
    f() {            
    console.log(this.d);        
    }        
};
</code></pre></div><p>所以，总结一句话来看，在 JavaScript 中，对象的状态和行为其实都被抽象为了属性.</p> <h4 id="在实现了对象基本特征的基础上-我认为-javascript-中对象独有的特色是-对象具有高度的动态性-这是因为-javascript-赋予了使用者在运行时为对象添改状态和行为的能力。"><a href="#在实现了对象基本特征的基础上-我认为-javascript-中对象独有的特色是-对象具有高度的动态性-这是因为-javascript-赋予了使用者在运行时为对象添改状态和行为的能力。" class="header-anchor">#</a> 在实现了对象基本特征的基础上, 我认为，JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</h4> <p>比如，JavaScript 允许运行时向对象添加属性，这就跟绝大多数基于类的、静态的对象设计完全不同。如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。</p> <p>下面这段代码就展示了运行时如何向一个对象添加属性，一开始我定义了一个对象 o，定义完成之后，再添加它的属性 b，这样操作是完全没问题的。</p> <div class="language- extra-class"><pre class="language-text"><code>ar o = { a: 1 }; 
o.b = 2;
console.log(o.a, o.b); //1 2
</code></pre></div><p>为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了数据属性和访问器属性（getter/setter）两类</p> <h3 id="javascript-对象的两类属性"><a href="#javascript-对象的两类属性" class="header-anchor">#</a> JavaScript 对象的两类属性</h3> <h4 id="对-javascript-来说-属性并非只是简单的名称和值-javascript-用一组特征-attribute-来描述属性-property"><a href="#对-javascript-来说-属性并非只是简单的名称和值-javascript-用一组特征-attribute-来描述属性-property" class="header-anchor">#</a> 对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）</h4> <p>先来说第一类属性，数据属性。它比较接近于其它语言的属性概念。数据属性具有四个特征。</p> <ul><li>value：就是属性的值。</li> <li>writable：决定属性能否被赋值。</li> <li>enumerable：决定 for in 能否枚举该属性。</li> <li>configurable：决定该属性能否被删除或者改变特征值。</li></ul> <p>在大多数情况下，我们只关心数据属性的值即可。第二类属性是访问器（getter/setter）属性，它也有四个特征。</p> <ul><li>getter：函数或 undefined，在取属性值时被调用。</li> <li>setter：函数或 undefined，在设置属性值时被调用。</li></ul> <p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p> <p>讲到了这里，如果你理解了对象的特征，也就可以理解为什么会有 &quot;JavaScript 不是面向对象&quot; 这样的说法了。</p> <p>这是由于 JavaScript 的对象设计跟目前主流基于类的面向对象差异非常大。可事实上，这样的对象系统设计虽然特别，JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言。</p> <h3 id="类型系统"><a href="#类型系统" class="header-anchor">#</a> 类型系统</h3> <p>对机器语言来说，所有的数据都是一堆二进制代码，CPU 处理这些数据的时候，并没有类型的概念，CPU 所做的仅仅是移动数据，比如对其进行移位，相加或相乘。</p> <p>而在高级语言中，我们都会为操作的数据赋予指定的类型，类型可以确认一个值或者一组值具有特定的意义和目的。所以，类型是高级语言中的概念。
<img src="/knowledge/yq.png" alt="">
比如在C/C++中，你需要胃药处理的每条数据指定类型，这样定义变量:</p> <div class="language- extra-class"><pre class="language-text"><code>int count = 100;
char* name = &quot;贪吃的猫&quot;;
</code></pre></div><p>C/C++ 编译器负责将这些数据片段转换为供 CPU 处理的正确命令，通常是二进制的机器代码。</p> <p>在JavaScript中引擎可以根据数据自动推导出类型，因此就不需要直接指定变量的类型。</p> <div class="language- extra-class"><pre class="language-text"><code>var counter = 100;
const name = &quot;贪吃的猫&quot;;
</code></pre></div><p>通用的类型有数字类型、字符串、Boolean 类型等等，引入了这些类型之后，编译器或者解释器就可以根据类型来限制一些有害的或者没有意义的操作。</p> <p>比如在 Python 语言中，如果使用字符串和数字相加就会报错，因为 Python 觉得这是没有意义的。而在 JavaScript 中，字符串和数字相加是有意义的，可以使用字符串和数字进行相加的。</p> <h4 id="再比如-你让一个字符串和一个字符串相乘-这个操作是没有意义的-所有语言几乎都会禁止该操作"><a href="#再比如-你让一个字符串和一个字符串相乘-这个操作是没有意义的-所有语言几乎都会禁止该操作" class="header-anchor">#</a> 再比如，你让一个字符串和一个字符串相乘，这个操作是没有意义的，所有语言几乎都会禁止该操作</h4> <p>每种语言都定义了自己的类型，还定义了如何操作这些类型，另外还定义了这些类型应该如何相互作用，我们就把这称为类型系统</p> <h3 id="v8是怎么认为字符串和数字相加是有意义"><a href="#v8是怎么认为字符串和数字相加是有意义" class="header-anchor">#</a> V8是怎么认为字符串和数字相加是有意义？</h3> <p>接下来我们就可以来看看 V8 是怎么处理 1+&quot;2&quot;的了。 之前我们提到过它并不会报错而是输出字符串&quot;12&quot;.
当有两个值相加的时候，比如:</p> <div class="language- extra-class"><pre class="language-text"><code>a+b
</code></pre></div><p>V8 会严格根据 ECMAScript 规范来执行操作。ECMAScript 是一个语言标准，JavaScript 就是 ECMAScript 的一个实现，比如在 ECMAScript 就定义了怎么执行加法操作，如下所示：
<img src="/knowledge/ECMAScript.png" alt="">
通俗地理解:</p> <p>如果 Type(lprim) 和 Type(rprim) 中有一个是 String，则：</p> <p>a. 把 ToString(lprim) 的结果赋给左字符串 (lstr)；</p> <p>b. 把 ToString(rprim) 的结果赋给右字符串 (rstr)；</p> <p>c. 返回左字符串 (lstr) 和右字符串 (rstr) 拼接的字符串。</p> <p>如果是其他的(对象) V8 会提供了一个 ToPrimitive 方法，其作用是将 a 和 b 转换为原生数据类型，其转换流程如下：</p> <ul><li>先检测该对象中是否存在 valueOf 方法，如果有并返回了原始类型，那么就使用该值进行强制类型转换；</li> <li>如果 valueOf 没有返回原始类型，那么就使用 toString 方法的返回值；</li> <li>如果 vauleOf 和 toString 两个方法都不返回基本类型值，便会触发一个 TypeError 的错误
当 V8 执行 1+&quot;2&quot; 时，因为这是两个原始值相加，原始值相加的时候，如果其中一项是字符串，那么 V8 会默认将另外一个值也转换为字符串，相当于执行了下面的操作：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Number(1).toString() + &quot;2&quot;
</code></pre></div><h4 id="这个过程还有另外一个名词叫拆箱转换"><a href="#这个过程还有另外一个名词叫拆箱转换" class="header-anchor">#</a> 这个过程还有另外一个名词叫拆箱转换</h4> <h4 id="还有另外一个名词叫装箱转换"><a href="#还有另外一个名词叫装箱转换" class="header-anchor">#</a> 还有另外一个名词叫装箱转换</h4> <p>每一种基本类型 Number、String、Boolean在对象中都有对应的构造函数，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。</p> <div class="language- extra-class"><pre class="language-text"><code>1.toString();
</code></pre></div><h4 id="数字直接量"><a href="#数字直接量" class="header-anchor">#</a> 数字直接量</h4> <p>原因是JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。</p> <p>十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>.01
12.
12.01
</code></pre></div><p>这都是合法的数字直接量。这里就有一个问题，也是我们刚刚提出的问题，我们看一段代码：</p> <div class="language- extra-class"><pre class="language-text"><code>1.toString();
</code></pre></div><p>这时候1. 会被当作省略了小数点后面部分的数字，而单独看成一个整体，所以我们要想让点单独成为一个 token(语义单元)，就要加入空格，这样写：</p> <div class="language- extra-class"><pre class="language-text"><code>1 .toString();
(1).toString();
1..toString();
</code></pre></div><p>此时就不会报错了，但是为什么1能调用tostring方法呢？  1不是原始值吗？  这个过程就是经历了装箱转换，在遇到(1).toString() 根据基本类型 Number 这个构造函数转换成一个对象。</p> <h4 id="围绕拆箱-装箱-转换可以写出很多有意思的代码"><a href="#围绕拆箱-装箱-转换可以写出很多有意思的代码" class="header-anchor">#</a> 围绕拆箱 装箱 转换可以写出很多有意思的代码</h4> <p>1、{}+[]</p> <div class="language- extra-class"><pre class="language-text"><code>以{}开头的会被解析为语句块
此时+为一元操作符，非字符串拼接符
[]会隐式调用toString()方法，将[]转化为原始值 ''
+'' 被转化为数字0
扩展：如果将其用()括起来，即({}+[])，此时会显示&quot;[object Object]&quot;，因为此时{}不再被解析为语句块
</code></pre></div><p>2、[]+{}</p> <div class="language- extra-class"><pre class="language-text"><code>[]会隐式调用toString()方法，将[]转化为原始值 ''
{}会隐式调用toString()方法，将{}转化为原始值&quot;[object Object]&quot;
+为字符串拼接符
</code></pre></div><p>3、[]+[]</p> <div class="language- extra-class"><pre class="language-text"><code>[]会隐式调用toString()方法，将[]转化为原始值 ''
+为字符串拼接符NaN
</code></pre></div><p>4、{}+{}</p> <div class="language- extra-class"><pre class="language-text"><code>以{}开头的会被解析为语句块，即第一个{}为语句块  (某些浏览器会这样导致Na'N)
此时+为一元操作符，非字符串拼接符
第二个{}会隐式调用toString()方法，将{}转化为原始值&quot;[object Object]&quot;
+&quot;[object Object][object Object]&quot;  ||  NaN
</code></pre></div><h4 id="前几年比较恶心的面试题。"><a href="#前几年比较恶心的面试题。" class="header-anchor">#</a> 前几年比较恶心的面试题。</h4> <p>([][[]]+[])[+!![]]+([]+{})[!+[]+!![]]</p> <div class="language- extra-class"><pre class="language-text"><code>左
([][[]]+[])[+!![]]
拆分
[+!![]]

!![]=&gt;true  +true =&gt; 1  
=&gt;[+!![]]=[1]

拆分
([][[]]+[])
[][[]]=&gt;[][false]=&gt;[][0]=&gt;undefined
undefined+[]=&gt;undefined
([][[]]+[])=&gt;[][0]=&gt;undefined
左边得:([][[]]+[])[+!![]]=&gt;undefined[1]=&gt;'n';

右
([]+{})[!+[]+!![]]
拆分
[!+[]+!![]]
!![]=&gt;true
+[]=&gt;0
!0=&gt;1
[1+1]=&gt;[2]

([]+{})=&gt;&quot;[object Object]&quot;

([]+{})[!+[]+!![]]=&gt;&quot;[object Object]&quot;[2]=&gt;'b'


所以:([][[]]+[])[+!![]]+([]+{})[!+[]+!![]]=&gt;&quot;nb&quot;

</code></pre></div><h2 id="v8怎么实现对象继承"><a href="#v8怎么实现对象继承" class="header-anchor">#</a> V8怎么实现对象继承</h2> <p>继承就是一个对象可以访问另一个对象中得属性和方法。最经典得继承方式有基于类得设计和基于原型继承得设计。js仅仅在对象中引入一个原型的属性来实现继承。</p> <h3 id="_1-原型继承的概念"><a href="#_1-原型继承的概念" class="header-anchor">#</a> 1.原型继承的概念</h3> <p>JS的对象都包含一个隐藏属性__proto__,这个隐藏属性称为该对象的原型prototype，__proto__在内存中指向的对象为该对象的原型对象，访问该对象就能直接访问其原型对象的属性和方法。JS查找属性时优先从自身对象查找，如果查找不到，就回去原型上查找，查找的路径成为原型链。</p> <p>作用域链和原型链的实现方式类似:</p> <ul><li>作用域链是沿着函数的作用域一级一级来查找变量</li> <li>原型链是沿着对象的原型一级一级查找属性的</li></ul> <h4 id="继承就是一个对象可用访问另外一个对象中的属性和方法-在js中-通过原型和原型链来实现继承"><a href="#继承就是一个对象可用访问另外一个对象中的属性和方法-在js中-通过原型和原型链来实现继承" class="header-anchor">#</a> 继承就是一个对象可用访问另外一个对象中的属性和方法，在js中，通过原型和原型链来实现继承</h4> <h3 id="_2-构造函数创建对象"><a href="#_2-构造函数创建对象" class="header-anchor">#</a> 2.构造函数创建对象</h3> <div class="language- extra-class"><pre class="language-text"><code>function Person(name, age){
    this.name = name;
    this.age = age;
};
let male = new Person('male', 20);
</code></pre></div><p>首先创建一个构造函数，然后使用new关键字实例化。当通过new关键字实例化工厂函数时，JS虚拟机会返回一个对象，针对new操作V8模拟代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>let male = new Person('male', 20);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let male = {};
male.__proto__ = Person.prototype;
Person.call(male, 'male', 20);
</code></pre></div><ul><li>第一步：创建空对象male</li> <li>第二步：给male设置原型对象Person.prototype</li> <li>第三步：调用Person方法，Person中的this指向新创建的对象male，给this赋值</li></ul> <h3 id="_3-构造函数实现继承"><a href="#_3-构造函数实现继承" class="header-anchor">#</a> 3.构造函数实现继承</h3> <p>函数的隐藏属性包括：name, code, prototype....</p> <p>当使用构造函数来创建一个新的对象时，新对象的原型对象就指向了该函数的prototype属性。当创建多个对象时，这些对象的原型就指向了同一个，也就是该函数的prototype属性。所以修改该构造函数的prototype属性，就实现了继承。</p> <h3 id="_4-v8查找变量的方法"><a href="#_4-v8查找变量的方法" class="header-anchor">#</a> 4.V8查找变量的方法</h3> <p>V8查找变量是基于作用域链查找的。作用域链就是将一个个作用域串起来，实现变量查找的路径。全局函数有全局作用域，每个函数有自己的作用域。全局作用域在V8启动过程中就创建了，且一直保存在内存中不会被销毁，直至V8退出。函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就会被销毁。</p> <h4 id="作用域链工作机制"><a href="#作用域链工作机制" class="header-anchor">#</a> 作用域链工作机制</h4> <ul><li>V8启动时，首先创建全局作用域，全局作用域中包括this, window等变量和接口。</li> <li>V8启动后，消息循环系统开始工作，优先解析顶层代码，在解析过程中将顶层定义的变量和声明的函数都添加到全局作用域中。</li> <li>全局作用域创建完成后，V8进入执行状态。继续创建函数作用域。</li> <li>作用域链创建完成后，查找作用域的顺序是按照函数定义时的位置来决定的，而不是函数执行时的顺序。因为这个顺序是在声明函数就确定好了，所以也称为静态作用域，词法作用域。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var type = 'global'
function bar() {
    var type = 'function'
    function foo() {
        console.log(type)
    }
    foo()
}
    
bar()

// 作用域链查找 foo =&gt; bar =&gt; global
// function
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>var type = 'global'
function bar() {
    var type = 'function'
    foo()
}
function foo() {
    console.log(type)
}
    
bar()

// 作用域链查找 foo =&gt; global
// global
</code></pre></div><h3 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> 5.总结</h3> <ul><li>当使用构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的prototype属性，使用prototype实- 现原型链的继承。</li> <li>作用域是存放变量和函数的地方。当在某个函数中使用某个变量时，V8会去这些作用域中查找相关变量，查找的路径就是作用域链。</li> <li>作用域链的路径是按照词法作用域来实现的，也就是函数定义时的位置来决定。</li></ul> <h2 id="原型和原型链"><a href="#原型和原型链" class="header-anchor">#</a> 原型和原型链</h2> <p>图解:
<img src="/knowledge/xyl.png" alt=""></p> <h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <p>Javascript中有一句话，叫一切皆是对象，当然这句话也不严谨，比如null和undefined就不是对象，除了这俩完全可以说Javascript一切皆是对象。而Javascript对象都有一个叫做原型的公共属性，属性名是_proto_。这个原型属性是对另一个对象的引用，通过这个原型属性我们就可以访问另一个对象所有的属性和方法。比如：</p> <div class="language- extra-class"><pre class="language-text"><code>let numArray = [1, 2, -8, 3, -4, 7];
</code></pre></div><p>Array对象就有一个原型属性指向Array.prototype,变量numArray继承了Array.prototype对象所有的属性和方法</p> <p><img src="/knowledge/arr.png" alt=""></p> <p>这就是为什么可以直接调用像sort()这种方法:</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(numArray.sort()); // -&gt; [-4, -8, 1, 2, 3, 7]
</code></pre></div><p>也就是说：</p> <div class="language- extra-class"><pre class="language-text"><code>numArray.__proto__ === Array.prototype // true
</code></pre></div><p>对于其他对象(函数)也是一样(比如Date(),Function(), String(),Number()等)；</p> <p>当一个构造函数被创建后，实例对象会继承构造函数的原型属性，这是构造函数的一个非常重要的特性。在Javascript中使用new关键字来对构造函数进行实例化。看下面的例子：</p> <div class="language- extra-class"><pre class="language-text"><code>const Car = function(color, model, dateManufactured) {
  this.color = color;
  this.model = model;
  this.dateManufactured = dateManufactured;
};
Car.prototype.getColor = function() {
    return this.color;
};
Car.prototype.getModel = function() {
    return this.model;
};
Car.prototype.carDate = function() {
    return `This ${this.model} was manufactured in the year ${this.dateManufactured}`
}
let firstCar = new Car('red', 'Ferrari', '1985');
console.log(firstCar);
console.log(firstCar.carDate());
</code></pre></div><p><img src="/knowledge/car_proto.png" alt=""></p> <p>上面的例子中，方法getColor,carDate,getModel都是对象(函数)Car的方法，而Car的实例对象firstCar可以继承Car原型上的一切方法和属性。</p> <p>结论：每一个实例对象都有一个私有属性_proto_,指向它的构造函数的原型对象(prototype)。</p> <h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <p>在Javascript中如果访问一个对象本身不存在的属性或是方法，就首先在它的原型对象上去寻找，如果原型对象上也不存在，就继续在原型对象的原型对象上去寻找，直到找到为止。那么原型对象有尽头么？所有对象的原型尽头是Object.prototype,那么Object.prototype这个对象的_proto_指向啥呢？答案是null。我们日常开发中用到的绝大多数对象的_proto_基本不会直接指向Object.prototype,基本都是指向另一个对象。比如所有的函数的_proto_都会指向Function.prototype,所有数组的_proto_都会指向Array.prototype</p> <div class="language- extra-class"><pre class="language-text"><code>let protoRabbit = {
  color: 'grey',
  speak(line) {
        console.log(`The ${this.type} rabbit says ${line}`);
  }
};
let killerRabbit = Object.create(protoRabbit);
killerRabbit.type = &quot;assassin&quot;;
killerRabbit.speak(&quot;SKREEEE!&quot;);
</code></pre></div><p>上面代码中变量protoRabbit设置为所有兔子对象的公有属性对象集，killerRabbit这只兔子通过Object.create方法继承了protoRabbit的所有属性和方法，然后给killerRabbit赋值了一个type属性，再看下面的代码</p> <div class="language- extra-class"><pre class="language-text"><code>let mainObject = {
    bar: 2
};
// create an object linked to `anotherObject`
let myObject = Object.create( mainObject );
for (let k in myObject) {
  console.log(&quot;found: &quot; + k);
}
// found: bar
(&quot;bar&quot; in myObject);
</code></pre></div><p>如上变量myObject本身并没有bar属性，但这里会循着原型链一层一层往上找，直到找到或者原型链结束为止。如果到原型链尽头还是没找到该属性，那么访问该属性的时候就会返回undefined了。</p> <p>使用for...in关键字对对象进行迭代的过程，和上面访问某个属性循着原型链查找类似,会去遍历所有原型链上的属性(不论属性是否可枚举)。</p> <div class="language- extra-class"><pre class="language-text"><code>let protoRabbit = {
  color: 'grey',
  speak(line) {
      console.log(`The ${this.type} rabbit says ${line}`);
  }
};
let killerRabbit = Object.create(protoRabbit);
killerRabbit.type = &quot;assassin&quot;;
killerRabbit.speak(&quot;SKREEEE!&quot;);
</code></pre></div><p>上面的代码中访问speak的效率很高，但如果我们想创建很多个Rabbit对象，就必须要重复写很多代码。而这正是原型和构造函数的真正用武之地。</p> <div class="language- extra-class"><pre class="language-text"><code>let protoRabbit = function(color, word, type) {
  this.color = color;
  this.word = word;
  this.type = type;
};
protoRabbit.prototype.getColor = function() {
    return this.color;
}
protoRabbit.prototype.speak = function() {
    console.log(`The ${this.type} rabbit says ${this.word}`);
}
let killerRabbit = new protoRabbit('grey', 'SKREEEEE!', 'assassin');
killerRabbit.speak();
</code></pre></div><p>如上代码，使用构造函数的方式就可以节省很多的代码。</p> <p>结论：每一个实例对象都有一个私有属性_proto_,指向它的构造函数的原型对象(prototype)。原型对象也有自己的_proto_，层层向上直到一个对象的原型对象为null。这一层层原型就是原型链。</p> <p>总结:</p> <ul><li>所有的引用类型(数组，函数，对象)，都具有对象特征，即可自由扩展属性(null除外)</li> <li>所有得引用类型(数组，函数，对象)，都有一个__proto__属性，属性值是一个普通得对象</li> <li>所有得函数，都有一个prototype属性，属性值也是一个普通得对象</li> <li>所有得引用类型(数组，函数，对象)，__proto__属性值指向他的构造函数得prototype属性值</li></ul> <p>题目1:</p> <div class="language- extra-class"><pre class="language-text"><code>var A = function() {};
A.prototype.n = 1;
var b = new A();
A.prototype = {
  n: 2,
  m: 3
}
var c = new A();

console.log(b.n);
console.log(b.m);

console.log(c.n);
console.log(c.m);
</code></pre></div><p>题目2：</p> <div class="language- extra-class"><pre class="language-text"><code>function Person() {};

Object.prototype.a = 'a';

Function.prototype.b = 'b';

var f = new Person();

console.log(f.a);
console.log(f.b);

console.log(Person.a);
console.log(Person.b);
</code></pre></div><p>题目3：</p> <div class="language- extra-class"><pre class="language-text"><code>var foo = {},
    F = function(){};
Object.prototype.a = 'value a';
Function.prototype.b = 'value b';

console.log(foo.a);
console.log(foo.b);

console.log(F.a);
console.log(F.b);
</code></pre></div><p>记住:</p> <div class="language- extra-class"><pre class="language-text"><code>Function.prototype === Function.__proto__

Function.prototype.__proto__ === Object.prototype

Object.prototype.__proto__ === null

Function.prototype === Object.__proto__
</code></pre></div><p>练习1:</p> <div class="language- extra-class"><pre class="language-text"><code>function Foo() {
    getName = function () {
        console.log(1)
    };
    return this;
}
Foo.getName = function () {
    console.log(2)
};
Foo.prototype.getName = function () {
    console.log(3)
};
var getName = function () {
    console.log(4)
};
function getName() {
    console.log(5)
}

//请写出以下输出结果：
Foo.getName();//此时调用得是Foo函数上的getName方法
getName();//调用的是全局getName方法
Foo().getName();//Foo()单独执行所以,作用域中的this绑定为window,相当于window.getName()。同上,执行的都是全局getName 方法,但是Foo执行时,内部执行了
getName();//全局getName已经被覆盖
new Foo.getName();//考察了运算符的优先级。 . 的优先级高于 new, 相当于执行 new (Foo.getName)()， 相当于执行 getName 的构造函
new Foo().getName();//(new Foo()).getName() 先生成 Foo 对象, 再执行 getName() 函数。 在 new Foo() 返回的是新创建的空对象，由于对象这时还没绑定属性 getName, 所以这时调用的是原型上的 getName
new new Foo().getName();//可以改写为 new ((new Foo()).getName)() 先初始化实例，然后将原型对象上的 getName() 作为构造函数执行
</code></pre></div><p>练习2:</p> <div class="language- extra-class"><pre class="language-text"><code>Object.prototype.a = 'a';
Function.prototype.a = 'a1';
function Person() {}
var roy = new Person();
console.log(Person.a);
console.log(roy.a);
console.log(
  roy.__proto__.__proto__.constructor.constructor.constructor.constructor
);
</code></pre></div><h2 id="闭包会造成内存泄露吗-v8是如何实现闭-包的"><a href="#闭包会造成内存泄露吗-v8是如何实现闭-包的" class="header-anchor">#</a> 闭包会造成内存泄露吗？v8是如何实现闭 包的</h2> <p>上面我们讲到了，浏览器作为 V8 的宿主环境提供了在执行JavaScript代码时所需的运行环境，这个环境包括了堆空间和栈空间、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，还有消息循环系统</p> <div class="language- extra-class"><pre class="language-text"><code>V8 是一个由 Google 开发的开源 JavaScript 引擎，目前用在 Chrome 浏览器
和 Node.js 中，其核心功能是执行易于人类理解的 JavaScript 代码。
</code></pre></div><p><img src="/knowledge/1.png" alt=""></p> <p>准备好运行时环境之后，V8 才可以执行 JavaScript 代码，这包括解析源码、生成字节码、解释执行或者编译执行这一系列操作</p> <h3 id="那么-v8-又是怎么执行-javascript-代码的呢"><a href="#那么-v8-又是怎么执行-javascript-代码的呢" class="header-anchor">#</a> 那么 V8 又是怎么执行 JavaScript 代码的呢?</h3> <p>处理器不能直接识别由高级语言所编写的代码通常，有两种方式来执行这些代码。第一种是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。具体流程如下图所示：</p> <p><img src="/knowledge/2.jpg" alt=""></p> <p>第二种是编译执行。采用这种方式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。</p> <p><img src="/knowledge/3.jpg" alt=""></p> <p>这两种翻译的方式都各有利弊。</p> <h3 id="解释器的利弊"><a href="#解释器的利弊" class="header-anchor">#</a> 解释器的利弊</h3> <p>解释器启动和执行的更快。你不需要等待整个编译过程完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行了。</p> <p>正是因为这个原因，解释器看起来更加适合 JavaScript。对于一个 Web 开发人员来讲，能够快速执行代码并看到结果是非常重要的。</p> <p>这就是为什么最开始的浏览器都是用 JavaScript 解释器的原因。</p> <p>可是当你运行同样的代码一次以上的时候，解释器的弊处就显现出来了。比如你执行一个循环，那解释器就不得不一次又一次的进行翻译，这是一种效率低下的表现。</p> <h3 id="编译器的利弊"><a href="#编译器的利弊" class="header-anchor">#</a> 编译器的利弊</h3> <p>编译器的问题则恰好相反。</p> <p>它需要花一些时间对整个源代码进行编译，然后生成目标文件才能在机器上执行。对于有循环的代码执行的很快，因为它不需要重复的去翻译每一次循环。</p> <p>另外一个不同是，编译器可以用更多的时间对代码进行优化，以使的代码执行的更快。而解释器是在 runtime 时进行这一步骤的，这就决定了它不可能在翻译的时候用很多时间进行优化。</p> <p>V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为 JIT（Just In Time）技术。</p> <p>这是一种权衡策略，因为这两种方法都各自有各自的优缺点，解释执行的启动速度快，但是执行时的速度慢，而编译执行的启动速度慢，但是执行时的速度快。你可以参考下面完整的 V8 执行 JavaScript 的流程图：</p> <p><img src="/knowledge/4.jpg" alt=""></p> <p>我们先看上图中的最左边的部分，在 V8 启动执行 JavaScript 之前，它还需要准备执行 JavaScript 时所需要的一些基础环境，这些基础环境包括了&quot;堆空间&quot; &quot;栈空间&quot; &quot;全局执行上下文&quot; &quot;全局作用域&quot; &quot;消息循环系统&quot; &quot;内置函数&quot; 等，这些内容都是在执行 JavaScript 过程中需要使用到的。基础环境准备好之后，接下来就可以向 V8 提交要执行的 JavaScript 代码了。</p> <p>首先 V8 会接收到要执行的 JavaScript 源代码，不过这对 V8 来说只是一堆字符串，V8 并不能直接理解这段字符串的含义，它需要结构化这段字符串。</p> <div class="language- extra-class"><pre class="language-text"><code>结构化，是指信息经过分析后可分解成多个互相关联的组成部分，各组成部分间有
明确的层次结构，方便使用和维护，并有一定的操作规范。
</code></pre></div><p>V8 源代码的结构化之后，就生成了抽象语法树 (AST)，我们称为 AST，AST 是便于 V8 理解的结构, 在生成 AST 的同时，V8 还会生成相关的作用域，作用域中存放相关变量。</p> <p>有了 AST 和作用域之后，接下来就可以生成字节码了，字节码是介于 AST 和机器代码的中间代码。解释器按照顺序解释执行字节码，并输出执行结果。</p> <p>接下来看图上的机器人，其实是一个监视器（也叫分析器）。监视器监控着代码的运行情况，记录代码一共运行了多少次、如何运行的等信息。如果同一行代码运行了几次，这个代码段就被标记成了  &quot;warm&quot;，如果运行了很多次，则被标记成 &quot;hot&quot;。</p> <p><img src="/knowledge/5.png" alt=""></p> <p>如果一段代码变成了 &quot;warm&quot;，那么 JIT 就把它送到编译器去编译，并且把编译结果存储起来。</p> <p><img src="/knowledge/6.png" alt=""></p> <p>代码段的每一行都会被编译成一个 stub code ，同时给这个stub分配一个以&quot;行号 + 变量类型&quot;的索引。如果监视器监视到了执行同样的代码和同样的变量类型，那么就直接把这个已编译的版本 push 出来</p> <h3 id="反优化"><a href="#反优化" class="header-anchor">#</a> 反优化</h3> <p>如果一个代码段变得 &quot;very hot&quot;，监视器会把它发送到优化编译器中。V8 就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。如果下面再执行到这段代码时，那么 V8 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。</p> <p><img src="/knowledge/7.png" alt=""></p> <p>不过，和静态语言不同的是，JavaScript 是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行，并且把优化代码丢掉</p> <p><img src="/knowledge/8.png" alt=""></p> <p>这一过程叫做去优化.</p> <h3 id="惰性解析的过程"><a href="#惰性解析的过程" class="header-anchor">#</a> 惰性解析的过程</h3> <p>值得注意的是：在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码。</p> <p>其主要有两个方面的原因：</p> <ul><li>如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度增加用户的等待时间；</li> <li>解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存资源。</li></ul> <p>基于以上的原因，所有主流的 JavaScript 虚拟机都实现了惰性解析。所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码。</p> <p>关于惰性解析，我们可以结合下面这个例子来分析下：</p> <div class="language- extra-class"><pre class="language-text"><code>function foo(a,b) {
  var d = 100;
  var f = 10;
  return a+b+d+f;
}
</code></pre></div><p>当把这段代码交给 V8 处理时，V8 会至上而下解析这段代码，在解析过程中首先会遇到 foo 函数，由于这只是一个函数声明语句，V8 在这个阶段只需要将该函数转换为函数对象，如下图所示：</p> <p><img src="/knowledge/9.jpg" alt=""></p> <p>注意，这里只是将该函数声明转换为函数对象，但是并没有解析和编译函数内部的代码，所以也不会为 foo 函数的内部代码生成抽象语法树。</p> <p>上去是不是很简单，不过在 V8 实现惰性解析的过程中，需要支持 JavaScript 中的闭包特性，这会使得 V8 的解析过程变得异常复杂。</p> <h3 id="闭包给惰性解析带来的问题"><a href="#闭包给惰性解析带来的问题" class="header-anchor">#</a> 闭包给惰性解析带来的问题</h3> <p>我们来了解下 JavaScript 函数特征你就知道了。</p> <p>第一，JavaScript 语言允许在函数内部定义新的函数，代码如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>function fun(){
  function wait(){
  }
}
</code></pre></div><p>这和其他的流行语言有点差异，在其他的大部分语言中，函数只能声明在顶层代码中，而 JavaScript 中之所以可以在函数中声明另外一个函数，主要是因为 JavaScript 中的函数即对象，你可以在函数中声明一个变量，当然你也可以在函数中声明一个函数。</p> <p>第二，可以在内部函数中访问父函数中定义的变量，代码如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>function fun(){
  var a = 1;
  function wait(){
    return a+1;
  }
}
</code></pre></div><p>可以在函数中定义新的函数，所以很自然的，内部的函数可以使用外部函数中定义的变量，注意上面代码中的 wait 函数和 fun 函数，wait 是在 fun 函数内部定义的，我们就称 wait 函数是 fun 函数的子函数，fun函数是 wait 函数的父函数。</p> <p>这里的父子关系是针对词法作用域而言的，因为词法作用域在函数声明时就决定了。词法作用域是根据函数在代码中的位置来确定的，作用域是在声明函数时就确定好的了，所以我们也将词法作用域称为静态作用域。</p> <p>每个函数有自己的词法作用域，该函数中定义的变量都存在于该作用域中，然后 V8 会将这些作用域按照词法的位置，也就是代码位置关系，将这些作用域串成一个链，这就是词法作用域链，查找变量的时候会沿着词法作用域链的途径来查找。</p> <p>第三，因为函数是一等公民，所以函数可以作为返回值，我们可以看下面这段代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function fun(){
  var a = 1;
  return function wait(){
    return a+1;
  }
}
var ref = fun();
</code></pre></div><p>调用 fun 函数返回值（函数）给了全局变量 ref，接下来就可以在外部像调用 fun 函数一样调用ref了。</p> <p>这也是 JavaScript 过于灵活的一个原因，比如在 C/C++ 中，你就不可以在一个函数中定义另外一个函数，所以也就没了内部函数访问外部函数中变量的问题了。</p> <p>了解了 JavaScript 的这三个特性之后，下面我们就来使用这三个特性组装的一段经典的闭包代码：</p> <div class="language- extra-class"><pre class="language-text"><code>function fun(){
  var a = 1;
  return function wait(){
    return a+1;
  }
}
var ref = fun();
</code></pre></div><p>观察上面上面这段代码，我们在 fun  函数中定义了 wait 函数，并返回 wait 函数，同时在 wait 函数中访问了 foo 函数中的变量 a。</p> <p>我们可以分析下上面这段代码的执行过程：</p> <ul><li>当调用 fun 函数时，fun 函数会将它的内部函数 wait 返回给全局变量 ref；</li> <li>然后 fun 函数执行结束，执行上下文被 V8 销毁；</li> <li>虽然 fun 函数的执行上下文被销毁了，但是依然存活的 wait 函数引用了 fun 函数作用域中的变量 a。</li></ul> <p>按照通用的做法，a 已经被 v8 销毁了，但是由于存活的函数 wait 依然引用了 fun 函数中的变量 a，这样就会带来两个问题：</p> <ul><li>当 fun 执行结束时，变量 a 该不该被销毁？如果不应该被销毁，那么应该采用什么策略?</li> <li>如果采用了惰性解析，那么当执行到 fun 函数时，V8 只会解析 fun 函数，并不会解析内部的 wait 函数，那么这时候 V8 就不知道 wait 函数中是否引用了 fun函数的变量 a。</li></ul> <p>我们知道JavaScript 是一门基于堆和栈的语言，接下就模拟上面这段代码的执行流程观测堆栈的变化。
如下图所示：</p> <p><img src="/knowledge/10.png" alt=""></p> <p>从上图可以看出来，在执行全局代码时，V8 会将全局执行上下文压入到调用栈中，然后进入执行 fun 函数的调用过程，这时候 V8 会为 fun 函数创建执行上下文，执行上下文中包括了变量 a，然后将 fun 函数的执行上下文压入栈中，fun 函数执行结束之后，fun 函数执行上下文从栈中弹出，这时候 fun 执行上下文中的变量 a 也随之被销毁。</p> <p>但是这时候，由于 wait 函数被保存到全局变量中了，所以 wait 函数依然存在，最关键的地方在于 wait 函数使用了 fun 函数中的变量 a，按照正常执行流程，变量 a 在 fun 函数执行结束之后就被销毁了。</p> <p>所以正常的处理方式应该是 fun 函数的执行上下文虽然被销毁了，但是 wait 函数引用的 fun 函数中的变量却不能被销毁，那么 V8 就需要为这种情况做特殊处理，需要保证即便 fun 函数执行结束，但是 fun 函数中的 a 变量依然保持在内a存中，不能随着 fun 函数的执行上下文被销毁掉。</p> <p>那么怎么处理呢？在执行 fun 函数的阶段，虽然采取了惰性解析，不会解析和执行 fun 函数中的 wait 函数，但是 V8 还是需要判断 wait 函数是否引用了 fun 函数中的变量，负责处理这个任务的模块叫做预解析器。</p> <h3 id="预解析器如何解决了什么问题"><a href="#预解析器如何解决了什么问题" class="header-anchor">#</a> 预解析器如何解决了什么问题？</h3> <p>V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析，其主要目的有两个。</p> <ul><li>一，是判断当前函数是不是存在一些语法上的错误。</li> <li>二，除了检查语法错误之外，预解析器另外的一个重要的功能就是检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用。</li></ul> <p>由于 JavaScript 是一门天生支持闭包的语言，由于闭包会引用当前函数作用域之外的变量，所以当 V8 解析一个函数的时候，还需要判断该函数的内部函数是否引用了当前函数内部声明的变量，如果引用了，那么需要将该变量存放到堆中，下次执行到该函数的时候，直接使用堆中的引用</p> <h3 id="闭包会造成内存泄漏吗"><a href="#闭包会造成内存泄漏吗" class="header-anchor">#</a> 闭包会造成内存泄漏吗?</h3> <p>答案是不会：内存泄漏本质是不在需要的内存依然没有被释放。 如果下次有人问你什么是闭包？
你可以这么回复他:&quot;闭包是绑定了执行环境的函数&quot;。</p> <p>执行环境的组成部分：</p> <ul><li>词法环境
词法环境就是指查找作用域的顺序是按照函数定义时的位置来决定的。即函数中查找变量，其查找顺序都是按照当前函数作用域  =&gt; 全局作用域这个路径来的。</li> <li>变量环境<br>
在ES6前声明变量都是通过var关键词声明的，在ES6中则提倡使用let和const来声明变量，为了兼容var的写法,于是使用变量环境来存储var声明的变量。
变量环境本质上仍是词法环境，但它只存储var声明的变量，这样在初始化变量时可以赋值undefined。</li> <li>this</li></ul> <h3 id="为什么会流传闭包造成内存泄漏这种说法"><a href="#为什么会流传闭包造成内存泄漏这种说法" class="header-anchor">#</a> 为什么会流传闭包造成内存泄漏这种说法？</h3> <p>在低版本的IE浏览器中，由于BOM和DOM中的对象是使用C++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。</p> <p>扩展：</p> <p>当内存不再需要使用时释放，在这里最艰难的任务是找到哪些被分配的内存确实已经不再需要了。</p> <p>怎么确定不在需要？明确的说垃圾回收器是无法判断的。但是早期做法依赖了&quot;引用&quot;的概念来判断。
把  &quot;内存是否不再需要&quot; 转化为 &quot;对象是否不再需要&quot; 在简化定义为&quot;对象有没有其他地方引用到它&quot;。如果没有引用指向该对象(零引用) 对象将被垃圾回收机制回收，这就是引用计数。</p> <p>这也是IE浏览器早期的垃圾回收机制，但是有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题，这也是流传闭包会导致内存泄露的主要原因。</p> <div class="language- extra-class"><pre class="language-text"><code>function fun(){
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o
}

fun();
</code></pre></div><p>o, o2两个对象被创建，并互相引用，形成了一个循环。引用计数都为1，当调用 fun 执行完毕 v8销毁执行上下文但是o、o2 这两个它们不会被回收。</p> <p>改进：</p> <p>所有现代浏览器都使用了标记-清除垃圾回收算法，算法假定设置一个叫做根Root的对象。</p> <p>垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。如上述代码函数调用返回之后，两个对象从全局对象出发无法获取因此，他们将会被垃圾回收器回收。</p> <h4 id="最后强调-闭包不会造成内存泄漏-程序写错了才会造成内存泄漏。"><a href="#最后强调-闭包不会造成内存泄漏-程序写错了才会造成内存泄漏。" class="header-anchor">#</a> 最后强调：闭包不会造成内存泄漏，程序写错了才会造成内存泄漏。</h4> <h2 id="异步编程-v8是如何实现微任务的"><a href="#异步编程-v8是如何实现微任务的" class="header-anchor">#</a> 异步编程-v8是如何实现微任务的？</h2> <h3 id="为什么javascript是单线程"><a href="#为什么javascript是单线程" class="header-anchor">#</a> 为什么JavaScript是单线程？</h3> <p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样不是能提高执行效率吗？</p> <p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p> <p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p> <div class="language- extra-class"><pre class="language-text"><code>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个
线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变
JavaScript单线程的本质。
</code></pre></div><p>单线程中有一种机制：在每次调用JavaScript引擎时，可以随着时间的推移执行你的程序的代码块儿，有些代码块是立即执行，有些代码块是稍后执行，这也称为&quot;事件轮询 (Event Loop)&quot;。</p> <div class="language- extra-class"><pre class="language-text"><code>其实就是想告诉大家 JavaScript 引擎对时间是没有感知的，JavaScript代
码的执行是 按需执行环境所安排
</code></pre></div><h3 id="什么叫轮询"><a href="#什么叫轮询" class="header-anchor">#</a> 什么叫轮询？</h3> <p>JavaScript引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。</p> <p>当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。</p> <p>如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为 &quot; 事件循环（Event Loop)&quot; 的原因。</p> <p>这么说你肯定会有些不太理解，不要紧我们从最简单的代码，来分析主线程和调用栈。</p> <div class="language- extra-class"><pre class="language-text"><code>function wait(){
 //code
}
wait();

function foo(){
 //code
}
foo();
</code></pre></div><p>当 V8 准备执行这段代码时，会先将全局执行上下文压入到调用栈中，如下图所示：</p> <p><img src="/knowledge/11.png" alt=""></p> <p>然后 V8 便开始在主线程上执行 wait 函数，首先它会创建 wait 函数的执行上下文，并将其压入栈中，那么此时执行栈、主线程的关系如下图所示：</p> <p><img src="/knowledge/12.png" alt=""></p> <p>等 wait 函数执行结束，V8 就会从栈中弹出 wait 函数的执行上下文，此时的效果如下所示：</p> <p><img src="/knowledge/13.png" alt=""></p> <p>foo函数的执行以此类推。等 foo 函数执行结束，V8 就会结束当前的宏任务，调用栈也会被清空，调用栈被清空后状态如下图所示：</p> <p><img src="/knowledge/14.png" alt=""></p> <p>不管如何请记住这句话：第一个宏任务队列中只有一个任务：执行主线程上的JavaScript代码；</p> <div class="language- extra-class"><pre class="language-text"><code>function wait(){
 //code
}
wait();

function foo(){
 //code
}
setTimeout(foo,,100);
</code></pre></div><p>在浏览器中会把I/O、setTimeout、setInterval、requestAnimationFrame 操作分类成宏任务。</p> <p>在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。</p> <h4 id="微任务、宏任务都为异步任务。"><a href="#微任务、宏任务都为异步任务。" class="header-anchor">#</a> 微任务、宏任务都为异步任务。</h4> <p>并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调函数到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。</p> <h4 id="一旦是执行栈中所有的同步任务执行完毕-系统就会读取任务队列。"><a href="#一旦是执行栈中所有的同步任务执行完毕-系统就会读取任务队列。" class="header-anchor">#</a> 一旦是执行栈中所有的同步任务执行完毕，系统就会读取任务队列。</h4> <p>我们只需记住当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。 在当前的微任务没有执行完成时，是不会执行下一个宏任务的。</p> <h4 id="宏任务执行完毕后callback放入任务队列。"><a href="#宏任务执行完毕后callback放入任务队列。" class="header-anchor">#</a> 宏任务执行完毕后callback放入任务队列。</h4> <p>刚刚的代码我们需要分成两张图来理解：</p> <p>图1</p> <p><img src="/knowledge/15.png" alt=""></p> <p>图2</p> <p><img src="/knowledge/16.png" alt=""></p> <h3 id="宏任务特征"><a href="#宏任务特征" class="header-anchor">#</a> 宏任务特征：</h3> <ul><li>宏任务所处的队列就是宏任务队列 第一个宏任务队列中只有一个任务：执行主线程上的JS代码。</li> <li>如果遇到I/O、setTimeout、setInterval、requestAnimationFrame异步任务，会创建出一个新的宏任务队列，存放这些异步函数执行完成后的回调函数。</li> <li>宏任务队列可以有多个。</li> <li>宏任务中可以创建微任务，但是在宏任务中创建的微任务不会影响当前宏任务的执行。</li> <li>当一个宏任务队列中的任务全部执行完后，会查看是否有微任务队列，如果有就会优先执行微任务队列中的所有任务，如果没有就查看是否有宏任务队列。</li></ul> <h3 id="微任务"><a href="#微任务" class="header-anchor">#</a> 微任务</h3> <p>在浏览器中微任务有Promise.then.catch finally、MutationObserver。</p> <p>为什么要设计微任务呢？</p> <p>通过刚刚的学习我们知道宏任务需要先被放到消息队列中，如果某些宏任务的执行时间过久，那么就会影响到消息队列后面的宏任务的执行，而且这个影响是不可控的，因为你无法知道前面的宏任务需要多久才能执行完成。所以宏任务无法胜任一些对精度和实时性要求较高的场景，而微任务可以在实时性和效率之间做有效的权衡。</p> <p>于是 JavaScript 中又引入了微任务，微任务会在当前的任务快要执行结束时执行，利用微任务，你就能比较精准地控制你的回调函数的执行时机。</p> <h4 id="微任务其实是一个需要异步执行的函数-执行时机是在主函数执行结束之后、当前宏任务结束之前。"><a href="#微任务其实是一个需要异步执行的函数-执行时机是在主函数执行结束之后、当前宏任务结束之前。" class="header-anchor">#</a> 微任务其实是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</h4> <h3 id="微任务特征"><a href="#微任务特征" class="header-anchor">#</a> 微任务特征：</h3> <ul><li>微任务所处的队列就是微任务队列。</li> <li>在上一个宏任务队列执行完毕后，如果有微任务队列就会执行微任务队列中的所有任务。</li> <li>微任务队列上创建的微任务，仍会阻碍后方将要执行的宏任务队列 。</li> <li>由微任务创建的宏任务，会被丢在异步宏任务队列中执行。</li></ul> <h3 id="题目"><a href="#题目" class="header-anchor">#</a> 题目:</h3> <div class="language- extra-class"><pre class="language-text"><code>setTimeout(() =&gt; {
    console.log('timeOut');
}, 0);

const promise = new Promise((resolve,reject)=&gt;{
    console.log('start');
    resolve('2222');
    console.log('end');
})

promise.then(res=&gt;{
    console.log(res);
    
})
//结果: 同步-(start,end),微任务-2222,宏任务-timeOut
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>setTimeout(()=&gt;{
    console.log('timeout1');
    Promise.resolve().then(res=&gt;{
        console.log('promise1');
    });
},0)
Promise.resolve().then(res=&gt;{
    console.log('promise2');
    setTimeout(()=&gt;{
        console.log('timeout2');
    },0)
});
//结果:promise2,timeout1,promise1,timeout2
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>async function async1(){
    console.log('async1 start');
    //等价下面
    await async2();
    console.log('async1 end');
    // new Promise((resolve,reject)=&gt;{
    //     console.log('async2');
    //     resolve()
    // }).then(res=&gt;{
    //     console.log('async1 end');
    // })
}

async function async2(){
    console.log('async2');
}

async1();
console.log('script');
//结果:async1 start,async2,script,async1 end
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>async function async1(){
    console.log('async1 start');
    await new Promise(resolve=&gt;{
        console.log('Promise');
        // resolve();
    })
    console.log('async1 success');
    return 'async1 end'
}
console.log('script start');
setTimeout(()=&gt;{
    console.log('setTimeout');
},0)
async1().then(res=&gt;{console.log(res);})
console.log('script end');
//结果:script start,async1 start ,Promise,script end,setTimeout
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>async function async1(){
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2(){
    console.log('async2');
}

console.log('script start');
setTimeout(()=&gt;{
    console.log('setTimeout');
},0)
async1();
new Promise(function(resolve){
    console.log('Promise1');
    resolve();
}).then((result) =&gt; {
    console.log('Promise2');
}).then((result) =&gt; {
    console.log('Promise3');
}).then((result) =&gt; {
    console.log('Promise4');
})
console.log('script end');
//结果:script start,async1 start,async2,Promise1,script end,async1 end,Promise2,Promise3,Promise4,setTimeout
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>async function async1(){
    console.log('async1 start');
    return new Promise(resolve=&gt;{
        resolve(async2());
        //包裹一个promise
    }).then(res=&gt;{
        console.log('async1 end');
    });
}
 function async2(){
    console.log('async2');
}
// async function async2(){
//     console.log('async2');
//     //自己是一个promise 加入async后async2会在Promise3后面打印
// }
setTimeout(()=&gt;{
    console.log('setTimeout');
},0)
async1();
new Promise(function(resolve){
    console.log('Promise1');
    resolve();
}).then((result) =&gt; {
    console.log('Promise2');
}).then((result) =&gt; {
    console.log('Promise3');
}).then((result) =&gt; {
    console.log('Promise4');
})
//async1 start,async2,Promise1,async1 end,Promise2,Promise3,Promise4,setTimeout
</code></pre></div><h2 id="jquery-源码分析-数据缓存模块-data详解"><a href="#jquery-源码分析-数据缓存模块-data详解" class="header-anchor">#</a> jQuery 源码分析 数据缓存模块 data详解</h2> <p>jQurey得数据缓存模块以一种安全得方式为DOM元素附加任意类型得数据，避免了在JavaScript对象和DOM元素之间出现循环引用，以及由此而导致的内存泄漏。</p> <p>数据缓存模块为DOM原生和JavaScript对象提供了统一得数据设置，读取和移除方法，在jQuery内部还为队列模块，动画模块，样式模块，时间系统提供基础功能，负责维护这些模块运行时得内部数据。</p> <p>对于DOM元素和JavaScript对象，数据的存储位置是不同的，如下:</p> <ul><li>对于DOM元素jQuery直接把数据存储在jQuery.cache中</li> <li>对于JavaScript对象，垃圾回收机制能够自动发生，因此数据可以直接存储在JavaScript对象中。</li></ul> <p>另外为了避免jQuery内部使用的数据和用户自定义的数据发生冲突，分为内部数据缓存对象和自定义数据缓存对象:</p> <ul><li>内部缓存对象   　　 ;jQuery内部使用        ;DOM元素:存储在$.cache[elem[$.expando]]                 ;JavaScript对象:obj[$.expando]</li> <li>自定义缓存对象    　;给用户使用的            ;DOM元素:存储在$.cache[elem[$.expando]].data        ;JavaScript对象:obj[$.expando].data</li></ul> <p>总体结构:</p> <div class="language- extra-class"><pre class="language-text"><code>// 数据缓存 Data
jQuery.extend({
     // DOM元素的数据缓存对象,所有DOM元素存储的数据都会存储在该对象里
     cache: {},
     // 唯一id种子，初始值为0,当数据存储在DOM元素上时用到，元素的$.expando属性的值等于最新的$.uuid加1
     uuid:0,
     // 页面中每个jQuery副本的唯一标识，只有刷新页面才会发生变化。格式:jQuery+版本号+随机数
     expando: &quot;jQuery&quot; + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, &quot;&quot; ),
     // 判断elem是否有关联的数据
     hasData: function(){},
     // 设置或返回DOM或JavaScript对象的数据。
     //elem是DOM元素或JavaScript对象。
     //·name是要设置或读取的数据名，也可以是包含键值对的对象。
     //·data是要设置的数据值，可以是任意数据。
     //·pvt表示操作的是否为内部数据，默认为false
     data: function(elem, name, data, pvt) {},
     // 移除通过$.data()设置的数据,pvt表示是否为内部数据
     removeData: function(elem, name, pvt) {},
     // 设置、读取内部数据，内部代码就一句return jQuery.data( elem, name, data, true )
     _data: function(elem, name, data) {},
     // 判断DOM元素elem是否可以设置数据，elem是一个DOM节点
     acceptData: function(elem){}
});
jQuery.fn.extend({
     // 设置、读取自定义数据，解析HTML5属性data-
     data: function(key,value){},
     // 移除匹配元素的自定义数据，key可以是一个字符换或数组，表示属性或属性列表
     removeData: function(key){}
});
// 解析HTML5属性 data-functiondataAttr(elem,key,data){}
// 检查数据缓存对象是否为空functionisEmptyDataObject(obj){}
jQuery.extend({
// 清空数据缓存对象
//移除多个DOM元素的全部数据和事件
cleanData: function(elems){}
});
</code></pre></div><p>为DOM元素存储数据时，比较特别，jQuery首先会在该DOM上添加一个名为$.expando的属性，值是一个唯一的id,等于++$.uuid(jQuery的一个内置属性)，$.uuid是一个整型值,初始值为0。为该DOM添加属性之后还会把这个id作为属性添加到全局缓存对象jQuery.cache中，对应的属性值是一个JavaScript对象，该对象是DOM元素的数据缓存对象</p> <p>例如:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;http://libs.baidu.com/jquery/1.7.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;123&lt;/p&gt;
    &lt;script&gt;
        var p = document.getElementsByTagName('p')[0];
        $.data(p,'age',25,true);                                //设置内部数据age=25，这是直接定义在数据缓存对象上的。等价于$._data(p,'age',25);
        $.data(p,'age',23);                                     //设置自定义数据age=23，等价于$.data(p,'age',23,false)，这是定义在数据缓存对象的data属性对象上
        console.log($.data(p,undefined,undefined,true));        //输出: Object { data={ age=23},  age=25}    ;获取数据缓存对象。    
        console.log($.data(p));                                 //输出: Object { age=23}             ;获取自定义缓存对象,其实就是$.data(p,undefined,undefined,true)对象的data属性
        console.log($.cache[p[$.expando]].data === $.data(p));  //输出true，从这里可以看出$.data(p)获取的就是自定义缓存对象，也就是数据缓存对象的data属性对象
    &lt;/script&gt;    
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>输出如下:</p> <p><img src="/knowledge/jqdata1.jpg" alt=""></p> <p>对于数据缓存模块的静态方法来说，它是以jQuery.extend({})函数直接挂载到jQuery里的，如下:</p> <div class="language- extra-class"><pre class="language-text"><code>jQuery.extend({
  cache: {},                                //DOM元素的数据缓存对象

  // Please use with caution
  uuid: 0,

  // Unique for each copy of jQuery on the page
  // Non-digits removed to match rinlinejQuery
  expando: &quot;jQuery&quot; + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, &quot;&quot; ),    //页面中每个jQuery副本的唯一标识

  // The following elements throw uncatchable exceptions if you
  // attempt to add expando properties to them.
  noData: {                                   //存放了不支持扩展属性的embed、object、applet元素的节点名称
    &quot;embed&quot;: true,
    // Ban all objects except for Flash (which handle expandos)
    &quot;object&quot;: &quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;,
    &quot;applet&quot;: true
  },

  hasData: function( elem ) {                 //判断一个DOM元素或JavaScript对象是否有与之关联的数据
    elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];     //如果是元素节点(有nodeType属性)则判断在jQuery.cache中是否有jQuery.expando属性，否则认为是JavaScript对象，判断是否有jQuery.expando属性。
    return !!elem &amp;&amp; !isEmptyDataObject( elem );                                              //如果elem存在且含有数据缓存则返回true,isEmptyDataObject是个jQuery内部的工具函数
  },

  data: function( elem, name, data, pvt /* Internal Use Only */ ) {
    /*略*/
  },

  removeData: function( elem, name, pvt /* Internal Use Only */ ) {
    /*略*/
  },

  // For internal use only.
  _data: function( elem, name, data ) {       //设置、读取内部数据，就是调用jQuery.data()，并设置第四个参数为true
    return jQuery.data( elem, name, data, true );
  },

  // A method for determining if a DOM node can handle the data expando
  acceptData: function( elem ) {              //判断参数elem是否可以设置数据，返回true则可以设置，返回false则不可以
    if ( elem.nodeName ) {
      var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

      if ( match ) {
        return !(match === true || elem.getAttribute(&quot;classid&quot;) !== match);
      }
    }

    return true;
  }
});
</code></pre></div><p>我们主要看一下$.data()是怎么设置数据的，懂了怎么设置数据，removeData也就懂了，如下:</p> <div class="language- extra-class"><pre class="language-text"><code>data: function( elem, name, data, pvt /* Internal Use Only */ ) {       //设置、读取自定义数据、内部数据
  if ( !jQuery.acceptData( elem ) ) {               //检查elem元素是否支持设置数据，如果jQuery.acceptData()函数返回false表示不允许设置数据
    return;                                           //则直接返回，不继续操作
  }

  var privateCache, thisCache, ret,                 //privateCache默认指向数据缓存对象(如果pvt参数未设置或者为false则指向自定义数据),thisCache表示自定义数据缓存对象,如果pvt是true,则privateCache和thisCache都指向数据缓存对象都指向数据缓存对象。ret是读取时的返回值
    internalKey = jQuery.expando,                   //jQuery.expando页面中每个jQuery副本的唯一标识，把它赋值给internalKey是为了减少拼写字数和缩短作用域链查找。
    getByName = typeof name === &quot;string&quot;,           //getByName表示name是否为字符串

    // We have to handle DOM nodes and JS objects differently because IE6-7
    // can't GC object references properly across the DOM-JS boundary
    isNode = elem.nodeType,                         //isNode表示elem是否为DOM元素

    // Only DOM nodes need the global jQuery cache; JS object data is
    // attached directly to the object so GC can occur automatically
    cache = isNode ? jQuery.cache : elem,           //如果是DOM元素则存储在$.cache中，如果是JavaScript对象则存储在该对象本身 

    // Only defining an ID for JS objects if its cache already exists allows
    // the code to shortcut on the same path as a DOM node with no cache
    id = isNode ? elem[ internalKey ] : elem[ internalKey ] &amp;&amp; internalKey,
    isEvents = name === &quot;events&quot;;

  // Avoid doing any more work than we need to when trying to get data on an
  // object that has no data at all
  if ( (!id || !cache[id] || (!isEvents &amp;&amp; !pvt &amp;&amp; !cache[id].data)) &amp;&amp; getByName &amp;&amp; data === undefined ) {   //如果是读取数据但没有数据，则返回，避免做不必要的工作,if语句中的符合表达式可以分两个部分，后一部分是getByName &amp;&amp; data === undefined，表示，如果name是字符串且data没有设置，则说明是在读数据。 前一部分(!id || !cache[id] || (!isEvents &amp;&amp; !pvt &amp;&amp; !cache[id].data)表示，如果id不存在说明没有该属性，如果cache[id]不存在则说明没有该数据
    return;
  }
  /*执行到这里有两种情况:1.存储数据 2.读取数据且数据存在*/   
  if ( !id ) {                                      //如果id不存在，则分配一个
    // Only DOM nodes need a new unique ID for each element since their data
    // ends up in the global cache
    if ( isNode ) {                                   //如果是DOM元素
      elem[ internalKey ] = id = ++jQuery.uuid;         //jQuery.uuid会自动加1，并附在DOM元素上
    } else {
      id = internalKey;                               //否则关联ID就是jQuery.expando
    }
  }

  if ( !cache[ id ] ) {                           //如果DOM对象或JavaScript对象对应的数据缓存对象不存在则初始化为一个空对象
    cache[ id ] = {};

    // Avoids exposing jQuery metadata on plain JS objects when the object
    // is serialized using JSON.stringify
    if ( !isNode ) {
      cache[ id ].toJSON = jQuery.noop;
    }
  }

  // An object can be passed to jQuery.data instead of a key/value pair; this gets
  // shallow copied over onto the existing cache
  if ( typeof name === &quot;object&quot; || typeof name === &quot;function&quot; ) { //如果name是对象或者函数(函数好像不可以，只能是对象)，则批量把参数name中的属性合并到已有的数据缓存对象上，即批量设置数据
    if ( pvt ) {
      cache[ id ] = jQuery.extend( cache[ id ], name );
    } else {
      cache[ id ].data = jQuery.extend( cache[ id ].data, name );
    }
  }

  privateCache = thisCache = cache[ id ];                         //设置privateCache和thisCache都指向数据缓存对象cache[ id ]

  // jQuery data() is stored in a separate object inside the object's internal data
  // cache in order to avoid key collisions between internal data and user-defined
  // data.
  if ( !pvt ) {                                                   //如果参数pvt是false或者未设置，则设置thisCache指向自定义数据，
    if ( !thisCache.data ) {                                        //如果数据缓存对象thisCache.data不存在则先将其初始化为空对象。
      thisCache.data = {};
    }

    thisCache = thisCache.data;
  }

  if ( data !== undefined ) {                                     //如果data不是undefined，则把参数data设置到属性name上，这里统一把参数name转换成了驼峰式，这样在读取的时候不管是连字符串还是驼峰式就都不会出错。
    thisCache[ jQuery.camelCase( name ) ] = data;
  }

  // Users should not attempt to inspect the internal events object using jQuery.data,
  // it is undocumented and subject to change. But does anyone listen? No.
  if ( isEvents &amp;&amp; !thisCache[ name ] ) {
    return privateCache.events;
  }

  // Check for both converted-to-camel and non-converted data property names
  // If a data property was specified
  if ( getByName ) {                                            //如果参数name是字符串，则读取单个数据

    // First Try to find as-is property data
    ret = thisCache[ name ];                                      //先尝试读取参数name对应的数据

    // Test for null|undefined property data  
    if ( ret == null ) {                                          //如果没有读取到则把参数name转换为驼峰式再次尝试读取

      // Try to find the camelCased property
      ret = thisCache[ jQuery.camelCase( name ) ];
    }
  } else {
    ret = thisCache;                                          //如果参数2不是字符串,则返回数据缓存对象。
  }

  return ret;                                                 //最后返回ret
},
</code></pre></div><p>这样就完成数据的设置的，对于jQuery实例上的方法如下:</p> <div class="language- extra-class"><pre class="language-text"><code>jQuery.fn.extend({
  data: function( key, value ) {      //设置、读取自定义数据，解析html5属性data- key是要设置或读取的数据名，或者是含有键值对的对象，value是要设置的数据值，可以是任意类型
    var parts, attr, name,
      data = null;

    if ( typeof key === &quot;undefined&quot; ) {       //如果未传入参数，即参数格式是.data()，则获取第一个匹配元素关联的数据缓存对象(即获得全部数据)
      if ( this.length ) {                      //如果该jQuery对象有匹配的元素
        data = jQuery.data( this[0] );            //获取第一个元素的数据缓存对象

        if ( this[0].nodeType === 1 &amp;&amp; !jQuery._data( this[0], &quot;parsedAttrs&quot; ) ) {    //这里是解析html5里的data-属性的，可以先略过
          attr = this[0].attributes;
          for ( var i = 0, l = attr.length; i &lt; l; i++ ) {
            name = attr[i].name;

            if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
              name = jQuery.camelCase( name.substring(5) );

              dataAttr( this[0], name, data[ name ] );
            }
          }
          jQuery._data( this[0], &quot;parsedAttrs&quot;, true );   //返回第一个匹配元素关联的自定义数据缓存对象。如果没有匹配元素则会返回null
        }
      }

      return data;

    } else if ( typeof key === &quot;object&quot; ) {         //如果key是一个对象，则为每个元素对象调用方法$.data(this,key)批量设置数据
      return this.each(function() {
        jQuery.data( this, key );
      });
    }

    parts = key.split(&quot;.&quot;);
    parts[1] = parts[1] ? &quot;.&quot; + parts[1] : &quot;&quot;;      //取出命名空间，比如$(this).data('a.b',123);则parts[1]是.b

    if ( value === undefined ) {                    //如果传入的格式是.data(key),则认为是读取单个数据
      data = this.triggerHandler(&quot;getData&quot; + parts[1] + &quot;!&quot;, [parts[0]]);     //触发自定义事件getData,并把事件监听函数的返回值赋值给变量data

      // Try to fetch any internally stored data first
      if ( data === undefined &amp;&amp; this.length ) {          //如果事件监听函数没有返回值，才会尝试从自定义数据缓存对象中读取
        data = jQuery.data( this[0], key );
        data = dataAttr( this[0], key, data );
      }

      return data === undefined &amp;&amp; parts[1] ?             //如果从getData()事件监听函数或自定义数据缓存对象或HTML5属性data-中取到了数据，则返回数据;如果没有取到数据，但是指定了命名空间，则去掉命名空间再次尝试读取。
        this.data( parts[0] ) :
        data;

    } else {                                          //如果传入了参数key和value,即参数格式是:.data(key,value)，则为每个匹配元素设置任意类型的数据，并触发自定义事件setData()和changeData()。
      return this.each(function() {
        var self = jQuery( this ),
          args = [ parts[0], value ];

        self.triggerHandler( &quot;setData&quot; + parts[1] + &quot;!&quot;, args );        //触发自定义事件setData,感叹号表示只执行没有命名控件的事件监听函数
        jQuery.data( this, key, value );                                //调用$.data()方法为任意匹配元素设置任意类型的数据
        self.triggerHandler( &quot;changeData&quot; + parts[1] + &quot;!&quot;, args );     //触发自定义事件changeData
      });
    }
  },
  /*...*/
})
</code></pre></div><p>设置数据缓存就是这样的，理解了设置数据缓存，移除就很好理解了。</p> <h2 id="jquery-源码分析-队列模块-queue详解"><a href="#jquery-源码分析-队列模块-queue详解" class="header-anchor">#</a> jQuery 源码分析 队列模块 Queue详解</h2> <p>队列是常用得数据结构之一，只允许在表得前端(对头)进行删除操作(出队),在表得后端(队尾)进行插入操作(入队)。特点是先进先出，最先插入得元素最先被是删除。</p> <p>在jQuery内部，队列模块为动画模块提供基础功能，负责储存动画函数，自动出队并执行动画函数，同时还要确保动画函数得顺序执行。</p> <p>jQuery的静态方法含有如下API:</p> <ul><li>$.queue(elem,type,data)　;返回或修改匹配元素关联的队列,返回最新的队列，参数如下:</li></ul> <p>elem 　　;DOM元素或JavaScript对象</p> <p>type 　　;队列名称，默认是标准动画fx</p> <p>data　　;需要设置的队列函数，可以是空(返回队列)、函数(加入队列)或函数数组(替换队列)</p> <ul><li>$.dequeue(elem,type) 　　;用于出队并执行匹配元素关联的函数队列中的下一个元素</li></ul> <p>elem　　;DOM元素或JavaScript对象</p> <p>type　　;是队列名称，默认为动画队列fx</p> <p>jQuery/$ 实例方法(可以通过jQuery实例调用的):</p> <ul><li>queue(type,data)  　　    ;</li></ul> <p>返回第一个匹配元素的函数队列，或修改所有匹配的元素关联的函数队列，参数如下:</p> <ul><li><p>type　　;队列名称</p></li> <li><p>data　　;data是可选的函数或函数数组，参数同$.queue()的第三个参数</p></li> <li><p>dequeue(type)　　　　   ;出队并执行所有匹配元素关联的函数队列中的下一个函数</p></li> <li><p>clearQueue(type)        　 ;移除匹配元素关联的函数队列中的所有未被执行的函数，内部代码就一句:return this.queue( type || &quot;fx&quot;, [] );</p></li></ul> <p>举个例子:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;http://libs.baidu.com/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;123&lt;/p&gt;
    &lt;script&gt;
        function f1(){console.log('f1触发');}　　　 //定义两个测试函数
        function f2(){console.log('f2触发')};

        $('p').queue('test',f1);               　　//将f1入队，队列名称为test
        $('p').dequeue('test');            　　　　//将匹配元素的名称为test的函数列表出队并执行
        $('p').queue(f2);            　　　　　　　 //将f2放入p匹配元素的队列中，默认为动画队列，会自动执行。
    &lt;/script&gt;    
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>结果:</p> <div class="language- extra-class"><pre class="language-text"><code>f1触发
f2触发
</code></pre></div><p>jQuery的队列是基于数据缓存模块$.data来实现的，当调用$.queue()时回把函数列表以队列名+'queue'为属性，保存在对应的DOM元素的内部缓存对象上，例如:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src=&quot;http://libs.baidu.com/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;123&lt;/p&gt;
    &lt;script&gt;
        function f1(){console.log('f1触发');}
        $('p').queue('test',f1);    
    &lt;/script&gt;    
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>我们可以在控制台里直接从$.cache里获取对应的属性，如下:</p> <p><img src="/knowledge/queue1.png" alt=""></p> <p>document.getElementsByTagName('p')[0][$.expando]就是例子里p元素节点对象的$.expando属性，该属性的值会作为$.cache的某个属性，存储着对应这个p元素的数据缓存对象(这是数据缓存模块的内容)</p> <p>$.queue和$.dequeue的实现如下:</p> <div class="language- extra-class"><pre class="language-text"><code>//队列
jQuery.extend( {
	//返回或修改匹配元素关联的队列,返回最新的队列
	//elem：DOM元素或JavaScript对象 
	//type:队列名称，默认是标准动画fx 
	//data需要设置的队列函数，可以是空(返回队列)、函数(加入队列)或函数数组(替换队列)
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;//修正参数type,默认为动画队列fx,在参数type后面加上queue表示这是一个队列
			queue = dataPriv.get( elem, type );//取出参数type对应的队列 如果之前有数据则返回该数组 否则 queue等于undefined

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {//data存在时
				if ( !queue || Array.isArray( data ) ) {//判断队列不存在或者data是否是一个数组
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );//调用jQuery.makeArray把参数data转换为数组并替换队列
				} else {
					queue.push( data );//队列存在且data不是一个数组则调用数组push方法把参数data放入队列
				}
			}
			return queue || [];
		}
	},
	//用于出队并执行匹配元素关联的函数队列中的下一个元素
	dequeue: function( elem, type ) {
		type = type || &quot;fx&quot;;//修正参数type,默认是&quot;fx&quot;;

		var queue = jQuery.queue( elem, type ),//获取elem元素的type队列
			startLength = queue.length,
			fn = queue.shift(), //调用shift方法取出队列第一个函数
			hooks = jQuery._queueHooks( elem, type ),//存放出队的函数在执行时的数据
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		//如果出队的是占位符&quot;inprogress&quot;，则丢弃再从队列头部出一个，只有动画队列会设置占位符&quot;inprogress&quot;
		if ( fn === &quot;inprogress&quot; ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === &quot;fx&quot; ) {//如果是动画队列
				queue.unshift( &quot;inprogress&quot; );//则在队列开头添加一个占位符&quot;inprogress&quot;，表示动画函数正在执行当中
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			//调用函数方法call执行出队的函数，elem是函数执行的上下文，
			//即关键词this指向的对象;第二个参数是封装了jQuery.dequeue( elem, type )的函数，
			//不会自动执行，需要在出队的函数返回前手动调用next()
			fn.call( elem, next, hooks );
		}
		//如果参数type对应的队列在出队后成为空队列，即所有函数都已经出队并执行
		if ( !startLength &amp;&amp; hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + &quot;queueHooks&quot;;
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( &quot;once memory&quot; ).add( function() {
				dataPriv.remove( elem, [ type + &quot;queue&quot;, key ] );
			} )
		} );
	}
} );
</code></pre></div><p>type默认等于fx，jQuery的动画效果也是基于Queue实现的，这个fx默认就是动画效果，对于jQuery/$ 实例方法来说，它是调用jQuery的静态方法来实现的，如下:</p> <div class="language- extra-class"><pre class="language-text"><code>
jQuery.fn.extend( {
	//返回第一个匹配元素的函数队列，或修改所有匹配的元素关联的函数队列。
	//type是队列名称，默认是fx。data参数等同于jQuery.queue中的data参数
	queue: function( type, data ) {
		var setter = 2;
		 //修正参数    当传入的格式是queue()或queue(data) (注:data可以是函数或函数数组)时
		if ( typeof type !== &quot;string&quot; ) {
			data = type;
			type = &quot;fx&quot;;
			setter--;
		}

		if ( arguments.length &lt; setter ) {
			return jQuery.queue( this[ 0 ], type );
		}
		
		return data === undefined ?
			this :
			 //如果传入了data参数
			this.each( function() {
				 //为每一个匹配元素调用jQuery.queue( this, type, data ),
				 //把参数(函数)入队，或者用参数data(函数数组)替换队列。
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );
				 //对于动画队列fx，且没有动画函数正在执行,则立即出队并执行动画函数。
				if ( type === &quot;fx&quot; &amp;&amp; queue[ 0 ] !== &quot;inprogress&quot; ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	// //出队并执行匹配元素关联的函数队列中的下一个函数
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	//移除匹配元素关联的函数队列中的所有未被执行的函数，内部代码就一句:return this.queue( type || &quot;fx&quot;, [] );
	clearQueue: function( type ) {
		return this.queue( type || &quot;fx&quot;, [] );
	},
} );
</code></pre></div><h2 id="jquery-源码分析-事件绑定"><a href="#jquery-源码分析-事件绑定" class="header-anchor">#</a> jQuery 源码分析 事件绑定</h2> <p>事件(Event)是JavaScript应用跳动的心脏，通过使用JavaScript ，你可以监听特定事件的发生，并规定让某些事件发生以对这些事件做出响应。</p> <h3 id="事件模型"><a href="#事件模型" class="header-anchor">#</a> 事件模型</h3> <h4 id="dom0级-事件模型"><a href="#dom0级-事件模型" class="header-anchor">#</a> DOM0级 事件模型</h4> <p>通过JavaScript指定事件处理程序的传统方式。就是将一个函数赋值给一个事件处理程序属性。</p> <h4 id="dom2-级事件模型"><a href="#dom2-级事件模型" class="header-anchor">#</a> DOM2 级事件模型</h4> <p>DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作，addEventListener(event, function, useCapture)和removeEventListener(event, function, useCapture)，所有的DOM节点中都包含这两个方法，它们都接收3个参数。</p> <ul><li>事件名称</li> <li>事件处理程序的函数</li> <li>布尔值，true代表在捕获阶段调用事件处理程序，false表示在冒泡阶段调用事件处理程序，默认为false。</li></ul> <h3 id="事件捕获-事件冒泡-事件委托"><a href="#事件捕获-事件冒泡-事件委托" class="header-anchor">#</a> 事件捕获 &amp; 事件冒泡 &amp; 事件委托</h3> <p>事件冒泡和事件捕获分别由网景公式和微软公司提出，DOM2级事件规定的事件流包含3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获为截获事件提供机会，然后是实际的目标接收事件，最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。</p> <p><img src="/knowledge/event.png" alt=""></p> <p>注：事件委托是利用冒泡阶段的运行机制来实现的。</p> <p><img src="/knowledge/4723.png" alt=""></p> <h3 id="事件捕获"><a href="#事件捕获" class="header-anchor">#</a> 事件捕获</h3> <p>事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这个路径回溯到文档跟节点。</p> <h3 id="目标阶段"><a href="#目标阶段" class="header-anchor">#</a> 目标阶段</h3> <p>当事件到达目标节点的，事件就进入了目标阶段。事件在目标节点上被触发，然后会逆向回流，直到传播至最外层的文档节点。</p> <h3 id="事件冒泡"><a href="#事件冒泡" class="header-anchor">#</a> 事件冒泡</h3> <p>事件在目标元素上触发后，并不在这个元素上终止。它会随着DOM树一层层向上冒泡，回溯到根节点。</p> <p>冒泡过程非常有用。它将我们从对特定元素的事件监听中释放出来，如果没有事件冒泡，我们需要监听很多不同的元素来确保捕获到想要的事件。</p> <h3 id="事件委托"><a href="#事件委托" class="header-anchor">#</a> 事件委托</h3> <p>在传统的事件处理中，你按照需要为每一个元素添加或者是删除事件处理器。但是，如果页面上有几个百元素需要绑定（假设）。此时问题就显现出来了。大量的事件绑定，性能消耗，而且还需要解绑（IE会泄漏）、后期生成HTML会没有事件绑定，需要重新绑定、语法过于繁杂。JavaScript事件委托可以把事件处理器添加到一个父元素上，这样就避免了把事件处理器添加到多个子元素上。</p> <h4 id="事件委托它是怎么运作的呢"><a href="#事件委托它是怎么运作的呢" class="header-anchor">#</a> 事件委托它是怎么运作的呢？</h4> <p>事件代理用到了两个JavaSciprt事件特性：事件冒泡以及目标元素。当一个元素上的事件被触发的时候，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；使用事件代理，我们可以把事件处理器添加到一个元素上，等待一个事件从它的子级元素里冒泡上来，并且可以得知这个事件是从哪个元素开始的。</p> <h3 id="阻止冒泡"><a href="#阻止冒泡" class="header-anchor">#</a> 阻止冒泡</h3> <p><code>e.stopPropagation() stopPropagation是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是不会阻止默认行为。</code></p> <h4 id="为什么要阻止事件冒泡"><a href="#为什么要阻止事件冒泡" class="header-anchor">#</a> 为什么要阻止事件冒泡？</h4> <p>有种可能是，某个DOM节点绑定了某事件监听器，本来是想当该DOM节点触发事件，才会执行回调函数。结果是该节点的某后代节点触发某事件，由于事件冒泡，该DOM节点事件也会触发，执行了回调函数，这样就违背了最初的本意了。</p> <p>这里需要注意的是，我们无法在事件捕获阶段阻止事件冒泡，因为捕获是从根节点向目标节点触发，而冒泡是从目标节点向根节点触发。</p> <h3 id="取消默认事件"><a href="#取消默认事件" class="header-anchor">#</a> 取消默认事件</h3> <p><code>e.preventDefault() preventDefault它也是事件对象的一个方法，作用是取消一个目标元素的默认行为，既然说是默认行为，当然只有它有默认行为才能被取消，如果元素本身无默认行为，调用无效。</code></p> <h3 id="jquery-事件-on-方法"><a href="#jquery-事件-on-方法" class="header-anchor">#</a> jQuery 事件 on() 方法</h3> <p>on() 方法在被选元素及子元素上添加一个或多个事件处理程序。</p> <p>语法：</p> <div class="language- extra-class"><pre class="language-text"><code>$( selector ).on( event, childSelector, data, function );
event	           必需。规定要从被选元素添加的一个或多个事件或命名空间。childSelector	   可选。规定只能添加到指定的子元素上的事件处理程序。
data	                   可选。规定传递到函数的额外数据。
function	           可选。规定当事件发生时运行的函数。
</code></pre></div><h3 id="jquery事件处理机制解决了哪些问题"><a href="#jquery事件处理机制解决了哪些问题" class="header-anchor">#</a> jQuery事件处理机制解决了哪些问题?</h3> <ul><li>不同浏览器下的事件兼容</li> <li>一个事件类型添加多个事件函数，一次添加多个事件类型的处理函数</li> <li>简洁的定义方式</li> <li>允许自定义事件</li></ul> <h3 id="jquery事件原型设计"><a href="#jquery事件原型设计" class="header-anchor">#</a> jQuery事件原型设计</h3> <p><img src="/knowledge/3212134.png" alt=""></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">8/25/2021, 3:56:53 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/knowledge/call,apply,bind,new的内部原理实现.html" class="prev">
        call,apply,bind,new的内部原理实现
      </a></span> <span class="next"><a href="/note/knowledge/元编程.html">
        元编程
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.61a85b1c.js" defer></script><script src="/assets/js/2.6b359b12.js" defer></script><script src="/assets/js/47.84f7cda3.js" defer></script>
  </body>
</html>
