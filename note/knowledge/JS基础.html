<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript 基础 | 码农机器人</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="努力向前">
    
    <link rel="preload" href="/assets/css/0.styles.b8d0645b.css" as="style"><link rel="preload" href="/assets/js/app.61a85b1c.js" as="script"><link rel="preload" href="/assets/js/2.6b359b12.js" as="script"><link rel="preload" href="/assets/js/44.2b684e4d.js" as="script"><link rel="prefetch" href="/assets/js/10.6bf522d2.js"><link rel="prefetch" href="/assets/js/100.a249a4e9.js"><link rel="prefetch" href="/assets/js/101.9d2465ad.js"><link rel="prefetch" href="/assets/js/102.5ea0ea92.js"><link rel="prefetch" href="/assets/js/103.ad073f03.js"><link rel="prefetch" href="/assets/js/104.afd1455c.js"><link rel="prefetch" href="/assets/js/105.5429d9b6.js"><link rel="prefetch" href="/assets/js/106.012719c5.js"><link rel="prefetch" href="/assets/js/107.fa002f10.js"><link rel="prefetch" href="/assets/js/108.9c70864a.js"><link rel="prefetch" href="/assets/js/109.ab6712ef.js"><link rel="prefetch" href="/assets/js/11.07adb038.js"><link rel="prefetch" href="/assets/js/110.3496849e.js"><link rel="prefetch" href="/assets/js/111.0708cccd.js"><link rel="prefetch" href="/assets/js/112.3ddda9ff.js"><link rel="prefetch" href="/assets/js/113.a826b4ec.js"><link rel="prefetch" href="/assets/js/114.54f06bf1.js"><link rel="prefetch" href="/assets/js/115.68bd2270.js"><link rel="prefetch" href="/assets/js/116.0e283e33.js"><link rel="prefetch" href="/assets/js/117.10ca7c11.js"><link rel="prefetch" href="/assets/js/118.0f21544b.js"><link rel="prefetch" href="/assets/js/119.3d5cdaf0.js"><link rel="prefetch" href="/assets/js/12.6a633ec9.js"><link rel="prefetch" href="/assets/js/13.2e8873e5.js"><link rel="prefetch" href="/assets/js/14.0ea5ac55.js"><link rel="prefetch" href="/assets/js/15.d24d1240.js"><link rel="prefetch" href="/assets/js/16.bfb99431.js"><link rel="prefetch" href="/assets/js/17.0bf6db21.js"><link rel="prefetch" href="/assets/js/18.f6a16197.js"><link rel="prefetch" href="/assets/js/19.15b1e095.js"><link rel="prefetch" href="/assets/js/20.56746f5a.js"><link rel="prefetch" href="/assets/js/21.5019bb92.js"><link rel="prefetch" href="/assets/js/22.36a83eaf.js"><link rel="prefetch" href="/assets/js/23.c1d826fa.js"><link rel="prefetch" href="/assets/js/24.66437f58.js"><link rel="prefetch" href="/assets/js/25.b5ef9760.js"><link rel="prefetch" href="/assets/js/26.1e34c193.js"><link rel="prefetch" href="/assets/js/27.ea4375e5.js"><link rel="prefetch" href="/assets/js/28.8e440e91.js"><link rel="prefetch" href="/assets/js/29.ffd2070e.js"><link rel="prefetch" href="/assets/js/3.a6d8cb97.js"><link rel="prefetch" href="/assets/js/30.c1451f4e.js"><link rel="prefetch" href="/assets/js/31.a21ecc83.js"><link rel="prefetch" href="/assets/js/32.5d1de9ff.js"><link rel="prefetch" href="/assets/js/33.f9eef1d1.js"><link rel="prefetch" href="/assets/js/34.edb8fde2.js"><link rel="prefetch" href="/assets/js/35.6950ed93.js"><link rel="prefetch" href="/assets/js/36.b394a848.js"><link rel="prefetch" href="/assets/js/37.f11aa33f.js"><link rel="prefetch" href="/assets/js/38.e86bdf7f.js"><link rel="prefetch" href="/assets/js/39.dbc9c882.js"><link rel="prefetch" href="/assets/js/4.f3783df1.js"><link rel="prefetch" href="/assets/js/40.470a2b37.js"><link rel="prefetch" href="/assets/js/41.bcffb885.js"><link rel="prefetch" href="/assets/js/42.484ee502.js"><link rel="prefetch" href="/assets/js/43.2a86b409.js"><link rel="prefetch" href="/assets/js/45.4e6fb818.js"><link rel="prefetch" href="/assets/js/46.86268f46.js"><link rel="prefetch" href="/assets/js/47.84f7cda3.js"><link rel="prefetch" href="/assets/js/48.fd78be04.js"><link rel="prefetch" href="/assets/js/49.f5a6fc1e.js"><link rel="prefetch" href="/assets/js/5.892f2cf8.js"><link rel="prefetch" href="/assets/js/50.29919944.js"><link rel="prefetch" href="/assets/js/51.c1b5918c.js"><link rel="prefetch" href="/assets/js/52.c4ad64f8.js"><link rel="prefetch" href="/assets/js/53.df154372.js"><link rel="prefetch" href="/assets/js/54.4fee1b96.js"><link rel="prefetch" href="/assets/js/55.18c6e9f2.js"><link rel="prefetch" href="/assets/js/56.d5569485.js"><link rel="prefetch" href="/assets/js/57.9eb74b69.js"><link rel="prefetch" href="/assets/js/58.c8b7968e.js"><link rel="prefetch" href="/assets/js/59.a208d99c.js"><link rel="prefetch" href="/assets/js/6.a9a81823.js"><link rel="prefetch" href="/assets/js/60.c0f7048b.js"><link rel="prefetch" href="/assets/js/61.e06e2c12.js"><link rel="prefetch" href="/assets/js/62.3726a0b9.js"><link rel="prefetch" href="/assets/js/63.53a81692.js"><link rel="prefetch" href="/assets/js/64.ba6af384.js"><link rel="prefetch" href="/assets/js/65.2f165ffa.js"><link rel="prefetch" href="/assets/js/66.8c0a983a.js"><link rel="prefetch" href="/assets/js/67.74bf1c32.js"><link rel="prefetch" href="/assets/js/68.27c15e0b.js"><link rel="prefetch" href="/assets/js/69.5b78d6fb.js"><link rel="prefetch" href="/assets/js/7.a9e85c97.js"><link rel="prefetch" href="/assets/js/70.4772f9bd.js"><link rel="prefetch" href="/assets/js/71.2a2e89e4.js"><link rel="prefetch" href="/assets/js/72.3debedf0.js"><link rel="prefetch" href="/assets/js/73.c9ee93ce.js"><link rel="prefetch" href="/assets/js/74.7ec9495c.js"><link rel="prefetch" href="/assets/js/75.8c828ff5.js"><link rel="prefetch" href="/assets/js/76.986dc0d7.js"><link rel="prefetch" href="/assets/js/77.7e7e3c8e.js"><link rel="prefetch" href="/assets/js/78.200d9828.js"><link rel="prefetch" href="/assets/js/79.ee6b28e9.js"><link rel="prefetch" href="/assets/js/8.448002b9.js"><link rel="prefetch" href="/assets/js/80.93d03d67.js"><link rel="prefetch" href="/assets/js/81.eebcba15.js"><link rel="prefetch" href="/assets/js/82.3b0bb838.js"><link rel="prefetch" href="/assets/js/83.75234d18.js"><link rel="prefetch" href="/assets/js/84.1a897e55.js"><link rel="prefetch" href="/assets/js/85.8267b168.js"><link rel="prefetch" href="/assets/js/86.a7557c20.js"><link rel="prefetch" href="/assets/js/87.4f7e77b3.js"><link rel="prefetch" href="/assets/js/88.9b41f10e.js"><link rel="prefetch" href="/assets/js/89.662b9425.js"><link rel="prefetch" href="/assets/js/9.804860d0.js"><link rel="prefetch" href="/assets/js/90.6d84e2d8.js"><link rel="prefetch" href="/assets/js/91.650a7b6f.js"><link rel="prefetch" href="/assets/js/92.8568032c.js"><link rel="prefetch" href="/assets/js/93.0c300b40.js"><link rel="prefetch" href="/assets/js/94.f7ce23ff.js"><link rel="prefetch" href="/assets/js/95.e6c8272f.js"><link rel="prefetch" href="/assets/js/96.8f51c3ac.js"><link rel="prefetch" href="/assets/js/97.9cc683f5.js"><link rel="prefetch" href="/assets/js/98.6af1269f.js"><link rel="prefetch" href="/assets/js/99.97a09de8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8d0645b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="码农机器人" class="logo"> <span class="site-name can-hide">码农机器人</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>建立前端知识体系</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/handwritten/手写.html" class="sidebar-link">手写</a></li><li><a href="/note/knowledge/JS数据类型.html" class="sidebar-link">JS数据类型</a></li><li><a href="/note/knowledge/变量、作用域、内存问题.html" class="sidebar-link">变量、作用域、内存问题</a></li><li><a href="/note/knowledge/复杂数据类型.html" class="sidebar-link">复杂数据类型</a></li><li><a href="/note/knowledge/JS原型-原型链.html" class="sidebar-link">JS原型-原型链</a></li><li><a href="/note/knowledge/函数表达式.html" class="sidebar-link">函数表达式</a></li><li><a href="/note/knowledge/事件循环机制EventLoop.html" class="sidebar-link">事件循环机制EventLoop</a></li><li><a href="/note/knowledge/深拷贝、浅拷贝.html" class="sidebar-link">深拷贝、浅拷贝</a></li><li><a href="/note/knowledge/迭代器.html" class="sidebar-link">迭代器</a></li><li><a href="/note/knowledge/tcp.html" class="sidebar-link">TCP三次握手，四次挥手</a></li><li><a href="/note/knowledge/HTTPS和HTTP2.0.html" class="sidebar-link">HTTPS和HTTP2.0</a></li><li><a href="/note/knowledge/call,apply,bind,new的内部原理实现.html" class="sidebar-link">call,apply,bind,new的内部原理实现</a></li><li><a href="/note/knowledge/JavaScript工作原理.html" class="sidebar-link">JavaScript工作原理</a></li><li><a href="/note/knowledge/元编程.html" class="sidebar-link">元编程</a></li><li><a href="/note/knowledge/JS基础.html" class="active sidebar-link">JavaScript 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#javascript-有哪些数据类型-它们的区别" class="sidebar-link">JavaScript 有哪些数据类型，它们的区别？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#数据类型检测的方式有哪些" class="sidebar-link">数据类型检测的方式有哪些？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#typeof" class="sidebar-link">typeof</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#instanceof" class="sidebar-link">instanceof</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#constructor" class="sidebar-link">constructor</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#object-prototype-tostring-call" class="sidebar-link">Object.prototype.toString.call()</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#null-和-undefined-区别" class="sidebar-link">null 和 undefined 区别</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#intanceof-操作符的实现原理及实现" class="sidebar-link">intanceof 操作符的实现原理及实现</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#object-is-与比较操作符-、-的区别" class="sidebar-link">Object.is() 与比较操作符 “===”、“==” 的区别</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#如何判断一个对象是空对象" class="sidebar-link">如何判断一个对象是空对象</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#const-对象的属性可以修改吗" class="sidebar-link">const 对象的属性可以修改吗</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#如果-new-一个箭头函数的会怎么样" class="sidebar-link">如果 new 一个箭头函数的会怎么样</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#箭头函数的-this-指向哪里" class="sidebar-link">箭头函数的 this 指向哪⾥？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#javascript-脚本延迟加载的方式有哪些" class="sidebar-link">JavaScript 脚本延迟加载的方式有哪些？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#什么是-dom-和-bom" class="sidebar-link">什么是 DOM 和 BOM？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#escape、encodeuri、encodeuricomponent-的区别" class="sidebar-link">escape、encodeURI、encodeURIComponent 的区别</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#什么是尾调用-使用尾调用有什么好处" class="sidebar-link">什么是尾调用，使用尾调用有什么好处？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#es6-模块与-commonjs-模块有什么异同" class="sidebar-link">ES6 模块与 CommonJS 模块有什么异同？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#for-in-和-for-of-的区别" class="sidebar-link">for...in 和 for...of 的区别</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#原型链的终点是什么" class="sidebar-link">原型链的终点是什么？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#对作用域、作用域链的理解" class="sidebar-link">对作用域、作用域链的理解</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#对-this-对象的理解" class="sidebar-link">对 this 对象的理解</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#call-和-apply-的区别" class="sidebar-link">call() 和 apply() 的区别？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#异步编程的实现方式" class="sidebar-link">异步编程的实现方式？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#对-promise-的理解" class="sidebar-link">对 Promise 的理解</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#对-async-await-的理解" class="sidebar-link">对 async/await 的理解</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#async-await-对比-promise-的优势" class="sidebar-link">async/await 对比 Promise 的优势</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#对象创建的方式有哪些" class="sidebar-link">对象创建的方式有哪些？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#对象继承的方式有哪些" class="sidebar-link">对象继承的方式有哪些？</a></li><li class="sidebar-sub-header"><a href="/note/knowledge/JS基础.html#哪些情况会导致内存泄漏" class="sidebar-link">哪些情况会导致内存泄漏</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue源码分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>提效赋能 前端工程化篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>程序员PLUS篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>忍者秘籍书</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript-基础"><a href="#javascript-基础" class="header-anchor">#</a> JavaScript 基础</h1> <h2 id="javascript-有哪些数据类型-它们的区别"><a href="#javascript-有哪些数据类型-它们的区别" class="header-anchor">#</a> JavaScript 有哪些数据类型，它们的区别？</h2> <p>JavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、
Number、String、Object、Symbol、BigInt。</p> <p>其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：</p> <ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了
解决可能出现的全局变量冲突的问题。</li> <li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，
使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了
Number 能够表示的安全整数范围。</li></ul> <p>这些数据可以分为原始数据类型和引用数据类型：</p> <ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li> <li>堆：引用数据类型（对象、数组和函数）</li></ul> <p>两种类型的区别在于存储位置的不同：</p> <ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间
小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li> <li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固
定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈
中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引
用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</li> <li>在数据结构中，栈中数据的存取方式为先进后出。</li> <li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大
小来规定。</li></ul> <p>在操作系统中，内存被分为栈区和堆区：</p> <ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的
值等。其操作方式类似于数据结构中的栈。</li> <li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可
能由垃圾回收机制回收。</li></ul> <h2 id="数据类型检测的方式有哪些"><a href="#数据类型检测的方式有哪些" class="header-anchor">#</a> 数据类型检测的方式有哪些？</h2> <h3 id="typeof"><a href="#typeof" class="header-anchor">#</a> typeof</h3> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// boolean</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><p>其中数组、对象、null 都会被判断为 object，其他判断都正确。</p> <h3 id="instanceof"><a href="#instanceof" class="header-anchor">#</a> instanceof</h3> <p>instanceof 可以正确判断对象的类型，其内部运行机制是判断在其
原型链中能否找到该类型的原型。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>instanceof 只能正确判断引用数据类型，而不能判断基
本数据类型。instanceof 运算符可以用来测试一个对象在其原型链
中是否存在一个构造函数的 prototype 属性。</p> <h3 id="constructor"><a href="#constructor" class="header-anchor">#</a> constructor</h3> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> String<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>constructor 有两个作用，一是判断数据的类型，二是对象实例通过
constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象
来改变它的原型，constructor 就不能用来判断数据类型了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Fn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="object-prototype-tostring-call"><a href="#object-prototype-tostring-call" class="header-anchor">#</a> Object.prototype.toString.call()</h3> <p>Object.prototype.toString.call() 使用 Object 对象的原型方法
toString 来判断数据类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Number]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Boolean]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;str&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object String]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Array]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Object]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Null]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [object Undefined]</span>
</code></pre></div><p>同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和
Object.prototype.toString.call(obj)的结果不一样，这是为什
么？</p> <p>这是因为 toString 是 Object 的原型方法，而 Array、function 等类
型作为 Object 的实例，都重写了 toString 方法。不同的对象类型调
用 toString 方法时，根据原型链的知识，调用的是对应的重写之后</p> <p>的 toString 方法（function 类型返回内容为函数体的字符串，Array
类型返回元素组成的字符串…），而不会去调用 Object 上原型
toString 方法（返回对象的具体类型），所以采用 obj.toString()
不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要
得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。</p> <h2 id="null-和-undefined-区别"><a href="#null-和-undefined-区别" class="header-anchor">#</a> null 和 undefined 区别</h2> <p>Undefined 和 Null 都是基本数据类型，这两个基本数据类型
分别都只有一个值，就是 undefined 和 null。</p> <p>undefined 代表的含义是未定义，null 代表的含义是空对象。一般
变量声明了但还没有定义的时候会返回 undefined，null 主要用于
赋值给一些可能会返回对象的变量，作为初始化。</p> <p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用
undefined 来作为一个变量名，但是这样的做法是非常危险的，它会
影响对 undefined 值的判断。我们可以通过一些方法获得安全的
undefined 值，比如说 void 0。</p> <p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回
“object”，这是一个历史遗留的问题。当使用双等号对两种类型的
值进行比较时会返回 true，使用三个等号时会返回 false。</p> <h2 id="intanceof-操作符的实现原理及实现"><a href="#intanceof-操作符的实现原理及实现" class="header-anchor">#</a> intanceof 操作符的实现原理及实现</h2> <p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现
在对象的原型链中的任何位置。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> right <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;not function&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">||</span> <span class="token keyword">typeof</span> left <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> left <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> leftVal <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token keyword">const</span> rightVal <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>leftVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>leftVal <span class="token operator">==</span> rightVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    leftVal <span class="token operator">=</span> leftVal<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="object-is-与比较操作符-、-的区别"><a href="#object-is-与比较操作符-、-的区别" class="header-anchor">#</a> Object.is() 与比较操作符 “===”、“==” 的区别</h2> <p>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进
行强制类型转化后再进行比较。</p> <p>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不
会做强制类型准换，直接返回 false。</p> <p>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相
同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN
是相等的。</p> <h2 id="如何判断一个对象是空对象"><a href="#如何判断一个对象是空对象" class="header-anchor">#</a> 如何判断一个对象是空对象</h2> <p>使用 JSON 自带的.stringify 方法来判断：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;{}&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;空对象&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用 ES6 新增的方法 Object.keys()来判断：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>keys<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;空对象&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="const-对象的属性可以修改吗"><a href="#const-对象的属性可以修改吗" class="header-anchor">#</a> const 对象的属性可以修改吗</h2> <p>const 保证的并不是变量的值不能改动，而是变量指向的那个内存地
址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值
就保存在变量指向的那个内存地址，因此等同于常量。</p> <p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的
内存地址，保存的只是一个指针，const 只能保证这个指针是固定不
变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p> <h2 id="如果-new-一个箭头函数的会怎么样"><a href="#如果-new-一个箭头函数的会怎么样" class="header-anchor">#</a> 如果 new 一个箭头函数的会怎么样</h2> <p>箭头函数是 ES6 中的提出来的，它没有 prototype，也没有自己的 this
指向，更不可以使用 arguments 参数，所以不能 New 一个箭头函数。
new 操作符的实现步骤如下：</p> <ul><li>创建一个对象</li> <li>将构造函数的作用域赋给新对象（也就是将对象的<strong>proto</strong>属性指向构造函数的 prototype 属性）</li> <li>指向构造函数中的代码，构造函数中的 this 指向该对象（也就是为这个对象添加属性和方法）</li> <li>返回新的对象</li></ul> <p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p> <h2 id="箭头函数的-this-指向哪里"><a href="#箭头函数的-this-指向哪里" class="header-anchor">#</a> 箭头函数的 this 指向哪⾥？</h2> <p>箭头函数不同于传统 JavaScript 中的函数，箭头函数并没有属于⾃
⼰的 this，它所谓的 this 是捕获其所在上下⽂的 this 值，作为⾃
⼰的 this 值，并且由于没有属于⾃⼰的 this，所以是不会被 new
调⽤的，这个所谓的 this 也不会被改变。</p> <h2 id="javascript-脚本延迟加载的方式有哪些"><a href="#javascript-脚本延迟加载的方式有哪些" class="header-anchor">#</a> JavaScript 脚本延迟加载的方式有哪些？</h2> <p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。js 延
迟加载有助于提高页面加载速度。</p> <p>一般有以下几种方式：</p> <p>defer 属性：给 js 脚本添加 defer 属性，这个属性会让脚本的加
载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文
件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性
的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是
这样。</p> <p>async 属性：给 js 脚本添加 async 属性，这个属性会使脚本异步
加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js
脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async
属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次
执行。</p> <p>动态创建 DOM 方式：动态创建 DOM 标签的方式，可以对文档的加载
事件进行监听，当文档加载完成后再动态的创建 script 标签来引入
js 脚本。</p> <p>使用 setTimeout 延迟方法：设置一个定时器来延迟加载 js 脚本文件。</p> <p>让 JS 最后加载：将 js 脚本放在文档的底部，来使 js 脚本尽可能
的在最后来加载执行。</p> <h2 id="什么是-dom-和-bom"><a href="#什么是-dom-和-bom" class="header-anchor">#</a> 什么是 DOM 和 BOM？</h2> <p>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象
主要定义了处理网页内容的方法和接口。</p> <p>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，
这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是
window，而 window 对象具有双重角色，它既是通过 js 访问浏览器
窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页
中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方
法存在。window 对象含有 location 对象、navigator 对象、screen
对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM
的 window 对象的子对象。</p> <h2 id="escape、encodeuri、encodeuricomponent-的区别"><a href="#escape、encodeuri、encodeuricomponent-的区别" class="header-anchor">#</a> escape、encodeURI、encodeURIComponent 的区别</h2> <p>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合
法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p> <p>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊
字符也会得到转义。</p> <p>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为
0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode
编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，
再在每个字节前加上 %。</p> <h2 id="什么是尾调用-使用尾调用有什么好处"><a href="#什么是尾调用-使用尾调用有什么好处" class="header-anchor">#</a> 什么是尾调用，使用尾调用有什么好处？</h2> <p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行
栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上
下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，
因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上
下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优
化只在严格模式下开启，正常模式是无效的。</p> <h2 id="es6-模块与-commonjs-模块有什么异同"><a href="#es6-模块与-commonjs-模块有什么异同" class="header-anchor">#</a> ES6 模块与 CommonJS 模块有什么异同？</h2> <p>ES6 Module 和 CommonJS 模块的区别：</p> <p>CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6
Module 只存只读，不能改变其值，也就是指针指向不能变，类似 const；
import 的接⼝是 read-only（只读状态），不能修改其变量值。 即
不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对
commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会
编译报错。</p> <p>ES6 Module 和 CommonJS 模块的共同点：</p> <p>CommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内
部属性的值进⾏改变。</p> <h2 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="header-anchor">#</a> for...in 和 for...of 的区别</h2> <p>for…of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口
的数据结构（数组、对象等）并且返回各项的值，和 for…in 的区别如下:</p> <p>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</p> <p>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而
for … of 只遍历当前对象不会遍历原型链；</p> <p>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原
型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</p> <p>总结：for...in 循环主要是为了遍历对象而生，不适用于遍历数组；
for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以
及 Generator 对象。</p> <h2 id="原型链的终点是什么"><a href="#原型链的终点是什么" class="header-anchor">#</a> 原型链的终点是什么？</h2> <p>由于 Object 是构造函数，原型链终点 Object.prototype.<strong>proto</strong>，
而 Object.prototype.<strong>proto</strong>=== null // true，所以，原型链
的终点是 null。原型链上的所有原型都是对象，所有的对象最终都
是由 Object 构造的，而 Object.prototype 的下一级是
Object.prototype.<strong>proto</strong>。</p> <h2 id="对作用域、作用域链的理解"><a href="#对作用域、作用域链的理解" class="header-anchor">#</a> 对作用域、作用域链的理解</h2> <p>1）全局作用域和函数作用域</p> <p>（1）全局作用域</p> <p>最外层函数和最外层函数外面定义的变量拥有全局作用域</p> <p>所有未定义直接赋值的变量自动声明为全局作用域</p> <p>所有 window 对象的属性拥有全局作用域</p> <p>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空
间，容易引起命名冲突。</p> <p>（2）函数作用域</p> <p>函数作用域声明在函数内部的变量，一般只有固定的代码片段可以访问到</p> <p>作用域是分层的，内层作用域可以访问外层作用域，反之不行</p> <p>2）块级作用域</p> <p>使用 ES6 中新增的 let 和 const 指令可以声明块级作用域，块级作用
域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）</p> <p>let 和 const 声明的变量不会有变量提升，也不可以重复声明</p> <p>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量
限制在循环内部。</p> <p>作用域链：</p> <p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个
变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域
查找，依次向上级作用域查找，直到访问到 window 对象就被终止，
这一层层的关系就是作用域链。</p> <p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有
序访问，通过作用域链，可以访问到外层环境的变量和函数。
作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个
包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是
当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全
局对象）始终是作用域链的最后一个对象。</p> <p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域
链向后查找。</p> <h2 id="对-this-对象的理解"><a href="#对-this-对象的理解" class="header-anchor">#</a> 对 this 对象的理解</h2> <p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的
对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p> <p>第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作
为函数来调用时，this 指向全局对象。</p> <p>第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，
this 指向这个对象。</p> <p>第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行
前会新创建一个对象，this 指向这个新创建的对象。</p> <p>第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显
示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：
一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，
第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。
也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举
出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对
象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其
他情况下都不会改变。</p> <p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call
和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p> <h2 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="header-anchor">#</a> call() 和 apply() 的区别？</h2> <p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p> <p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，
第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类
数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p> <p>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是
代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依
次传入函数。</p> <h2 id="异步编程的实现方式"><a href="#异步编程的实现方式" class="header-anchor">#</a> 异步编程的实现方式？</h2> <p>JavaScript 中的异步机制可以分为以下几种：</p> <p>回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函
数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦
合度太高，不利于代码的可维护。</p> <p>Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为
链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，
可能会造成代码的语义不够明确。</p> <p>generator 的方式，它可以在函数的执行过程中，将函数的执行权转
移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行
的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权
给转移回来。因此在 generator 内部对于异步操作的方式，可以以
同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控
制权转移回来，因此需要有一个自动执行 generator 的机制，比如
说 co 模块等方式来实现 generator 的自动执行。</p> <p>async 函数的方式，async 函数是 generator 和 promise 实现的
一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个
await 语句的时候，如果语句返回一个 promise 对象，那么函数将
会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此
可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动
执行。</p> <h2 id="对-promise-的理解"><a href="#对-promise-的理解" class="header-anchor">#</a> 对 Promise 的理解</h2> <p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步
操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，
它比传统的解决方案回调函数和事件更合理和更强大。</p> <p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束
的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一
个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，
各种异步操作都可以用同样的方法进行处理。</p> <p>（1）Promise 的实例有三个状态:</p> <p>Pending（进行中）</p> <p>Resolved（已完成）</p> <p>Rejected（已拒绝）</p> <p>当把一件事情交给 promise 时，它的状态就是 Pending，任务完成了
状态就变成了 Resolved、没有完成失败了就变成了 Rejected。</p> <p>（2）Promise 的实例有两个过程：</p> <p>pending -&gt; fulfilled : Resolved（已完成）</p> <p>pending -&gt; rejected：Rejected（已拒绝）</p> <p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p> <p>Promise 的特点：</p> <p>对象的状态不受外界影响。promise 对象代表一个异步操作，有三种
状态，pending（进行中）、fulfilled（已成功）、rejected（已失
败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他
操作都无法改变这个状态，这也是 promise 这个名字的由来——“承
诺”；</p> <p>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise
对象的状态改变，只有两种可能：从 pending 变为 fulfilled，从
pending 变为 rejected。这时就称为 resolved（已定型）。如果改
变已经发生了，你再对 promise 对象添加回调函数，也会立即得到这
个结果。这与事件（event）完全不同，事件的特点是：如果你错过
了它，再去监听是得不到结果的。</p> <p>Promise 的缺点：</p> <p>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。
如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始
还是即将完成）。</p> <p>总结：</p> <p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise
是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。
一个 Promise 实例有三种状态，分别是 pending、resolved 和
rejected，分别代表了进行中、已成功和已失败。实例的状态只能由
pending 转变 resolved 或者 rejected 状态，并且状态一经改变，
就凝固了，无法再被改变了。</p> <p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在
异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原
型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的
改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的
末尾执行。</p> <p>注意：在构造 Promise 的时候，构造函数内部的代码是立即执行的</p> <h2 id="对-async-await-的理解"><a href="#对-async-await-的理解" class="header-anchor">#</a> 对 async/await 的理解</h2> <p>async/await 其实是 Generator 的语法糖，它能实现的效果都能用
then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，
async 是“异步”的简写，await 则为等待，所以很好理解 async 用
于申明一个 function 是异步的，而 await 用于等待一个异步方法
执行完成。</p> <p>优势：</p> <p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需
要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。</p> <h2 id="async-await-对比-promise-的优势"><a href="#async-await-对比-promise-的优势" class="header-anchor">#</a> async/await 对比 Promise 的优势</h2> <p>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的
链式调⽤也会带来额外的阅读负担</p> <p>Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅</p> <p>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的
错误捕获⾮常冗余</p> <p>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返
回表达式的箭头函数中设置断点，如果你在⼀个.then 代码块中使⽤
调试器的步进(step-over)功能，调试器并不会进⼊后续的.then 代
码块，因为调试器只能跟踪同步代码的每⼀步。</p> <h2 id="对象创建的方式有哪些"><a href="#对象创建的方式有哪些" class="header-anchor">#</a> 对象创建的方式有哪些？</h2> <p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大
量相似对象的时候，会产生大量的重复代码。但 js 和一般的面向对
象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来
进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p> <ul><li>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装
创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一
个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是
简单的封装了复用代码，而没有建立起对象和类型间的关系。</li> <li>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，
只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。
执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数
的 prototype 属性，然后将执行上下文中的 this 指向这个对象，
最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因
为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。
构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建
立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存
在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函
数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次
都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有
的实例都可以通用的。</li> <li>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype
属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例
都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方
法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决
了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有
办法通过传入参数来初始化值，另一个是如果存在一个引用类型如
Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用
类型值的改变会影响所有的实例。</li> <li>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自
定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存
在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化
对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的
解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使
用了两种不同的模式，所以对于代码的封装性不够好。</li> <li>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创
建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以
实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式
很好地对上面的混合模式进行了封装。</li> <li>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实
现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，
在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函
数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法
实现对象的识别。</li></ul> <h2 id="对象继承的方式有哪些"><a href="#对象继承的方式有哪些" class="header-anchor">#</a> 对象继承的方式有哪些？</h2> <ul><li>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在
的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，
容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传
递参数。</li> <li>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子
类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不
能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函
数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</li> <li>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数
组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属
性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继
承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我
们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构
造函数，造成了子类型的原型中多了很多不必要的属性。</li> <li>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已
有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，
然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为
了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5
中定义的 Object.create() 方法就是原型式继承的实现。缺点与原
型链方式相同。</li> <li>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于
封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，
然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解
是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这
个对象不是自定义类型时。缺点是没有办法实现函数的复用。</li> <li>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类
型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式
组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这
样就避免了创建不必要的属性</li></ul> <h2 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="header-anchor">#</a> 哪些情况会导致内存泄漏</h2> <ul><li>意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局
变量，而使这个变量一直留在内存中无法被回收。</li> <li>被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记
取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被
一直留在内存中，而无法被回收。</li> <li>脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删
除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li> <li>闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">7/28/2023, 3:06:05 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/knowledge/元编程.html" class="prev">
        元编程
      </a></span> <span class="next"><a href="/note/vue3/vue基础.html">
        Vue 基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.61a85b1c.js" defer></script><script src="/assets/js/2.6b359b12.js" defer></script><script src="/assets/js/44.2b684e4d.js" defer></script>
  </body>
</html>
