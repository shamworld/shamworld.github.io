<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>忍者秘籍书 | 码农机器人</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="努力向前">
    
    <link rel="preload" href="/assets/css/0.styles.b8d0645b.css" as="style"><link rel="preload" href="/assets/js/app.61a85b1c.js" as="script"><link rel="preload" href="/assets/js/2.6b359b12.js" as="script"><link rel="preload" href="/assets/js/27.ea4375e5.js" as="script"><link rel="prefetch" href="/assets/js/10.6bf522d2.js"><link rel="prefetch" href="/assets/js/100.a249a4e9.js"><link rel="prefetch" href="/assets/js/101.9d2465ad.js"><link rel="prefetch" href="/assets/js/102.5ea0ea92.js"><link rel="prefetch" href="/assets/js/103.ad073f03.js"><link rel="prefetch" href="/assets/js/104.afd1455c.js"><link rel="prefetch" href="/assets/js/105.5429d9b6.js"><link rel="prefetch" href="/assets/js/106.012719c5.js"><link rel="prefetch" href="/assets/js/107.fa002f10.js"><link rel="prefetch" href="/assets/js/108.9c70864a.js"><link rel="prefetch" href="/assets/js/109.ab6712ef.js"><link rel="prefetch" href="/assets/js/11.07adb038.js"><link rel="prefetch" href="/assets/js/110.3496849e.js"><link rel="prefetch" href="/assets/js/111.0708cccd.js"><link rel="prefetch" href="/assets/js/112.3ddda9ff.js"><link rel="prefetch" href="/assets/js/113.a826b4ec.js"><link rel="prefetch" href="/assets/js/114.54f06bf1.js"><link rel="prefetch" href="/assets/js/115.68bd2270.js"><link rel="prefetch" href="/assets/js/116.0e283e33.js"><link rel="prefetch" href="/assets/js/117.10ca7c11.js"><link rel="prefetch" href="/assets/js/118.0f21544b.js"><link rel="prefetch" href="/assets/js/119.3d5cdaf0.js"><link rel="prefetch" href="/assets/js/12.6a633ec9.js"><link rel="prefetch" href="/assets/js/13.2e8873e5.js"><link rel="prefetch" href="/assets/js/14.0ea5ac55.js"><link rel="prefetch" href="/assets/js/15.d24d1240.js"><link rel="prefetch" href="/assets/js/16.bfb99431.js"><link rel="prefetch" href="/assets/js/17.0bf6db21.js"><link rel="prefetch" href="/assets/js/18.f6a16197.js"><link rel="prefetch" href="/assets/js/19.15b1e095.js"><link rel="prefetch" href="/assets/js/20.56746f5a.js"><link rel="prefetch" href="/assets/js/21.5019bb92.js"><link rel="prefetch" href="/assets/js/22.36a83eaf.js"><link rel="prefetch" href="/assets/js/23.c1d826fa.js"><link rel="prefetch" href="/assets/js/24.66437f58.js"><link rel="prefetch" href="/assets/js/25.b5ef9760.js"><link rel="prefetch" href="/assets/js/26.1e34c193.js"><link rel="prefetch" href="/assets/js/28.8e440e91.js"><link rel="prefetch" href="/assets/js/29.ffd2070e.js"><link rel="prefetch" href="/assets/js/3.a6d8cb97.js"><link rel="prefetch" href="/assets/js/30.c1451f4e.js"><link rel="prefetch" href="/assets/js/31.a21ecc83.js"><link rel="prefetch" href="/assets/js/32.5d1de9ff.js"><link rel="prefetch" href="/assets/js/33.f9eef1d1.js"><link rel="prefetch" href="/assets/js/34.edb8fde2.js"><link rel="prefetch" href="/assets/js/35.6950ed93.js"><link rel="prefetch" href="/assets/js/36.b394a848.js"><link rel="prefetch" href="/assets/js/37.f11aa33f.js"><link rel="prefetch" href="/assets/js/38.e86bdf7f.js"><link rel="prefetch" href="/assets/js/39.dbc9c882.js"><link rel="prefetch" href="/assets/js/4.f3783df1.js"><link rel="prefetch" href="/assets/js/40.470a2b37.js"><link rel="prefetch" href="/assets/js/41.bcffb885.js"><link rel="prefetch" href="/assets/js/42.484ee502.js"><link rel="prefetch" href="/assets/js/43.2a86b409.js"><link rel="prefetch" href="/assets/js/44.2b684e4d.js"><link rel="prefetch" href="/assets/js/45.4e6fb818.js"><link rel="prefetch" href="/assets/js/46.86268f46.js"><link rel="prefetch" href="/assets/js/47.84f7cda3.js"><link rel="prefetch" href="/assets/js/48.fd78be04.js"><link rel="prefetch" href="/assets/js/49.f5a6fc1e.js"><link rel="prefetch" href="/assets/js/5.892f2cf8.js"><link rel="prefetch" href="/assets/js/50.29919944.js"><link rel="prefetch" href="/assets/js/51.c1b5918c.js"><link rel="prefetch" href="/assets/js/52.c4ad64f8.js"><link rel="prefetch" href="/assets/js/53.df154372.js"><link rel="prefetch" href="/assets/js/54.4fee1b96.js"><link rel="prefetch" href="/assets/js/55.18c6e9f2.js"><link rel="prefetch" href="/assets/js/56.d5569485.js"><link rel="prefetch" href="/assets/js/57.9eb74b69.js"><link rel="prefetch" href="/assets/js/58.c8b7968e.js"><link rel="prefetch" href="/assets/js/59.a208d99c.js"><link rel="prefetch" href="/assets/js/6.a9a81823.js"><link rel="prefetch" href="/assets/js/60.c0f7048b.js"><link rel="prefetch" href="/assets/js/61.e06e2c12.js"><link rel="prefetch" href="/assets/js/62.3726a0b9.js"><link rel="prefetch" href="/assets/js/63.53a81692.js"><link rel="prefetch" href="/assets/js/64.ba6af384.js"><link rel="prefetch" href="/assets/js/65.2f165ffa.js"><link rel="prefetch" href="/assets/js/66.8c0a983a.js"><link rel="prefetch" href="/assets/js/67.74bf1c32.js"><link rel="prefetch" href="/assets/js/68.27c15e0b.js"><link rel="prefetch" href="/assets/js/69.5b78d6fb.js"><link rel="prefetch" href="/assets/js/7.a9e85c97.js"><link rel="prefetch" href="/assets/js/70.4772f9bd.js"><link rel="prefetch" href="/assets/js/71.2a2e89e4.js"><link rel="prefetch" href="/assets/js/72.3debedf0.js"><link rel="prefetch" href="/assets/js/73.c9ee93ce.js"><link rel="prefetch" href="/assets/js/74.7ec9495c.js"><link rel="prefetch" href="/assets/js/75.8c828ff5.js"><link rel="prefetch" href="/assets/js/76.986dc0d7.js"><link rel="prefetch" href="/assets/js/77.7e7e3c8e.js"><link rel="prefetch" href="/assets/js/78.200d9828.js"><link rel="prefetch" href="/assets/js/79.ee6b28e9.js"><link rel="prefetch" href="/assets/js/8.448002b9.js"><link rel="prefetch" href="/assets/js/80.93d03d67.js"><link rel="prefetch" href="/assets/js/81.eebcba15.js"><link rel="prefetch" href="/assets/js/82.3b0bb838.js"><link rel="prefetch" href="/assets/js/83.75234d18.js"><link rel="prefetch" href="/assets/js/84.1a897e55.js"><link rel="prefetch" href="/assets/js/85.8267b168.js"><link rel="prefetch" href="/assets/js/86.a7557c20.js"><link rel="prefetch" href="/assets/js/87.4f7e77b3.js"><link rel="prefetch" href="/assets/js/88.9b41f10e.js"><link rel="prefetch" href="/assets/js/89.662b9425.js"><link rel="prefetch" href="/assets/js/9.804860d0.js"><link rel="prefetch" href="/assets/js/90.6d84e2d8.js"><link rel="prefetch" href="/assets/js/91.650a7b6f.js"><link rel="prefetch" href="/assets/js/92.8568032c.js"><link rel="prefetch" href="/assets/js/93.0c300b40.js"><link rel="prefetch" href="/assets/js/94.f7ce23ff.js"><link rel="prefetch" href="/assets/js/95.e6c8272f.js"><link rel="prefetch" href="/assets/js/96.8f51c3ac.js"><link rel="prefetch" href="/assets/js/97.9cc683f5.js"><link rel="prefetch" href="/assets/js/98.6af1269f.js"><link rel="prefetch" href="/assets/js/99.97a09de8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8d0645b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="码农机器人" class="logo"> <span class="site-name can-hide">码农机器人</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>建立前端知识体系</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue源码分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>提效赋能 前端工程化篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>程序员PLUS篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Flutter</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>忍者秘籍书</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/book/忍者秘籍书.html" class="active sidebar-link">忍者秘籍书</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#利用测试和调试武装自己" class="sidebar-link">利用测试和调试武装自己</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#日志记录" class="sidebar-link">日志记录</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#断点" class="sidebar-link">断点</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#测试用例生成" class="sidebar-link">测试用例生成</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#测试框架" class="sidebar-link">测试框架</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#测试套件基础知识" class="sidebar-link">测试套件基础知识</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#断言" class="sidebar-link">断言</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#函数是根基" class="sidebar-link">函数是根基</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#函数是第一型对象" class="sidebar-link">函数是第一型对象</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#浏览器事件轮询" class="sidebar-link">浏览器事件轮询</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#函数声明" class="sidebar-link">函数声明</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#作用域和函数" class="sidebar-link">作用域和函数</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#函数调用" class="sidebar-link">函数调用</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#挥舞函数" class="sidebar-link">挥舞函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#匿名函数" class="sidebar-link">匿名函数</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#将函数视为对象" class="sidebar-link">将函数视为对象</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#可变长度得参数列表" class="sidebar-link">可变长度得参数列表</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#闭包是如何工地作的" class="sidebar-link">闭包是如何工地作的</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#使用闭包" class="sidebar-link">使用闭包</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#绑定函数上下文" class="sidebar-link">绑定函数上下文</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#偏应用函数" class="sidebar-link">偏应用函数</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#函数重载-2" class="sidebar-link">函数重载</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#即时函数" class="sidebar-link">即时函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#原型与面向对象" class="sidebar-link">原型与面向对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#实例化和原型" class="sidebar-link">实例化和原型</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#疑难陷阱" class="sidebar-link">疑难陷阱</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#编写类的风格的代码" class="sidebar-link">编写类的风格的代码</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#正则表达式" class="sidebar-link">正则表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#为什么正则表达式很牛" class="sidebar-link">为什么正则表达式很牛</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#正则表达式进阶" class="sidebar-link">正则表达式进阶</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#编译正则表达式" class="sidebar-link">编译正则表达式</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#捕获匹配地片段" class="sidebar-link">捕获匹配地片段</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#利用函数进行替换" class="sidebar-link">利用函数进行替换</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#利用正则表达式解决常见问题" class="sidebar-link">利用正则表达式解决常见问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#驯服线程和定时器" class="sidebar-link">驯服线程和定时器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#定时器和线程是如何工作的" class="sidebar-link">定时器和线程是如何工作的</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#定时器延迟的最小化及其可靠性" class="sidebar-link">定时器延迟的最小化及其可靠性</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#处理昂贵的计算过程" class="sidebar-link">处理昂贵的计算过程</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#中央定时器控制" class="sidebar-link">中央定时器控制</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#异步测试" class="sidebar-link">异步测试</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#忍者点金术-运行时代码求值" class="sidebar-link">忍者点金术:运行时代码求值</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#代码求值机制" class="sidebar-link">代码求值机制</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#函数反编译" class="sidebar-link">函数反编译</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#代码求值实战" class="sidebar-link">代码求值实战</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#with语句" class="sidebar-link">with语句</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#with是怎么回事" class="sidebar-link">with是怎么回事</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#真实示例" class="sidebar-link">真实示例</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#导入有命名空间的代码-2" class="sidebar-link">导入有命名空间的代码</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#测试" class="sidebar-link">测试</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#使用with进行模板化" class="sidebar-link">使用with进行模板化</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#开发浏览器策略" class="sidebar-link">开发浏览器策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#选择要支持的浏览器" class="sidebar-link">选择要支持的浏览器</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#五大开发关注点" class="sidebar-link">五大开发关注点</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#实现策略" class="sidebar-link">实现策略</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#减少假设" class="sidebar-link">减少假设</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#洞悉特性-属性和样式" class="sidebar-link">洞悉特性，属性和样式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#dom特性和dom属性" class="sidebar-link">DOM特性和DOM属性</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#跨浏览器的attribute问题" class="sidebar-link">跨浏览器的attribute问题</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#令人头疼的样式特性" class="sidebar-link">令人头疼的样式特性</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#获取计算样式" class="sidebar-link">获取计算样式</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#不老事件" class="sidebar-link">不老事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#绑定和解绑事件处理程序" class="sidebar-link">绑定和解绑事件处理程序</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#event对象" class="sidebar-link">Event对象</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#处理程序的管理" class="sidebar-link">处理程序的管理</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#事件触发-2" class="sidebar-link">事件触发</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#冒泡与委托" class="sidebar-link">冒泡与委托</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#文档就绪事件-document-ready" class="sidebar-link">文档就绪事件(document ready)</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#dom操作" class="sidebar-link">DOM操作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#像dom中注入html" class="sidebar-link">像DOM中注入HTML</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#克隆元素" class="sidebar-link">克隆元素</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#删除元素" class="sidebar-link">删除元素</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#文本内容" class="sidebar-link">文本内容</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#css选择器引擎" class="sidebar-link">CSS选择器引擎</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#w3c-selectors-api" class="sidebar-link">W3C Selectors API</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#利用xpath查找元素" class="sidebar-link">利用XPath查找元素</a></li><li class="sidebar-sub-header"><a href="/note/book/忍者秘籍书.html#纯dom实现" class="sidebar-link">纯DOM实现</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="忍者秘籍书"><a href="#忍者秘籍书" class="header-anchor">#</a> 忍者秘籍书</h1> <h2 id="利用测试和调试武装自己"><a href="#利用测试和调试武装自己" class="header-anchor">#</a> 利用测试和调试武装自己</h2> <h3 id="日志记录"><a href="#日志记录" class="header-anchor">#</a> 日志记录</h3> <div class="language- extra-class"><pre class="language-text"><code>function log(){
    try(){
        console.log.apply(console,arguments);//尝试使用最常见得方法记录
    }catch(e){//捕获日志记录过程中得异常失败
        try{
            opera.postError.apply(opera,arguments);//尝试使用opera方式记录日志
        }catch(e){
            alert(Array.prototype.join.call(arguments,&quot; &quot;));//如果都不行，则使用alert函数
        }
    }
} 
</code></pre></div><h3 id="断点"><a href="#断点" class="header-anchor">#</a> 断点</h3> <p>它能在特定得代码上暂停脚本得执行，从而暂停浏览器运行。这使我们可以在该断电处，随意查看任意代码得状态。包括所有可访问得变量，上下文以及作用域链.</p> <h3 id="测试用例生成"><a href="#测试用例生成" class="header-anchor">#</a> 测试用例生成</h3> <h4 id="特征"><a href="#特征" class="header-anchor">#</a> 特征:</h4> <ul><li>可重用性(repeatability) ----测试结果应该是高度可再生的。多次运行测试应该产生相同得结果。如果测试结果是不确定得，那我们又如何知道哪些结果是有效得，哪些又是无效的呢？此外，可重现性可以确保我们得测试不依赖于外部因素(诸如网络或CPU负载)</li> <li>简单性(simplicity) ----测试应该只关注于测试一件事。在不影响测试用例目的情况下，我们应该尽可能消除过多得HTML标记，CSS或者JavaScript。我们删除得越多，测试用例只受特定代码影响得可能性就越大</li> <li>独立性(independence) ----测试用例应该独立执行。我们必须避免一个测试结果依赖于另一个测试结果。把测试分解成尽可能小的单元，这将帮助我们确定在错误发生时确切代码位置</li></ul> <h4 id="构建测试得主要方法"><a href="#构建测试得主要方法" class="header-anchor">#</a> 构建测试得主要方法:</h4> <ul><li>解构型测试用例(deconstructive test cases) ----解构型测试用例，在消弱代码隔离问题时进行吃创建，以消除任何不恰当得问题。这有助于我们实现之前列表得三个特效。我们可能从一个完整得网站开始练习，但在消除额外得HTML标记，CSS和JavaScript之后，我们将看到一个能重现该问题得小用例场景.</li> <li>构建型测试用例(construct test cases)</li></ul> <h3 id="测试框架"><a href="#测试框架" class="header-anchor">#</a> 测试框架</h3> <h4 id="部分功能"><a href="#部分功能" class="header-anchor">#</a> 部分功能:</h4> <ul><li>能够模拟浏览器行为(单机按键等)</li> <li>测试的交互式控制(暂停和恢复测试)</li> <li>处理异步测试超时问题</li> <li>能够过滤哪些会被执行得测试</li></ul> <h4 id="qunit"><a href="#qunit" class="header-anchor">#</a> QUnit</h4> <p>最初用于测试jQuery得单元测试框架。目前是一个独立得单元测试框架。QUnit主要是为了单元测试提供一个简单得解决方案，提供最小但却易于使用得API</p> <h5 id="特点"><a href="#特点" class="header-anchor">#</a> 特点:</h5> <ul><li>简洁得API</li> <li>支持异步测试</li> <li>不限于jQuery或使用jQuery得代码</li> <li>特别适合于回归测试</li></ul> <h4 id="jsunit"><a href="#jsunit" class="header-anchor">#</a> JsUnit</h4> <p>是流行得Java JUnit测试框架在JavaScript语言上得实现</p> <h3 id="测试套件基础知识"><a href="#测试套件基础知识" class="header-anchor">#</a> 测试套件基础知识</h3> <p>测试套件得主要目的是聚合代码中得所有单个测试，将其组合成一个单元，这样他们可以批量运行，提供一个可以轻松反复运行得单一资源</p> <h3 id="断言"><a href="#断言" class="header-anchor">#</a> 断言</h3> <p>单元测试框架得核心是断言方法，通常叫assert().该方法通常接收一个值----需要断言的值，断言就会通过；否则，断言就会被认为是失败得。通常用一个相应得通过(pass)/失败(fail)标记记录相关得信息</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script&gt;
        //定义assert()方法
        function assert(value,desc){
            var li = document.createElement(&quot;li&quot;);
            li.className = value?&quot;pass&quot;:&quot;fail&quot;;
            li.appendChild(document.createTextNode(desc));
            document.getElementById(&quot;results&quot;).appendChild(li);
        }
        window.onload = function(){
            //测试断言执行执行测试
            assert(true,&quot;The test suite is running&quot;);
            assert(false,&quot;Fail!&quot;);
        }
    &lt;/script&gt;
    &lt;style&gt;
        /* 定义结果样式 */
        #results li.pass{color: green;}
        #results li.fail{color: red;}
    &lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 测试结果显示 --&gt;
    &lt;ul id=&quot;results&quot;&gt;&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div><h2 id="函数是根基"><a href="#函数是根基" class="header-anchor">#</a> 函数是根基</h2> <h3 id="函数是第一型对象"><a href="#函数是第一型对象" class="header-anchor">#</a> 函数是第一型对象</h3> <p>对象在JavaScript中有如下功能</p> <ul><li>它们可以通过字面量进行创建</li> <li>它们可以赋值给变量，数组或其他对象得属性</li> <li>它们可以作为参数传递给函数</li> <li>它们可以作为函数得返回值进行返回</li> <li>它们可以拥有动态创建并赋值的属性</li></ul> <h3 id="浏览器事件轮询"><a href="#浏览器事件轮询" class="header-anchor">#</a> 浏览器事件轮询</h3> <h4 id="方法"><a href="#方法" class="header-anchor">#</a> 方法:</h4> <ul><li>创建用户页面</li> <li>进入轮询，等待事件触发</li> <li>调用事件的处理程序</li></ul> <p>代码不负责事件轮询和事件派发，而是浏览器帮我们处理得</p> <h4 id="以下类型得事件都可能相互穿插发生"><a href="#以下类型得事件都可能相互穿插发生" class="header-anchor">#</a> 以下类型得事件都可能相互穿插发生</h4> <ul><li>浏览器事件，如当一个页面完成加载或卸载得时候</li> <li>网络事件，如响应Ajax请求</li> <li>用户事件，如鼠标单机，鼠标移动或者按键</li> <li>计时器事件，如超时或计时器触发</li></ul> <p>特别注意:浏览器的事件轮询是单线程得。每个事件都是按照在队列中锁放置得顺序来处理，这就是所谓得FIFO(先进先出)列表。每个事件都在自己得生命周期内进行处理，所有其他事件必须等到这个事件处理结束以后才能继续处理。在任何情况下，单线程都不能同时执行两个处理程序。</p> <p><img src="/book/sjxu.png" alt=""></p> <h3 id="函数声明"><a href="#函数声明" class="header-anchor">#</a> 函数声明</h3> <h4 id="函数字面量由四个部分组成"><a href="#函数字面量由四个部分组成" class="header-anchor">#</a> 函数字面量由四个部分组成</h4> <ul><li>function关键字</li> <li>可选名称，如果指定名称，则必须是一个有效得JavaScript标识符</li> <li>括号内部，一个以逗号分割得参数列表。各个参数名称必须是有效的标识符，而且参数列表允许为空，即使是空参数列表，圆括号也必须始终存在。</li> <li>函数体，包含在大括号内的一系列JavaScript语句，函数体可以为空，但是大括号必须始终存在</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
//声明一个命名函数，该名称在当前作用域有效，并隐士在window上添加一个同名属性
function isNimble(){
    return true;
}
//第一个断言判断window属性是确定得，第二个断言判断函数得name属性也是准确记录得
assert(typeof window.isNimble === 'function',&quot;isNimble() defined&quot;);
assert(typeof isNimble.name === 'isNimble',&quot;isNimble() has a name&quot;);
//创建一个匿名函数，并赋值给canFly变量，改变量是一个window属性，并且该匿名函数得name属性为空
var canFly = function(){return true};
//测试断言该变量引用了匿名函数，并且name属性为空
assert(typeof window.canFly === 'function',&quot;canFly() defined&quot;);
assert(typeof canFly.name === &quot;&quot;,&quot;canFly() has no name&quot;);
//创建一个匿名函数，引用到window得一个属性上
window.isDeadly = function(){return true};
//测试断言该属性引用得是所定义得匿名函数，我们也能测试该函数有一个空值得name属性
assert(typeof window.isDeadly === 'function',&quot;isDeadly() defined&quot;);
//在outer函数内定义一个inner函数，测试该inner()在其定义之前和之后都可以访问到，并且没有创建全局得inner()
function outer(){
    assert(typeof inner === 'function',&quot;inner() in scope before delaration&quot;);
    function inner(){}
    assert(typeof inner === 'function',&quot;inner() in scope after declaration&quot;)
    assert(window.inner === undefined,&quot;innner() not in global scope&quot;);
}
//测试断言，outer()可以在全局作用域内访问到，而inner()则不可以
outer();
assert(window.inner === undefined,&quot;inner() still not in global scope&quot;);
//将函数进行赋值得变量与名称无关，真正起到控制作用得是该函数真正得字面量名称
window.wieldsSword = function wieldsSword(){return true};
assert(window.wieldsSword.name === 'wieldsSword',&quot;wieldsSword's real name is wieldsSword&quot;);

&lt;/script&gt;
</code></pre></div><p>在这个测试页面中，我们通过三种不同得方式声明了全局作用域函数:</p> <ul><li>isNimble()函数被声明为一个命名函数，这可能是大多数开发人员所看到得最常见得声明风格</li> <li>创建一个匿名函数，并赋值给一个名为canFly的全局变量。由于JavaScript的函数式特性，该函数可以通过它的引用canFly()进行调用。在这一方面，它与一个定义了名为canFly的命名函数几乎一模一样，但并不完全一样。最主要得一个区别是，该函数得name属性值是&quot;&quot;,而不是&quot;canFly&quot;</li> <li>创建另一个匿名函数，并将其赋值给一个window得isDeadly属性。同样，我们可以通过调用该属性(window.isDeadly()或isDeadly())进行调用。同样，其实功能和一个定义名为isDeadly的命名函数几乎一模一样
<img src="/book/hs.png" alt="">
该测试证明了如下几点:</li> <li>window.isNimble被定义为一个函数，这证明该命名函数是作为属性添加到window对象上得</li> <li>该命名函数isNimble()，有一个name属性，该属性值为&quot;isNimble&quot;</li> <li>window.canFly被定义为一个函数，证明了即使即便包含函数得全局变量，最终也存在于window上得</li> <li>赋值给canFly的匿名函数有一个值为空字符串得name属性</li> <li>window.isDeadly被定义为一个函数</li></ul> <h3 id="作用域和函数"><a href="#作用域和函数" class="header-anchor">#</a> 作用域和函数</h3> <p>在JavaScript得作用域中，作用域是由function进行声明得，而不是代码块。声明得作用域创建于代码块，但不是终结于代码块(其他语言是终结于代码块的)。</p> <p>在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性.作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</p> <div class="language- extra-class"><pre class="language-text"><code>if(window){
    var x=213;
}
alert(x);
</code></pre></div><p>在其他语言中，我们会希望x终结于if语句得关闭大括号，alert则弹出一个undfined值。但是，如果我们在页面上运行上述代码，会发现alert弹出得确实213，这是因为JavaScript在大括号关闭处并没有终止其作用域.</p> <ul><li>变量声明得作用域开始于声明得地方，结束于所在函数得结尾，与代码嵌套无关</li> <li>命名函数得作用域是指声明该函数得整个函数范围，与代码嵌套无关(提升机制)</li> <li>对于作用域声明，全局上下文就像一个包含页面所有代码的超大型函数</li></ul> <h4 id="作用域分为全局作用域-函数作用域-块级作用域"><a href="#作用域分为全局作用域-函数作用域-块级作用域" class="header-anchor">#</a> 作用域分为全局作用域,函数作用域,块级作用域</h4> <p>全局作用域:</p> <ul><li>最外层函数和在最外层函数外面定义得变量拥有全局作用域</li> <li>所有未定义直接赋值得变量自动声明为拥有全局作用域</li> <li>所有window对象得属性拥有全局作用域
弊端:如果我们写了很多行js代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会污染全局命名空间，容易引起命名冲突</li></ul> <p>函数作用域:是指声明在函数内部得变量，和全局作用域相反，局部作用域一般只在固定得代码片段内可访问到，最常见得例入函数内部</p> <div class="language- extra-class"><pre class="language-text"><code>function doSomething(){
    var blogName=&quot;浪里行舟&quot;;
    function innerSay(){
        alert(blogName);
    }
    innerSay();
}
alert(blogName); //脚本错误
innerSay(); //脚本错误
</code></pre></div><p>块级作用域:可通过新增命令let和const声明，所声明的变量在指定块的作用域外无法被访问</p> <p>特点:</p> <ul><li>声明变量不会提升到代码块顶部</li> <li>禁止重复声明</li> <li>循环中的绑定块作用域的妙用</li></ul> <h3 id="函数调用"><a href="#函数调用" class="header-anchor">#</a> 函数调用</h3> <p>方式:</p> <ul><li>作为一个函数进行调用，是最简单的形式</li> <li>作为一个方法进行调用，在对象上进行调用，支持面向对象编程</li> <li>作为构造器进行调用，创建一个新对象</li> <li>通过apply()或call()方法进行调用</li></ul> <h4 id="从参数到函数形参"><a href="#从参数到函数形参" class="header-anchor">#</a> 从参数到函数形参</h4> <p>当一个参数列表作为函数调用的一部分时，这些参数会按照函数声明里的形参声明顺序，将参数值分别赋值给这些形参。第一个参数赋值给第一个形参，第二个参数赋值给第二个形参，以次内推。
如果传入的参数个数和声明的形参数量不一致，不会抛错，JavaScript可以完美解决这种问题，具体处理策略如下:</p> <ul><li>如果实际传递的参数数量大于函数声明的形参数量，超出的参数则不会配给形参名称</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function whatever(a,b,c){...}
如果我们调用的时候执行whatever(1,2,3,4,5),参数1，2，3会分别赋值给a,b,c，而参数4和5则不会赋值给任何形参
</code></pre></div><ul><li>如果声明的形参数量大于实际传递的参数数量，则没有对应参数的形参会赋值为undfined</li></ul> <div class="language- extra-class"><pre class="language-text"><code>如果我们调用whatever(a,b,c)函数的时候执行whatever(1),则a会被赋值为1，而b和c则会被赋值为undefined
</code></pre></div><p>所有的函数调用都会传递两个隐式参数:arguments和this</p> <h4 id="arguments参数"><a href="#arguments参数" class="header-anchor">#</a> arguments参数</h4> <p>arguments参数是传递给函数的所有参数的一个集合。该集合有一个length属性，其值是全部参数的个数，单个参数值可以像访问数组索引一样进行获取，例如:arguments[2]则表示获取第三个参数</p> <p>但是请注意，要避免将arguments参数作为数组进行调用。不要误以为是一个数组。</p> <h4 id="this参数"><a href="#this参数" class="header-anchor">#</a> this参数</h4> <p>一个函数被调用时，除了传入了函数的显式参数以外,名为this的隐式参数也被传入了函数。this参数引用了与该函数调用进行隐式关联的一个对象，被称之为函数上下文。</p> <h4 id="作为函数进行调用"><a href="#作为函数进行调用" class="header-anchor">#</a> 作为函数进行调用</h4> <div class="language- extra-class"><pre class="language-text"><code>function ninja(){};
ninja();
vr samurai = function(){};
samurai();
</code></pre></div><p>以这种方式调用时，函数上下文是全局上下文----window对象。</p> <h4 id="作为方法进行调用"><a href="#作为方法进行调用" class="header-anchor">#</a> 作为方法进行调用</h4> <p>当一个函数被赋值给一个对象的一个属性，并使用引用该函数的这个属性进行调用时，那么函数就是作为该对象的一个方法进行调用的。</p> <div class="language- extra-class"><pre class="language-text"><code>var o={};
o.whatever = function(){};
o.whatever();
</code></pre></div><p><img src="/book/ff.png" alt="">
结果:
<img src="/book/fs.png" alt="">
注意:即便在上述所有这些例子中调用的都是相同的函数，其函数上下文也会随着函数调用方式的变化而变化，而不是取决于函数时怎么声明的</p> <h4 id="作为构造器进行调用"><a href="#作为构造器进行调用" class="header-anchor">#</a> 作为构造器进行调用</h4> <p>将函数作为构造器进行调用，我们要在函数调用之前使用new关键字。</p> <div class="language- extra-class"><pre class="language-text"><code>function creep(){return this;}
new creep();
</code></pre></div><h4 id="构造器的超能力"><a href="#构造器的超能力" class="header-anchor">#</a> 构造器的超能力</h4> <ul><li>创建一个新的空对象</li> <li>传递给构造器的对象是this参数，从而成为构造器的函数上下文</li> <li>如果没有显式的返回值，新创建的对象则作为构造器的返回值进行返回</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
//声明一个构造器，该构造器在函数上下文对象上创建一个skulk属性，该属性方法又返回了上下文自身，以便可以进行外部测试
function Ninja(){
    this.skulk = function(){return this;};
}
//通过new关键字调用构造器分别创建两个对象，新创建的对象分别被ninja1和ninja2进行引用
var ninja1 = new Ninja();
var ninja2 = new Ninja();
//对所构造出对象的方法进行测试，每个方法的返回值都应该是其构造对象本身
assert(ninja1.skulk()===ninja1,&quot;this 1st ninja is skulking&quot;);//this 1st ninja is skulking
assert(ninja2.skulk()===ninja2,&quot;this 2nd ninja is skulking&quot;);//this 2nd ninja is skulking
&lt;/script&gt;
</code></pre></div><h4 id="使用apply-和call-方法进行调用"><a href="#使用apply-和call-方法进行调用" class="header-anchor">#</a> 使用apply()和call()方法进行调用</h4> <p>函数方式之间的主要差异是:作为this参数传递给执行函数的上下文对象之间的区别;作为方法进行调用，该上下文是方法的拥有者;作为全局函数进行调用，其上下文永远是window;作为构造器进行调用，其上下文对象则是新创建的对象实例。</p> <h5 id="apply"><a href="#apply" class="header-anchor">#</a> apply()</h5> <p>传入两个参数:一个作为函数上下文的对象，另一个是作为函数参数所组成的数组。</p> <h5 id="call"><a href="#call" class="header-anchor">#</a> call()</h5> <p>使用方式类似，唯一不同的是，给函数传入的参数是是一个参数列表，而不是单个数组</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
//定义一个函数
function juggle(){
    var result = 0;
    for(var n=0;n&lt;arguments.length;n++){//收集参数
        result+=arguments[n];
    }
    this.result = result;//在上下文保存结果
}
//创建测试对象
var ninja1 = {};
var ninja2 = {};

juggle.apply(ninja1,[1,2,3,4]);//使用apply方法执行函数
juggle.call(ninja2,5,6,7,8);//使用call方法执行函数
//验证结果
assert(ninja1.result === 10,&quot;juggled via apply&quot;);//juggled via apply
assert(ninja2.result === 26,&quot;juggled via call&quot;);//juggled via call

&lt;/script&gt;
</code></pre></div><h2 id="挥舞函数"><a href="#挥舞函数" class="header-anchor">#</a> 挥舞函数</h2> <h3 id="匿名函数"><a href="#匿名函数" class="header-anchor">#</a> 匿名函数</h3> <p>匿名函数是一种在运行时动态声明的函数。他们之所以被成为匿名函数是因为不同于普通函数，他们并没有函数名。</p> <p>匿名函数时通过函数表达式而不是函数声明语法定义的。</p> <p>以下是一个典型的匿名函数：</p> <div class="language- extra-class"><pre class="language-text"><code> function flyToTheMoon()

{

 alert(&quot;Zoom! Zoom! Zoom!&quot;);

}

flyToTheMoon();
</code></pre></div><p>以下是同样的例子但此时是作为匿名函数被创建：</p> <div class="language- extra-class"><pre class="language-text"><code>var flyToTheMoon = function()

{

alert(&quot;Zoom! Zoom! Zoom!&quot;);

}

flyToTheMoon();
</code></pre></div><h4 id="匿名函数是被函数表达式创建的"><a href="#匿名函数是被函数表达式创建的" class="header-anchor">#</a> 匿名函数是被函数表达式创建的</h4> <p>在javascript中两种最常用的创建函数方式是利用函数声明语法和函数表达式。匿名函数是通过函数表达式创建的。</p> <p>在语句中如果function关键字首先出现并紧跟一个函数名，那么这个函数则是由函数声明语法创建的:</p> <p><img src="/book/nm1.png" alt=""></p> <p>如果function关键字出现在其他地方，则很可能是被用作函数表达式：</p> <p><img src="/book/nm2.png" alt=""></p> <p>当函数表达式被调用时，它创建一个新的函数对象并返回它。这里是一个创建函数并将其赋给一个名为flyToTheMoon的变量的例子:</p> <div class="language- extra-class"><pre class="language-text"><code>var flyToTheMoon = function() {

 alert(&quot;Zoom! Zoom! Zoom!&quot;);

}
</code></pre></div><p>这里的赋值跟将任意函数的返回值赋值给变量是几乎一样的，唯一特殊的地方是这个值是一个函数对象而不是一些简单的数字或者日期。</p> <p>这是可能的，因为函数在javascript中只是一种特殊的对象。这意味着它们能像其他对象一样被使用。它们可以被存储在变量中，作为参数被传递到其他函数，抑或在函数中被return语句返回。函数永远是对象，无论它们是如何被创建出来的。</p> <h4 id="匿名函数在运行时被创建"><a href="#匿名函数在运行时被创建" class="header-anchor">#</a> 匿名函数在运行时被创建</h4> <p>函数表达式可以被用在任意一个可以放置表达式的地方。例如，你可以在一个变量被赋值时运用函数表达式，在一个参数被传递到函数或者在一个return语句中运用函数表达式。这是可能的，因为函数永远是在运行时被调用的。</p> <p>函数声明语法则不一样。它们运行在任何其他代码被执行之前，因为函数在被代码调用之前不需要声明。</p> <p>函数声明语法不能被用于创建匿名函数，因为它们要求函数有一个名字。函数声明语法利用函数名在将其作为一个变量添加到当前作用域中。</p> <h3 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h3> <p>当函数调用自身，或调用另外一个函数，但是这个函数的调用树中的某个地方又用了自己时，递归就发生了。</p> <h4 id="普通命名函数中的递归"><a href="#普通命名函数中的递归" class="header-anchor">#</a> 普通命名函数中的递归</h4> <p>很多常见的递归函数实例。其中一个是用于检查回文的----相当于递归计数的&quot;Hello world!&quot;。</p> <p>通过理由回文的更多数学定义，我们可以想出一个更简洁的解决方案。这些定义如下所示。</p> <ul><li>单个和零个字符都是一个回文。</li> <li>如果字符串的第一个字符和最后一个字符相同，并且除了两个字符以外剩余的其他字符串也是一个回文的话，我们称原字符串是一个回文。</li></ul> <p>基于该定义的代码实现如下:</p> <div class="language- extra-class"><pre class="language-text"><code>function isPalindrome(text){
    if(text.length&lt;=1)return true;
    if(text.charAt(0)!=text.charAt(text.length-1))return false;

    return isPalindrome(text.substr(1,text.length-2));
}
</code></pre></div><p>注意，上述新定义及实现都是递归的，因为它使用回文的定义来确定一个字符串是否是回文。实现很简单，我们在函数的最后一行递归调用函数自身。</p> <h4 id="方法中的递归"><a href="#方法中的递归" class="header-anchor">#</a> 方法中的递归</h4> <p>我们通过声明一个digi函数并将其作为ninja对象的方法来完成这个人物。这使得事情变得有点复杂，因为会将递归函数变成一个匿名函数赋值给对象的一个属性，代码示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>var ninja = {
    //声明一个chirp递归函数，将其作为ninja对象的一个属性。现在我们可以通过引用该对象的方法来调用方法本身
    chirp:function(n){
        return n&gt;1?ninja.chirp(n-1)+&quot;-chirp&quot;:&quot;chirp&quot;;
    }
}
assert(ninja.chirp(3)==&quot;chirp-chirp-chirp&quot;,&quot;An object property isn't too confusing,either.&quot;);
</code></pre></div><p>在上述测试中，我们将递归函数定义成一个匿名函数，并将其引用到ninja对象的chirp属性。在该函数内，我们通过对象的ninja.chirp()属性递归调用了函数自身。</p> <p><img src="/book/1.png" alt=""></p> <h4 id="引用的丢失问题"><a href="#引用的丢失问题" class="header-anchor">#</a> 引用的丢失问题</h4> <div class="language- extra-class"><pre class="language-text"><code>var ninja = {
    chirp:function(n){
        return n&gt;1?ninja.chirp(n-1)+&quot;-chirp&quot;:&quot;chirp&quot;;
    }
}
//在samurai上创建一个chirp()函数，并引用ninja上的现有同名方法。代码实现都有了，为何要写两次呢
var samurai = {chirp:ninja.chirp};
//重新定义ninja对象，去除所有的属性。也就是说chirp属性已经没有了
ninja = {};
//测试一下运行是否正常。提示:不是
try {
    assert(samurai.chirp(3)==&quot;chirp-chirp-chirp&quot;,&quot;Is this going to work?&quot;);
} catch (e) {
    assert(false,&quot;Uh,this isn't good!Where'd ninja.chirp go?&quot;);
}
</code></pre></div><p><img src="/book/2.png" alt=""></p> <p>两个对象引用相通的函数，但是函数引用自身的时候只是通过其中一个对象。有问题</p> <p>所以，如果ninja消失的话，会发生什么呢？samurai会持有该匿名函数吗？为了验证这一点，我们重新给ninja对象定义一个空对象。匿名函数仍然存在，而且可以通过samurai.chirp属性进行引用，但是ninja.chirp属性却已经不复存在了。而该函数是通过原有的ninja.chirp属性引用进行递归调用自身的，所以函数在调用的时候会出现很严重的问题</p> <p>通过完善原本对递归函数的粗略定义，我们可以修复解决这个问题。在匿名函数中不在使用显式的ninja引用，而是使用函数上下文(this)进行引用，如下:</p> <div class="language- extra-class"><pre class="language-text"><code>var ninja = {
    chirp:function(n){
        return n&gt;1?this.chirp(n-1)+&quot;-chirp&quot;:&quot;chirp&quot;;
    }
}
</code></pre></div><p>记住，当一个函数作为方法被调用时，函数上下文指的是调用该方法的对象。调用ninja.chirp()时，this对象引用的时ninja，而调用samurai.chirp()时，this对象引用的则是samurai，都很好用。</p> <h4 id="内联命名函数"><a href="#内联命名函数" class="header-anchor">#</a> 内联命名函数</h4> <div class="language- extra-class"><pre class="language-text"><code>var ninja = {
    chirp:function signal(n){//定义一个命名内联函数
        return n&gt;1?signal(n-1)+&quot;-chirp&quot;:&quot;chirp&quot;;
    }
}
//测试是否按预期执行
assert(ninja.chirp(3)==&quot;chirp-chirp-chirp&quot;,&quot;Works as we would expect it to!&quot;);
//创建一个新对象
var samurai = {chirp:ninja.chirp};
//情况ninja对象
ninja = {};
//测试是否按预期执行。确实是按预期执行了
assert(samurai.chirp(3)==&quot;chirp-chirp-chirp&quot;,&quot;The method correctly calls itself.&quot;);
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>验证内联函数的标识

//声明一个命名内联函数，并将其赋值给一个变量
var ninja = function myNinja(){
    //在内联函数中，验证两个名字是等价的
    assert(ninja == myNinja,&quot;This function is named two things at once!&quot;);
}
//调用函数执行内部的验证
ninja();
//验证内联函数的名称在内联函数外部是不可用的
assert(typeof myNinja == &quot;undefined&quot;,&quot;But myNinja isn't defined outside of the function&quot;);
</code></pre></div><p>上述代码展示了内联函数最重要的一点:尽管可以给内联函数进行命名，但这些名称只能在自身函数内部才是可见的。内联函数的名称和变量名称有点像，它们的作用域仅限于声明它们的函数。</p> <p>注意:这就是为什么要将全局函数作为window的方法进行创建的原因。不使用window的属性，我们没有办法引用这些函数。</p> <h4 id="callee属性"><a href="#callee属性" class="header-anchor">#</a> callee属性</h4> <p>警告:callee属性在即将到来的新版JavaScript上会被去除，而且ECMAScript5标准在strict模式下也禁止使用该属性了。不过，在当前浏览器中还是可以使用该属性的，但它的使用不具前瞻性，我们可能不希望在新代码中使用callee。然而，我们在这里继续讲解它，是因为搭建可能在代码中遇到它。</p> <div class="language- extra-class"><pre class="language-text"><code>var ninja = {
    chirp:function(n){
        //引用arguments.callee属性
        return n&gt;1?arguments.callee(n-1)+&quot;-chirp&quot;:&quot;chirp&quot;;
    }
}
//验证代码可以按预期执行
assert(ninja.chirp(3)==&quot;chirp-chirp-chirp&quot;,&quot;arguments.callee is the function itself.&quot;);
</code></pre></div><p>参数arguments是隐式传递给每一个函数的，arguments有一个callee属性，callee属性引用的是当前所执行的函数。该属性可以作为一个可靠的方法引用函数自身。</p> <h3 id="将函数视为对象"><a href="#将函数视为对象" class="header-anchor">#</a> 将函数视为对象</h3> <p>先从将函数赋值给变量开始:</p> <div class="language- extra-class"><pre class="language-text"><code>var obj = {};
var fn = function(){};
assert(obj&amp;&amp;fn,&quot;Both the object and function exist.&quot;);
</code></pre></div><p>与可以将对象赋值给变量一样，我们也可以将函数赋值给变量。同样，也可以将函数赋值给对象的一个属性，从而创建一个方法。</p> <p>注意:要记住一个重要的事情是:function(){}定义后面的分号。在所有语句结束时，使用分号是一个很好的做法，尤其是在变量赋值之后，匿名函数也不例外。压缩代码时，分号的妥善放置会为压缩技术提供更大的灵活性。</p> <p>另外一个可能会让我们惊讶的函数特性是，和其他对象一样，我们可以给函数添加属性：</p> <div class="language- extra-class"><pre class="language-text"><code>var obj={};
var fn=function(){};
obj.prop=&quot;hitsuke(distraction)&quot;;
fn.prop=&quot;tanuki(climbing)&quot;;
</code></pre></div><h4 id="函数存储"><a href="#函数存储" class="header-anchor">#</a> 函数存储</h4> <div class="language- extra-class"><pre class="language-text"><code>var store = {
    nextId:1,//持续跟踪要赋值的nextId
    cache:{},//创建一个对象作为缓存，用于存储函数
    add:function(fn){//向缓存中添加函数，但只有缓存不存在的情况下才能添加成功
    if(!fn.id){
        fn.id = store.nextId++;
        return !!(store.cache[fn.id]=fn);
    }
    }
};
function ninja(){}
//测试是否按预期进行
assert(store.add(ninja),&quot;Function was safely added.&quot;);

assert(!store.add(ninja),&quot;But it was only added once.&quot;);


输出:
Function was safely added.
But it was only added once.
</code></pre></div><p>在上述代码中，我们创建一个对象并赋值给store变量，我们将在该对象里储存一组独立得函数。该对象有两个数据属性:一个用于储存下一个可用得id值，另一个cache用于存储函数。函数是通过add()方法添加cache中得。</p> <p>在add()中，我们首先检测要添加得函数是否有一个id属性，如果有，则表示函数已经被处理过，那就忽略它。如果没有，我们就给函数分配一个id属性(其值是一直自增得nextId)，然后将该函数作为cache得一个属性添加进来，同时使用id作为属性名称。</p> <p>然后通过将函数转换为等效得布尔函数，我们返回了true，以便知道在调用add()之后，函数是否成功添加进去.</p> <h4 id="自记忆函数"><a href="#自记忆函数" class="header-anchor">#</a> 自记忆函数</h4> <p>缓存记忆是构建函数得过程，这种函数能够记住先前计算得结果。通过避免已经执行过得不必要复杂计算，这种方式可以显著提高性能。</p> <div class="language- extra-class"><pre class="language-text"><code> &lt;script&gt;
    function isPrime(value){
        if(!isPrime.anwers) isPrime.anwers = {};//创建缓存
        //检查缓存过的值
        if(isPrime.anwers[value]!=null){
            return isPrime.anwers[value];
        }

        var prime = value !=1;

        for(var i = 0;i&lt;value;i++){
            if(value%1==0){
                prime = false;
                break;
            }
        }
        //保存计算出得值
        return isPrime.anwers[value] = prime;
    }
    assert(isPrime(5),'5 is prime!');
    assert(isPrime.anwers(5),'The answer was cached!');
&lt;/script&gt;
</code></pre></div><p>缓存记忆有两个主要优点:</p> <ul><li>在函数调用获取之前计算结果得时候，最终用户享有性能优势。</li> <li>发生在幕后，完全无缝，最终用户和页面开发人员都无需任何</li></ul> <p>但是，这种方式并不完全都是鲜花和掌声，与优点相比，也需要权衡一下缺点:</p> <ul><li>为了提高性能，任何类型得缓存肯定会牺牲掉内存。</li> <li>纯粹主义者可能认为缓存这个问题不应该与业务逻辑放在一起，一个函数或者方法应该只做一件事，并把它做好。</li> <li>很难测试或测量一个算法得性能</li></ul> <h4 id="伪造数组方法"><a href="#伪造数组方法" class="header-anchor">#</a> 伪造数组方法</h4> <p>有时，我们可能想创建一个包含一组数据得对象。如果只是集合，则只需要创建一个数组即可。但在某些情况下，除了集合本身，可能会有更多得状态需要保存----比如与集合项有关得一些元数据。</p> <p>一种选择可能是，每次创建对象新版本得时候都创建一个新数组，然后将元数据作为属性或方法添加到这个新数组上----记住，我们可以为任何对象添加属性和方法，包括数组。不过，一般来说这种方式太慢了，更不用说乏味了。</p> <p>模拟类似数组得方法:</p> <div class="language- extra-class"><pre class="language-text"><code> &lt;input id=&quot;first&quot;/&gt;
&lt;input id=&quot;second&quot;/&gt;
&lt;script&gt;
    var elems = {
        //保存元素得个数，如果我们要假装成是数组，那就需要保存元素项得个数
        length:0,
        add:function(elem){
        //实现将元素添加到集合方法。Array得原型中得一个方法可以做到，那为什么不直接用呢
        Array.prototype.push.call(this,elem);
        },
        gather:function(id){
        //实现一个gather()方法，根据id值查找元素，并将其添加到集合中
        this.add(document.getElementById(id));
        }
    }
    elems.gather('first');
    assert(elems.length == 1&amp;&amp;elems[0].nodeType,&quot;Verify that we have an elment in our stash&quot;);
    elems.gather('second');
    assert(elems.length == 2&amp;&amp;elems[1].nodeType,&quot;Verify the other insertion&quot;);

&lt;/script&gt;
</code></pre></div><h3 id="可变长度得参数列表"><a href="#可变长度得参数列表" class="header-anchor">#</a> 可变长度得参数列表</h3> <h4 id="使用apply-支持可变参数"><a href="#使用apply-支持可变参数" class="header-anchor">#</a> 使用apply()支持可变参数</h4> <p>我们平时使用call()和apply()方法是作为所有函数得方法存在得----甚至是内置得JavaScript函数。</p> <div class="language- extra-class"><pre class="language-text"><code> &lt;script&gt;
    function smallest(array) {
        //实现一个查找最小值
        return Math.min.apply(Math,array );
    }
    function largest(array) {
        //实现一个方法查找最大值
        return Math.max.apply(Math,array);
    }
    assert(smallest([0,1,2,3]) == 0,&quot;Located the smallest value.&quot;);
    assert(largest([0,1,2,3]) == 3,&quot;Located the largest value.&quot;);
&lt;/script&gt;
</code></pre></div><p>上述代码中我们要注意，这两个函数是如何使用apply方法将数组作为可变长度参数进行接收，并传递给Math函数得</p> <h4 id="函数重载"><a href="#函数重载" class="header-anchor">#</a> 函数重载</h4> <p>所有的函数都隐式传递了arguments这一重要参数，这将使得函数有能力处理任意数量得参数。即使我们只定义固定数量得形参，通过arguments参数我们还是总是能够访问到传递给函数得所有参数。</p> <h4 id="检测并遍历参数"><a href="#检测并遍历参数" class="header-anchor">#</a> 检测并遍历参数</h4> <p>在JavaScript中，我们重载函数得时候只用一个实现，只不过这个实现内部是通过传入参数得特性和个数进行相应修改来达到目的得。</p> <p>遍历可变长度得参数列表:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    //实现一个merge()函数
    function merge(root){
        for(var i = 1;i&lt;arguments.length;i++){
            for(var key in arguments[i]){
                root[key] = arguments[i][key];
            }
        }
        return root;
    }
//   调用merge()函数
    var merged = merge(
    {name:&quot;Batou&quot;}, 
    {city:&quot;Niihama&quot;}
    );
    assert(merged.name == &quot;Batou&quot;,&quot;The original name is intact&quot;);
    assert(merged.city == &quot;Niihama&quot;,&quot;And the city has been coyied over&quot;);
&lt;/script&gt;
</code></pre></div><p>关于merge()函数，我们会注意到它的签名里声明了一个参数:root。这并不意味着调用得时候，我们只能传入一个参数。于此相反，实际上，我们在调用merge()得时候可以传入任意数量得参数，也可以什么都不传。</p> <p>在JavaScript中，没有强制函数声明多少个参数就得传入多少个参数。函数是否可以成功处理这些参数完全取决于函数本身得定义，不过在这方面JavaScript并没有强加规则。实际上，函数在只定义一个参数root时，意味着只能用root这个名称访问所传入参数得其中一个----第一个。</p> <div class="language- extra-class"><pre class="language-text"><code>要检测对应于已经命名得形参得参数是否传入，可以使用表达式:paramname === undefined,如果没有对应得参数，则返回true。
</code></pre></div><p>arguments参数指向得是所有传入参数得集合。</p> <p>记住，我们要做的事情，是想第二个甚至第n个参数上得属性合并到传入得root对象(第一个参数)中。所以，在遍历列表中的参数时，为了跳过第一个参数，索引要从1开始。</p> <p>每次遍历时，被遍历项目就是传递给函数得一个对象，然后遍历传入对象得所有属性，并将这些属性复制到root对象上。</p> <p>现在应该很明显了，访问和遍历arguments集合特性是一种创建复杂且智能方法得强大机制。我们可以用他来检查任意函数得传入参数，以便让函数更灵活的操作这些参数，即使我们事先不知道所要传入得参数到底是什么。</p> <h4 id="对arguments列表进行切片-slice-和取舍-dice"><a href="#对arguments列表进行切片-slice-和取舍-dice" class="header-anchor">#</a> 对arguments列表进行切片(slice)和取舍(dice)</h4> <p>我们将构建一个函数，将第一个参数与剩余参数得最大值进行进行相乘。这可能不是特别适用于应用程序，但是它展示更多处理arguments参数技术得例子。</p> <p>首先获取第一个参数，然后将其与剩余参数上调用Math.max()函数得结果进行相乘。由于给Math.max()传递的参数要从数组得第二个元素开始，所以这里，我们使用数组得slice()方法重新创建一个省略了第一个元素得新数组。</p> <p>对arguments列表进行切片</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    function multiMax(multa){
        //欺骗slice()方法，将其在arguments列表上使用，该参数列表不是一个真正得数组实例
        return multa*Math.max.apply(Math, Array.prototype.slice.call(arguments,1));
    }

    assert(multiMax(3,1,2,3) == 9,&quot;3*3=9(First arg,by largest)&quot;);
&lt;/script&gt;
</code></pre></div><p>在代码中，强制Array得slice()方法将arguments参数视为一个真正的数组，即便他不是。</p> <h4 id="函数重载方法"><a href="#函数重载方法" class="header-anchor">#</a> 函数重载方法</h4> <p>定义一个函数重载时----基于传递得参数定义一个有很多不同功能得函数----很容易想象，根据我们所学得这种机制，检查参数列表并使用if-then或else-if字句执行不同得行为，我们可以很容易实现一个函数。</p> <h4 id="函数的length属性"><a href="#函数的length属性" class="header-anchor">#</a> 函数的length属性</h4> <p>所有得函数都一个有趣得属性，它并不为人知，但却让我们可以了解函数的声明，那就是length属性。不要将该属性和arguments参数得length属性弄混淆了。该属性得值等于该函数声明时所需要传入得形参数量。</p> <p>因此，如果声明一个接收单个参数得函数，那这个函数得length属性值就应该是1.</p> <div class="language- extra-class"><pre class="language-text"><code>function makeNinja(name){}
function makeSamurai(name,rank){}
assert(makeNinja.length == 1,&quot;Only expecting a single argument&quot;);
assert(makeSamurai.length == 2,&quot;Two arguments expected&quot;);
</code></pre></div><p>对于一个函数，在参数方面，我们可以确定两件事:</p> <ul><li>通过其length属性，可以知道声明了多少命名参数。</li> <li>通过arguments.length,可以知道在调用时传入了多少参数</li></ul> <h4 id="利用参数个数进行函数重载"><a href="#利用参数个数进行函数重载" class="header-anchor">#</a> 利用参数个数进行函数重载</h4> <p>基于传入得参数，有很多中方法可以判断并进行函数重载。一种通用得方法是，根据传入参数得类型执行不同得操作。另一种方法是，可以通过某些特定参数是否存在来进行判断。还有一种方法是通过传入参数得个数进行判断</p> <p>假设在对象上有一个方法，根据传入参数得个数执行不同得操作。如果想要冗长且完整得函数，则会像如下这样:</p> <div class="language- extra-class"><pre class="language-text"><code>var ninja = function(){
    whatever:function(){
        switch(arguments.length){
            case 0:
                break;
            case 1:
                break;
            case 2:
                break;
            //...
        }
    }
}
</code></pre></div><p>在这种方式中，通过arguments参数获取实际传入得参数个数进行判断，每一种情况都会执行不同得操作。</p> <p>让我们假设另一种方法：</p> <div class="language- extra-class"><pre class="language-text"><code>var ninja = {};
addMethod(ninja,'whatever',function(){});
addMethod(ninja,'whatever',function(a){});
addMethod(ninja,'whatever',function(a,b){});

function addMethod(object,name,fn) {
    //保存原有函数,因为调用得时候可能不匹配传入得参数个数
    var old = object[name];
    //创建一个新匿名函数作为新方法
    object[name] = function() {
        //如果该匿名函数得形参个数和实数个数匹配，就调用该函数
        if(fn.length==arguments.length)
            return fn.apply(this,arguments);
        //如果传入得参数不匹配，则调用原有得参数
        else if (typeof old === &quot;function&quot;)
            return old.apply(this,arguments);
    }
}

</code></pre></div><p>addMethod()函数接收了三个参数:</p> <ul><li>要绑定方法得对象</li> <li>绑定方法所用的属性名称</li> <li>要绑定的方法
让我们在来看一下实例:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var ninja = {};
addMethod(ninja,'whatever',function(){});
addMethod(ninja,'whatever',function(a){});
addMethod(ninja,'whatever',function(a,b){});
</code></pre></div><p>addMethod()的第一次调用将创建一个新匿名函数，传入零个参数进行调用的时候将会调用该fn函数。由于此时ninja是一个新对象，所以这时候不用担心之前创建的方法。</p> <p>第二次调用addMethod()的时候，首先将之前的同名函数保存到一个变量old中，然后将新创建的匿名函数作为方法。新方法首先检查传入的函数个数是否为1，如果是，就调用刚才传入的fn函数，如果不是，则重新调用存储在old上的函数，重新调用该函数时，将会再次检查参数个数是否为零，继而调用参数个数为零的fn版本函数。</p> <p>第三次调用addMethod()的时候，传入了一个接收两个参数的fn函数，然后判断逻辑相同:创建一个匿名函数作为方法，判断如果传入参数的个数为2个，则调用2个参数的fn函数，并推迟之前创建的1个参数的函数。</p> <p>测试addMethod()函数:</p> <div class="language- extra-class"><pre class="language-text"><code>// 创建一个基础对象，实现加载一些测试数据
var ninjas = {
    values:['Dean Edwards','Sam Stephenson','Alex Russell']
};
//在基础对象上绑定一个无参数方法
addMethod(ninjas,'find',function(){
    return this.values;
});
//在基础对象上绑定一个单参数的方法
addMethod(ninjas,'find', function(name){
    var ret = [];
    for(var i = 0; i &lt; this.values.length; i++){
        if (this.values[i].indexOf(name)==0) {
            ret.push(this.values[i]);
        }
    }
    return ret;
});
//在基础对象上绑定两个参数的方法
addMethod(ninjas,'find', function(first,last) {
    var ret = [];
    for(var i = 0; i &lt; this.values.length; i++){
        if (this.values[i] == (first+&quot; &quot;+last)) {
            ret.push(this.values[i]);
        }
    }
    return ret;
});

assert(ninjas.find().length==3,&quot;Found all ninjas&quot;);//Found all ninjas
assert(ninjas.find(&quot;Sam&quot;).length==1,&quot;Found ninjas by first name&quot;);//Found ninjas by first name
assert(ninjas.find(&quot;Dean&quot;,&quot;Edwards&quot;).length==1,&quot;Found ninjas by first and last name&quot;);//Found ninjas by first and last name
assert(ninjas.find(&quot;Alex&quot;,&quot;Russell&quot;,&quot;Jr&quot;).length==null,&quot;Found nothing&quot;);//Found nothing

</code></pre></div><p>以上是我们声明并绑定的三个版本的find()方法。</p> <ul><li>第一次方法期待没有参数，并返回所有的ninja。</li> <li>第二个方法期望接收一个参数，并返回所有以传入文本开头的ninja</li> <li>第三个方法期望接收两个参数，返回姓氏和名字都匹配所传入字符串参数的ninja</li></ul> <p>这是一个绝佳的技巧，因为这些绑定函数实际上并没有存储于任何典型的数据结构中，而是在闭包里作为引用进行存储。</p> <p>应该注意的是，在使用这个特定的技巧时，需要注意一下几点:</p> <ul><li>重载只适用于不同数量的参数，但并不区分类型，参数名称或其他东西。这些才是我们经常想做的事情。</li> <li>这样的重载方法会有一些函数调用开销，我们要需要考虑在高性能时的情况</li></ul> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <h3 id="闭包是如何工地作的"><a href="#闭包是如何工地作的" class="header-anchor">#</a> 闭包是如何工地作的</h3> <p>简单的说，闭包时一个函数在创建时允许该自身函数访问并操作该自身函数之外的变量时所创建的作用域。换句话说，闭包可以让函数访问所有的变量和函数，只要这些变量和函数存在于该函数声明时的作用域内就行。</p> <p>听起来似乎是很直观的，要记住，声明的函数在后续什么时候都可以被调用，即便是声明时的作用域消失之后。</p> <p>实现一个简单的闭包:</p> <div class="language- extra-class"><pre class="language-text"><code>//在全局作用域内声明一个变量
var outerValue = &quot;ninja&quot;;
function outerFunction(){
    //在全局作用域内声明一个函数
    assert(outerValue=='ninja',&quot;I can see the ninja&quot;);
}
//执行该函数
outerFunction();
</code></pre></div><p>外部变量和外部函数都是在全局作用域内声明的，该作用域(实际上就是一个闭包)从未消失过(因为页面已经被加载了)，不足为奇，该函数可以访问到外部变量，因为它仍在作用域内并且是可用的。</p> <div class="language- extra-class"><pre class="language-text"><code>//在全局作用域内声明一个变量
var outerValue = &quot;ninja&quot;;
var later;
function outerFunction(){
    //在函数内部声明一个值。该变量的作用域是限制在该函数内部，并且在函数外部访问不到
    var innerValue = 'samurai';
    function innerFunction(){

        //在全局作用域内声明一个函数
        assert(outerValue,&quot;I can see the ninja&quot;);
        assert(innerValue,&quot;I can see the samurai&quot;);
    }
    //将内部函数引用到later变量上。由于later在全局作用域内，所以我们可以对它进行调用
    later = innerFunction;
}
//调用外部函数，将会声明内部函数，并将内部函数赋值给later变量
outerFunction();
//通过later调用内部函数，我们不能直接调用内部函数，因为它的作用域(和innerValue一起)被限制在outerFunction()内
later();
</code></pre></div><p>通过以上代码，在外包函数中声明innferFunction()的时候，不仅是声明了函数，还创建了一个闭包，该闭包不仅包含函数声明，还包含了函数声明的那一时刻点上该作用域中的所有变量。</p> <p>最终当innerFunction()执行的时候，当时声明的作用域已经消失了，通过闭包，该函数还是能够访问到原始作用域的,如图:</p> <p><img src="/book/1599577287591.jpg" alt="">;</p> <p>这就是我们所说的闭包。如果我们愿意，针对在函数声明那一时刻点的作用域内的所有函数和变量，闭包创建了一个&quot;安全气泡&quot;，因此函数获得了执行操作所需的所有东西。</p> <p>这种&quot;气泡&quot;，包含了函数及其变量，和函数本身停留在一起。</p> <div class="language- extra-class"><pre class="language-text"><code>//闭包可以访问到什么内容
var outerValue = &quot;ninja&quot;;
var later;
function outerFunction(){
    var innerValue = 'samurai';
    //为内部函数添加一个参数
    function innerFunction(paramValue){
        //测试是否可以访问到该参数，并且测试闭包是否包括在函数声明后在声明的变量
        assert(outerValue,&quot;Inner can see the ninja&quot;);
        assert(innerValue,&quot;Inner can see the samurai&quot;);
        assert(paramValue,&quot;Inner can see the wakizashi&quot;);
        assert(tooLate,&quot;Inner can see the ronin&quot;);
        
    }
    later = innerFunction;
}
//检查作用域外的值。该测试是失败还是通过
assert(!tooLate,&quot;Outer can't see the ronin&quot;);
//在内部函数声明后，在声明一个变量值
var tooLate = &quot;ronin&quot;;
outerFunction();
//调用内部函数，运行上述测试。你得期望结果是什么
later('wakizashi');

//Outer can't see the ronin
//Inner can see the ninja
//Inner can see the samurai
//Inner can see the wakizashi
//Inner can see the ronin
</code></pre></div><p>测试结果说明了三个关于闭包的更有趣概念。</p> <ul><li>内部函数的参数是包含在闭包中的</li> <li>作用域之外的所有变量，即便是函数声明之后哪些声明，也都包含在闭包中。</li> <li>相同的作用域内，尚未声明的变量不能进行提前引用。</li></ul> <p>闭包非常有用，但它们的使用并非完全没有开销。使用闭包时，闭包里的信息会一直保存在内存里，知道这些信息确保不在被使用(可以安全进行垃圾回收)，或页面卸载时，JavaScript引擎才有清理这些信息。</p> <h3 id="使用闭包"><a href="#使用闭包" class="header-anchor">#</a> 使用闭包</h3> <h4 id="私有变量"><a href="#私有变量" class="header-anchor">#</a> 私有变量</h4> <p>闭包的一种常见用法是封装一些信息作为&quot;私有变量&quot;----也就是说，限制这些变量的作用域。在编写面向对象的JavaScript代码时，是无法使用传统的私有变量:对象的属性对外保持隐藏。但通过使用闭包，我们可以实现一个可接受的类似功能，代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个Ninja构造器
function Ninja() {
    //在该函数(构造器)内声明一个变量。由于该变量的作用域被限制在构造器内，
    //所以它是一个私有变量。我们使用该变量计算ninja佯攻了多少次
    var feints = 0;
    //创建一个访问feints计数的方法。由于该变量在构造器内部无法被访问，这是通过只读形式访问该变量的一个常用方法吧
    this.getFeints = function (){
        return feints;
    }
    //为feints计数声明一个累加器方法。由于该变量是私有的，
    //在外面是无法对其进行增加的，我们通过一个方法对其进行限制访问
    this.feints = function (){
        feints++;
    }
}
var ninja = new Ninja();
ninja.feints();
//验证我们不能直接获取该变量值
assert(ninja.getFeints==1,&quot;We're able to access the internal feint count.&quot;);
//代码显示，即便我们没有对该变量直接赋值，通过方法我们将变量增加到1了。我们可以操作feints的值，
//是因为即便是该构造器执行完并且已经没有作用域了，feints变量还是会绑定在feint()方法声明创建
//的闭包上，并且可以在feint()方法内进行使用
assert(ninja.getFeints==undefined,&quot;And the private data is inaccessible to us.&quot;);

</code></pre></div><p>通过上述测试代码显示，可以通过存取方法获取私有变量的值，但是不能直接访问私有变量。这有效的阻止了我们不能控制的变量修改，就像它是完全面向对象语言中的一个私有变量一样。</p> <h4 id="回调-callback-与计时器-timer"><a href="#回调-callback-与计时器-timer" class="header-anchor">#</a> 回调(callback)与计时器(timer)</h4> <p>另外一个使用闭包的最常见情形，是在处理回调或使用计数器的时候。在这两个情况下，函数都是在后期未指定的时间进行异步调用，在这种函数内部，我们常见需要访问外部数据。</p> <p>闭包可以作为一种访问这些数据的很直观的方式，特别是当我们希望避免创建全局变量来存储这些信息时。让我们来看一下简单的例子，使用jQuery库进行Ajax请求，代码如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;testSubject&quot;&gt;&lt;/div&gt;
&lt;button type=&quot;button&quot; id=&quot;testButton&quot;&gt;&lt;/button&gt;
&lt;script&gt;
    //为测试按钮创建一个click处理程序。按钮单击的时候，传递给click()方法的函数就会被执行
    jQuery('#testButton').click(function() {
        //在函数内部的开始处，声明一个elem$变量，改变量包含一个&lt;div&gt;元素的引用
        var elem$ = jQuery(&quot;#testSubject&quot;);
        //预先给&lt;div&gt;加载一些文本，以便让用户知道，正在进行处理
        elem$.html(&quot;Loading...&quot;);
        jQuery.ajax({
            url:&quot;test.html&quot;,
            success: function(html) {
                //在给jQuery的ajax()方法传递的参数列表中，我们定义了一个响应返回时调用的一个回调。
                //响应文本就是传递给回调的html参数，我们通过闭包内的elem$变量将文本诸如到&lt;div&gt;元素中
                assert(elem$,&quot;We can see elem$,via the closure for this callback.&quot;);
                elem$.html(html);
            }
        });
    });
&lt;/script&gt;
</code></pre></div><p>提示:使用$符号作为变量的后缀或前缀，是一个jQuery约定，用于表明该变量引用的是jQuery对象。</p> <p>在计数器间隔回调中使用闭包:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 创建一个需要展示动画的元素 --&gt;
&lt;div id=&quot;box&quot;&gt;动画&lt;/div&gt;

&lt;script&gt;
    function animateIt(elementId) {
        //在animateIt()函数中，获取对该元素的引用
        var elem = document.getElementById(elementId);
        //创建一个计时器，持续最终动画次数
        var tick = 0;
        //创建并启动一个interval计时器，该计时器内传入一个每隔10ms就执行一次的callback函数
        //在动画执行到第100次时，调整该元素的位置
        var timer = setInterval(function(){
            if (tick&lt;100) {
                elem.style.left = elem.style.top = tick + 'px';
                tick++;
            }else{
                clearInterval(timer);
                //100次之后，停止计时器，并执行测试，验证我们还能看到所有与执行动画相关的变量
                assert(tick == 100,&quot;Tick accessed via a closure&quot;);
                assert(timer,&quot;Timer reference also obtained via a closure&quot;);
            }
        },10);
    }
    //至此一起准备妥当，开始执行
    animateIt('box');
&lt;/script&gt;
</code></pre></div><p>上述代码的重要作用是，它使用一个独立的匿名函数完成特定元素的动画效果。通过闭包，该函数使用三个变量控制动画过程。</p> <p>这三个变量(DOM元素的引用，tick计数器，计时器引用)都必须要维持整个动画过程，并且需要能在全局作用域内访问到。</p> <p>但是为什么呢？如果我们将这些变量从animateIt()函数移出到全局作用域，动画实例仍然能正常工作。为什么不才去行动污染全局作用域呢？</p> <p>继续，将这些变量放到全局作用域呢，然后验证示例是否正常运行。现在，修改示例代码，给两个元素设置动画:在添加一个有唯一ID的元素，在第一个动画调用以后，再次调用animateIt()方法，并传入这个新ID。</p> <p>问题马上出现了，如果我们在全局作用域内保存变量，那么需要为每个动画设置三个变量----否则，用三个变量来跟踪多个动画的状态，那状态就会串了。</p> <p>通过在函数内部定义变量，并依赖闭包，可以将它们在计时器回调函数调用的时候进行使用，这样，每个动画都有自己的私有&quot;气泡&quot;变量了，如图</p> <p><img src="/book/1599643394411.jpg" alt=""></p> <p>没有闭包，同时做多件事情的时候，无论是事件处理，还是动画，甚至是Ajax请求，都将是及其困难的。如果大家一直想知道关注闭包的理由，那么这就是理由。</p> <p>函数在闭包里执行的时候，不仅可以在闭包创建的时刻点上看到这些变量的值，我们还可以对齐进行更新。换句话说，闭包不是在创建那一时刻点的状态快照，而且一个真实的状态封装，只要闭包存在，就可以对其进行修改。</p> <h3 id="绑定函数上下文"><a href="#绑定函数上下文" class="header-anchor">#</a> 绑定函数上下文</h3> <p>给函数绑定一个特定的上下文</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 创建一个bottom元素用于绑定事件处理程序 --&gt;
&lt;button id=&quot;test&quot;&gt;Click Me!&lt;/button&gt;
&lt;script&gt;
    //声明一个对象保存button的状态，用于跟踪button是否被单机过
    var button = {
        clicked:false,
        click:function(){
            //定义一个方法作为click事件处理程序。由于它是一个对象方法，所以在函数内部使用this获取该对象
            this.clicked = true;
            //在方法内，我们测试button按钮的状态是否在单击后进行了相应的改变
            assert(button.clicked,&quot;The button has been clicked&quot;);
        }
    }
    //为button绑定click事件处理程序
    var elem = document.getElementById(&quot;test&quot;);
    elem.addEventListener(&quot;click&quot;,button.click,false);
&lt;/script&gt;
</code></pre></div><p>在浏览器加载该代码，并单机按钮，测试未通过,代码测试之所以会失败，是因为click函数的上下文不是我们所期待的button对象。</p> <p>如果我们通过button.click(),那么该函数上下文就会是button。但在上述代码中，浏览器的时间处理系统认为函数调用的上下文是事件的目标元素，所以才会导致其上下文是<code>&lt;button&gt;</code>元素，而不是button对象。所以我们将click状态设置在错误的对象上了。</p> <p>将上下文设置为调用事件处理程序时的目标元素，是一个完全合理的默认行为，很多情况下，我们可以对其进行判断。但是在上述代码中，用的就是默认方法。幸运的是，闭包可以帮我们解决这个问题。</p> <p>通过使用匿名函数,apply()和闭包，我们可以强制让特定的函数在调用时都使用特定所需的上下文，如下面代码:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;button id=&quot;test&quot;&gt;Click Me!&lt;/button&gt;
&lt;script&gt;
//定义一个binding函数，封装了一个其他对象上的方法。
    function bind(context,name) {
        return function(){
            return context[name].apply(context,arguments);
        }
    }
    var button = {
        clicked:false,
        click:function(){
            this.clicked = true;
            assert(button.clicked,&quot;The button has been clicked&quot;);
            console.log(this);
        }
    }
    //利用binding函数，将button对象作为上下文绑定到事件处理程序上
    var elem = document.getElementById(&quot;test&quot;);
    elem.addEventListener(&quot;click&quot;,bind(button,&quot;click&quot;).click,false);
&lt;/script&gt;
</code></pre></div><p>在这里，我们添加的秘密武器是bind()方法。该方法用于创建并返回一个匿名函数，该匿名函数使用apply()调用了原始函数，以便我们可以强制将上下文设置成我们想要的任何对象。在代码中，传递给bind()的第一个参数就是要设置的上下文对象。上下文(context)和方法名称(name),通过匿名函数的闭包进行传入，在函数结束时进行调用，而匿名函数闭包则包含了传递给bind()的参数。</p> <p>接下来，在建立事件处理程序时，我们使用了bind()方法来指定事件处理程序，而不是直接使用button.click。这会让包装的匿名函数成为事件处理程序。当单机按钮时，将调用匿名函数，然后反过来在调用click方法，同时将上下文强制设置成button对象。</p> <p>上述代码所创建的关系，如图:</p> <p><img src="/book/284FE10B3674.png" alt=""></p> <p>绑定函数的特定实现，是假设我们使用现有对象的方法(作为属性的函数)，并且也是将该对象作为上下文。基于这个假设，bind()函数只需要两个信息:包含该方法的对象以及方法名称。</p> <p>该bind()函数是Prototype流行库中其中一个函数的简化版本，该库可以使得代码变得整洁并使用经典的面向对象方式进行编程。</p> <p>在Prototype库中，函数bind代码的示例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script&gt;
    Function.prototype.bind = function() {
        var fn = this,args = Array.prototype.slice.call(arguments);
        object = args.shift();

        return function() {
            return fn.apply(object, args.concat(Array.prototype.slice.call(arguments)));
        }
    }

    var myObject = {};
    function myFunction() {
        return this == myObject;
    }
    assert(!myFunction(),&quot;Context is not set yet&quot;);

    var aFunction = myFunction.bind(myObject);
    assert(aFunction,&quot;Context is set prototype&quot;);
&lt;/script&gt;
</code></pre></div><p>上述代码中，将自身方法作为Function的prototype属性的属性，以便将该方法附加到所有的函数上，而不是声明一个全局作用域的方法。</p> <p>使用该函数，将其作为方法绑定到所有的函数上(通过原型),像这样使用:var boundFunction = myFunction.bind(myObject)。通过该方法，我们可以将参数绑定到匿名函数上。这样，在某些程序的分部函数上，可以让我们提前声明一些参数。</p> <p>Prototype的bind()，并不意味着它是apply()或call()的一个替代方法。该方法的潜在目的是通过匿名函数和闭包控制后续执行的上下文。这个重要的区别使apply()和call()对事件处理程序和定时器的回调进行延时执行特别有帮助。</p> <h3 id="偏应用函数"><a href="#偏应用函数" class="header-anchor">#</a> 偏应用函数</h3> <p>&quot;分部应用&quot;一个函数是一项特别有趣的技术，在函数调用之前，我们可以预先传入一些函数。实际上，偏应用函数返回了一个含有预处理参数的新函数，以便后期可以调用。</p> <p>这类代理函数----代理的是另外一个函数，并且在执行的时候会调用所代理的函数----这就是我们签名所使用的在函数调用时&quot;绑定&quot;特定上下文的技术。这里只是把相同的技术用在不同的地方而已。</p> <p>这种在一个函数中首先填充几个参数的技术称之为柯里化。</p> <p>假设我们想把一个字符串分割成CSV(逗号分割)，并忽略多余的空格，我们很容易通过一个正则表达式，使用String的split()方法做到这一点:<code>var elements = &quot;val1,val2,val3&quot;.split(/,\s*/);</code></p> <p>在原生函数上进行分部参数应用</p> <div class="language- extra-class"><pre class="language-text"><code>String.prototype.csv = String.prototype.split.partial(/,\s*/);
var result = (&quot;Mugan,Jin,Fuu&quot;).csv();

assets(result[0]==&quot;Mugan&quot;&amp;&amp;result[0]==&quot;Jin&quot;&amp;&amp;result[0]==&quot;Fuu&quot;,&quot;The text values were split properly&quot;);
</code></pre></div><p>在上述代码中，我们使用了String得split方法，并想象出一个partial()方法，利用这个方法，我们可以预先填充正则表达式用于分隔符字符串。其结果是返回一个名为csv()得新函数，我们可以在任何时候调用该函数，将含有逗号得字符串转换成数组，而无需在处理混乱得正则表达式。</p> <p>柯里化函数实例(在第一个特定参数中进行填充)</p> <div class="language- extra-class"><pre class="language-text"><code>Function.prototype.curry = function(){
    //记住，该函数以及预填充得参数是保存在闭包中的
    var fn = this,
    args = Array.prototype.slice.call(arguments);
    //创建一个匿名柯里化函数
    return function(){
        return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)));
    }
}
</code></pre></div><p>这种技术事另外一个利用闭包记住状态得很好的例子。在上述代码中我们要记住新增加得函数(这里的this参数不会存在于任何闭包中，因为每个函数调用得时候都有自己得this)以及预填充参数，并将它们转移到新创建得函数中。该新函数将有预填充得参数以及刚传入得新参数。其结果就是，这样得方法可以让我们预先传入一些参数，然后返回给我们一个新得简单函数供我们使用</p> <p>虽然这种风格得部分函数非常有用，但我们可以做的更好。如果我们给特定函数传递遗漏得参数，而不是从参数列表一开始就传，该如何做呢？</p> <p>一个更复杂得&quot;分部&quot;函数:</p> <div class="language- extra-class"><pre class="language-text"><code>Function.prototype.partial = function(){
    var fn = this,args = Array.prototype.slice.call(arguments);
    return function(){
        var arg = 0;
        for(var i = 0; i &lt;args.length&amp;&amp;arg &lt; arguments.length;i++){
            if (args[i] == undefined) {
                args[i] = arguments[arg++];
            }
        }

        return fn.apply(this, args);
    }
}
</code></pre></div><p>该实现得本质类似于Prototype得curry()方法，但它有几个重要得差异。值得注意得是，用户可以在参数列表得任意位置指定参数，然后是在后续得调用中，根据遗漏得参数值是否等于undefined来判断参数得遗漏。要实现这种功能，我们添加了参数合并功能。很有效果，遍历传入得所有参数，判断相应得参数是否遗漏了(是否是undefined)，然后沿着顺序天仇遗漏得参数。</p> <h3 id="函数重载-2"><a href="#函数重载-2" class="header-anchor">#</a> 函数重载</h3> <p>过多控制函数在JavaScript中得工作原理产生得一个有趣得副作用是，我们可以在用户毫无感知得情况下，完全操作一个函数得内部行为。具体来说有两种方法可以做到这个事情:修改现有的函数(不需要闭包)，或基于现有的函数创建一个自更新得新函数。</p> <h4 id="缓存记忆"><a href="#缓存记忆" class="header-anchor">#</a> 缓存记忆</h4> <p>在签名我们了解到，缓存记忆是一个让函数具备一种可以记忆它历史被调用时所产生得运算结果得能力得过程</p> <p>函数得记忆方法:</p> <div class="language- extra-class"><pre class="language-text"><code>Function.prototype.memoized = function(key){
    //在values属性里保存函数返回值得缓存，此处检查是否已经创建了缓存，如果没有就创建
    this._values = this._values || {};
    //传入key进行调用得时候，检测是否有该key对应得缓存，如果有，则直接返回，如果没有，则调用函数，然后将返回值再保存在缓存里以便下次使用
    return thiss._values[key]!==undefined?this._values[key]:this._values[key] = this.apply(this.arguments);
}

function isPrime(num){
    var prime = num!=1;
    for(var i = 2; i &lt;num; i++){
        if (num%i==0) {
            prime = false;
            break;
        }
    }

    return prime;
}

assert(isPrime.memoized(5),&quot;The function works;5 is prime&quot;);
assert(isPrime._values[5],&quot;The answer has been cached&quot;);
</code></pre></div><p>刚开始，在做人任何计算或查询之前，必须先确保存在这样一个数据存储对象，并且该对象依附于父函数本身。通过简单得简化表达式就可以做到:this._values = this._values||{};</p> <p>如果_values属性已经存在，我们只是重新对引用进行保存，否则就创建一个新数据存储对象(初始空对象)，并将其存储在_values属性上。</p> <p>通过该方法调用一个函数时，首先检查数据存储对象里是否已经有值了，如果有，则直接返回。否则就开始对值进行计算，并将结果保存在缓存里，以便下次调用得时候可以在使用。</p> <p>在上述代码中有趣得地方是，函数计算和结果保存都是在一个单独得步骤中。计算结果是通过apply()调用父函数来完成得，并直接保存在数据存储对象中。但这句话中包含了return语句，也就是说计算结果也直接返回给父函数了。所以整个事件链----计算结果，保存结果，返回结果----是在一个逻辑代码单元中完成。</p> <p>这种方法得缺点是，isPrime()函数得调用者也必须记住要调用memoized()方法才能使用缓存记忆功能。调用者根本不可能记得住。</p> <p>通过缓存记忆方法，我们通过监控现有函数值得传入/传出来实现缓存记忆功能。让我们研究一下如果通过闭包来创建一个新函数，以便在函数调用得时候自动进行缓存记忆，而无需在做像调用memoized()方法这样得事情。使用闭包实现缓存记忆功能得代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>Function.prototype.memoized = function(key){
    this._values = this._values || {};
    return thiss._values[key]!==undefined?this._values[key]:this._values[key] = this.apply(this.arguments);
}

Function.prototype.memoize = function(){
    //通过变量赋值将上下文带到闭包中。否则，上下文就会丢失，因为它不会成为闭包得一部分
    var fn = this;
    //在缓存记忆函数中封装原始得函数
    return function (){
        return fn.memoized.apply(this, arguments);
    }
}

var isPrime =  (function (num){
    var prime = num!=1;
    for(var i = 2; i &lt;num; i++){
        if (num%i==0) {
            prime = false;
            break;
        }
    }

    return prime;
}).memoize();

assert(isPrime(17),&quot;17 is prime&quot;);
</code></pre></div><p>在原来代码基础上，首先创建了memoized()方法，然后又添加另外一个新方法memoize().该方法返回了一个包装了原始函数并且调用了memoized()方法得新函数，这样它返回得始终是原始函数得缓存记忆版本。这使得调用中无需在调用memoized()。</p> <p>注意，在memoize()方法中，我们构建了一个闭包，通过将上下文复制到一个变量中从而记住需要缓存记忆得原始函数(通过上下文)。这是一个常用得技巧:每个函数都有自己得上下文，所以函数从来都不是闭包得一部分。但是可以通过创建一个变量引用到上下文，从而可以将上下文变成闭包得一部分。通过记住原始函数，我们可以创建一个始终掉哟个memoized()方法得新函数，从而可以直接访问函数得缓存记忆实例。</p> <p>在代码中，定义isPrime()得时候,我们还用了一个非常奇怪得方法。由于我们希望isPrime()始终都有缓存记忆功能，所以需要构建一个返回值不会被缓存得临时函数。创建该匿名函数，并且立即对其进行缓存，随后将函数赋值给isPrime变量。在本例张松，不可能在非缓存函数中对素数进行计算，因为只有一个isPrime()函数是存在得，并且该函数在闭包中完全封装了原始函数。</p> <p>代码中是一个很好得闭包功能展示。从开发得角度来看，它非常有用，但同样也有缺陷:如果过多得利用闭包修改函数得逻辑，那会让函数变得不可拓展，这显然是不可取得。</p> <h4 id="函数包装"><a href="#函数包装" class="header-anchor">#</a> 函数包装</h4> <p>函数包装是一种封装函数逻辑得技巧,用于在单个步骤内重载创建新函数或继承函数。最有价值得场景是，在重载一些已经在得函数时，同时保存原有函数在被包装后仍然能够有效使用。</p> <p>使用新功能包装旧函数:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个普通得包装函数，接收3个参数:需要包装得方法所属得对象，要包装得方法名称，要代替原有方法进行执行得方法
function wrap(object,method,wrapper) {
    //记住原有函数，以便稍后可以使其通过闭包进行引用
    var fn = object[method];
    //通过创建一个新函数调用作为包装器传进得函数，从而创建了包装原始函数。
    //在新函数中，包装器函数是通过apply()进行调用得，强制将函数上下文设置
    //为object对象，并将其作为参数与原始参数一起传递给原有方法(通过使用bind()强制将函数上下文设置为objecct对象)
    return object[method] = function(){
        return wrapper.apply(this,[fn.bind(this)].concat(
            Array.prototype.slice.call(arguments)
        ))
    }
}
//利用Prototype得机制进行浏览器判断----记住，该代码来自Prototype，所以说是Prototype利用
//自己得prototype特性----来判断该函数是否需要进行包装
if (Prototype.Browser.Opera) {
    //如果attr参数是&quot;title&quot;并且不能使用原有函数得话，则利用wrap()函数执行新功能代码
    wrap(Element.Method,&quot;readAttribute&quot;,
    fuction(original,elem,attr){
        return attr == &quot;title&quot; ? elem.title : original(elem,attr);
    });
}
</code></pre></div><p>传入一个基本对象，要包装该对象中得方法名称，新包装容器函数。首先，将原有方法保存在变量fn中。</p> <p>然后,我们使用一个新得匿名函数来重载该方法。新函数执行了之前传进来得包装器函数wrapper(通过闭包),并传递一个重新构造过得参数列表。在构建这个参数列表时，我们希望第一个参数是我们要重载得原有函数，所以我们创建了一个数组，其中包含原始数组得引用，并将原始参数也追加到该函数组中。apply()方法会将该数组作为参数列表</p> <p>Prototype类库利用wrap()函数，实现了对一个已经存在函数得重写，取而代之得是一个新函数。但这个新函数仍然可以访问原有函数提供得方法。这就意味着，一个函数可以很安全得被重载，并且同时仍然保留原有得功能。</p> <p>上述内容得出得结果是，wrap()函数是一个可重用得函数，我们可以用一种比较隐蔽得方法重写任何对象得方法中已有得功能。这又彰显了闭包得威力。</p> <h3 id="即时函数"><a href="#即时函数" class="header-anchor">#</a> 即时函数</h3> <p>还有一个重要得构造是在JavaScript高级函数式编程中使用得，这种构造依赖于对闭包得充分利用，代码如下:
<code>(function(){})()</code></p> <p>这种模式得代码，毫无疑问可能有在很多地方，它给JavaScript语言带来了出乎意料得能力。这段代码中得花括号和圆括号看起来比较陌生，让我们一步一步探究一下，其内部到底都发生了什么。</p> <p>首先，让我们忽略第一组括号得内容，在回头来看代码:
<code>(...)()</code></p> <p>我们知道，可以通过函数名加圆括号(functionName())的语法方式调用任意的一个函数，但是在这里，我们可以使用任意一个引用函数实例的表达式作为函数的名称。这就是为什么我们可以像如下代码这样，使用变量名称调用该变量所引用的函数:</p> <div class="language- extra-class"><pre class="language-text"><code>var someFunction = function(){...};
result = someFunction();
</code></pre></div><p>与其他表达式在一起使用，我们需要将一个操作符----本例是函数调用操作符()----应用在整个表达式上，所以需要用圆括号将该表达式括起来</p> <h4 id="临时作用域与私有变量"><a href="#临时作用域与私有变量" class="header-anchor">#</a> 临时作用域与私有变量</h4> <p>由于函数是立即执行，其内部所有的函数，所有的变量都局限于其内部作用域。我们可以使用即时函数创建一个临时的作用域，用于存储数据状态。</p> <p>注意:记住，变量在JavaScript中的作用域依赖于定义变量的函数，通过创建一个临时函数，利用其特性，我们可以创建一个持有变量的临时作用域。</p> <h5 id="创建一个独立作用域"><a href="#创建一个独立作用域" class="header-anchor">#</a> 创建一个独立作用域</h5> <div class="language- extra-class"><pre class="language-text"><code>(function(){
    var numClicks = 0;
    document.addEventListener(&quot;click&quot;, function(){
        alert(++numClicks);
    },false);
})();
</code></pre></div><p>由于即时函数会立即执行，click时间也会马上执行。需要注意的一件重要事情是，上述代码为包含了numClicks变量的事件处理程序创建了一个闭包，该闭包使得numClicks变量可以在处理程序中进行持久化，并且可以被处理程序进行引用，除此之外旧没有别的地方可以引用该变量了。</p> <p>这也是一种最常见的几时函数使用方法:简单，自包装功能。各个功能所需的变量都保存在闭包内，但对其它地方却都不可见。</p> <p>由于即使函数也是函数，他们的使用方式可以更加有趣，代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener(&quot;click&quot;, function(){
    var numClicks = 0;
    return function(){
        alert(++numClicks);
    };
}(),false);
</code></pre></div><p>在本例中，我们再次创建了一个即时函数，但这一次我们为即时函数返回了一个值:作为事件处理程序的一个函数。就像其他表达式一样，该即时函数的返回的值被传递到了addEventListener()方法。但是我们创建的内部函数依然可以通过闭包获取numClicks变量值。</p> <p>该技巧时观察作用域的一个特别方式。在很多编程语言中，作用域时依赖于代码块的。但在JavaScript中，变量的作用域依赖于变量所在的闭包。</p> <p>此外，利用这个简单的构造，我们现在可以将作用域限制于代码块，子代码块或各级函数中。想函数调用的参数一样，将代码的作用域限制在一个很小的单元内，其威力时非常强大的，无疑也彰显了JavaScript语言的灵活性。</p> <h5 id="通过参数限制作用域内的名称"><a href="#通过参数限制作用域内的名称" class="header-anchor">#</a> 通过参数限制作用域内的名称</h5> <p>由于它们和普通函数一样，所以我们也可以像其他普通函数一样，在即时函数调用的时候向即时函数传递参数，通过形参名称来引用这些参数。实例如下:<code>(function(what){alert(what);}('Hi there!'))</code></p> <p>另外一个使用即时函数的更加实际的例子，在页面上，将其他库与jQuery库一起混合使用，比如Prototype库。</p> <p>jQuery在全局作用域内创建了一个名为jQuery(其主要函数名称)的对象，还为该函数创建了一个$别名。只不过，其他很多流行的JavaScript库也是都使用$作为别名，Prototype亦是如此。由于意识到这一点了，所以jQuery提供了一个方式(jQuery.noConflict())用于将$恢复成其他想使用的JavaScript库。在这种页面中使用$引用Prototype的时候，必须使用jQuery变量来引用jQuery。</p> <p>通过即时函数，我们可以将$重新分配会jQuery。代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;img src=&quot;./../../.vuepress/public/jjy.jpg&quot;/&gt;
&lt;script&gt;
    //定义一个$表示其他内容，而不是jQuery
    $ = function(){
        alert('not jQuery!')
    }
    //即时函数期望接收一个单个参数，并且名称为$。在该函数内部，该参数可以覆盖任何其他高级作用域的同名对象
    (function($){
        //即时函数内部，我们用$表示jQuery。注意我们不仅在函数内部使用了$。
        //即便是这些处理程序很久才调用，通过闭包，$也能进行正确绑定
        $('img').on('click',function(event){
            $(event.target).addClass('clickedOn');
        })
        //在调用即时函数的时候，我们将jQuery作为参数传递进去。就会将jQuery绑定到$参数上了。
    })(jQuery);
&lt;/script&gt;
</code></pre></div><p>在代码中，我们首先将$定义为其他内容，而不是jQuery。在页面里引用Prototype，或其他库，或其他占用$名称的代码，就有可能发生这种结果。</p> <p>但是，由于我们想在代码片段中使用$来引用jQuery，所以定义一个接收单个参数(名为$)的即时函数。在函数体中，参数$将优先于全局变量$。无论我们向该函数传递什么内容，其都会在函数内被$进行引用。通过向即时函数传入jQuery参数，函数内部的$就变成了jQuery。</p> <p>注意$参数会成为函数体内所创建内部函数的闭包的一部分，包括给jQuery的on()方法所传递的事件处理程序。所以，即便事件川里程序在即时函数执行并消失以后很久一段时间才执行，该处理程序还是可以将$引用到jQuery的。</p> <h5 id="使用简洁名称让代码保持可读性"><a href="#使用简洁名称让代码保持可读性" class="header-anchor">#</a> 使用简洁名称让代码保持可读性</h5> <p>通常，在一段代码中，我们会频繁引用一个对象。如果引用很长并且很复杂，所有这些很长的名称会让代码变得难以阅读。难以阅读的代码对任何人都没有好处。</p> <p>有一个便捷的方法，就是把这个引用赋值给一个短小的变量名，像如下这样：
<code>var short = Some.long.reference.to.something;</code></p> <p>但是，在我们使用简洁名称short来代替Some.long.reference.to.something的时候，我们在当前作用域内却引用了一个不必要的新名词，这是我们需要学会避免的情况。</p> <p>相反，有经验的函数式程序员，可以使用即时函数将短名称引用到一个有限的作用域内。如下事一个来自Prototype JavaScript库的简单示例:</p> <div class="language- extra-class"><pre class="language-text"><code>(function(v){
    Object.extend(v,{
        href:       v._getAttr,
        src:        v._getAttr,
        type:       v._getAttr,
        action:     v._getAttrNode,
        disabled:   v._flag,
        checked:    v._flag,
        readonly:   v._flag,
        multiple:   v._flag,
        onload:     v._getEv,
        onunload:   v._getEv,
        onclick:    v._getEv,
        ...
    });
})(Element.attributeTransferslations.read.values);
</code></pre></div><p>在当前示例中，Prototype正在给对象拓展新的属性和方法。在代码中，Prototype并没有为Element.attributeTransferslations.read.values创建临时变量，而是将其作为即时函数的第一个参数传递进去了。也就意味着，参数v就是这个长名称数据结构的引用，并存在于即时函数的作用域内。</p> <p>很容易看到，相当于将名称Element.attributeTransferslations.read.values替换成v，即时函数中v的使用，让代码更加具有可读性。</p> <p>这种在作用域内创建临时变量的技巧，对没有演示调用的循环遍历来说尤其有用。</p> <h4 id="循环"><a href="#循环" class="header-anchor">#</a> 循环</h4> <p>即时函数另外一个有用的地方是，它可以利用循环和闭包解决一些棘手的问题。考虑一下，如下这个常见的问题代码。</p> <p>闭包迭代中的代码没有按预期执行:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt;DIV 0&lt;/div&gt;
&lt;div&gt;DIV 1&lt;/div&gt;

&lt;script&gt;
    //在页面上查询所有的&lt;div&gt;元素，本例中可以查到两个
    var divs = document.getElementsByTagName(&quot;div&quot;);
    for (var i = 0; i &lt; divs.length;i++){
        divs[i].addEventListener(&quot;click&quot;,function(){
            //我们期望每个处理程序报告相应的数字，但是却没有看到预期结果
            alert(&quot;divs #&quot;+i+&quot;was clicked.&quot;);
        },false);
    }
&lt;/script&gt;
</code></pre></div><p>在上述代码中，我们遇到了一个使用闭包和循环时常见的问题，也就是说，函数绑定之后，闭包抓取的变量被更新了。这意味着，每个绑定的函数处理程序都会一直显示i最后的值，本例中该值为2。</p> <p>在前面探讨过:闭包记住的是变量的引用(reference) ----- 而不是闭包创建时刻该变量的值。这是一个重要的区别，让很多人都走了弯路。</p> <p>不过不用担心。我们可以在使用一个闭包和即时函数来修正当前这个闭包的问题，俗话说得好，以毒攻毒，代码如下:</p> <p>利用即时函数妥善处理迭代问题:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt;DIV 0&lt;/div&gt;
&lt;div&gt;DIV 1&lt;/div&gt;

&lt;script&gt;
    //在页面上查询所有的&lt;div&gt;元素，本例中可以查到两个
    var divs = document.getElementsByTagName(&quot;div&quot;);
    for (var i = 0; i &lt; divs.length;i++)(function(n){
        divs[n].addEventListener(&quot;click&quot;,function(){
            //我们期望每个处理程序报告相应的数字，但是却没有看到预期结果
            alert(&quot;divs #&quot;+n+&quot;was clicked.&quot;);
        },false);
    })(i);
&lt;/script&gt;
</code></pre></div><p>通过在for循环内加入即时函数(替换前一个实例中的代码块)，我们可以将正确的值传递给即时函数(也就是内部函数的闭包)，进而让处理程序得到正确的值。这意味着，在for循环每次迭代的作用域中，i变量都会重新定义，从而给click处理程序的闭包传入我们期望的值。</p> <h4 id="类库包装"><a href="#类库包装" class="header-anchor">#</a> 类库包装</h4> <p>关于闭包和即时函数细粒度应用的另外一个重要用途，是将其用于JavaScript类库的开发。当我们开发一个类库时，很重要的一点是，不希望让一些不必要的变量去污染全局命名空间，尤其是哪些临时变量。</p> <p>要解决这个问题，闭包和即时函数尤其有用，它们可以帮助我们让类库尽可能的保持私有，并且可以有选择性的让将一些变量暴露到全局命名空间内。jQuery就专注于这个原则，完全封装了它的所有功能，并选择性的将一些变量关联到全局空间，比如，这里看到了jQuery:</p> <div class="language- extra-class"><pre class="language-text"><code>(function() {
    var jQuery = window.jQuery = function(){
        // Initialize
    }
    //...
})();
</code></pre></div><p>注意，这里有两次赋值，这就有意这样做的。首先jQuery构造器(作为一个匿名函数)赋值给了window.jQuery，这样就将其作为了一个全局变量了。</p> <p>尽管如此，不能包装全局的jQuery变量就会一直存在，处于我们控制之外的代码可能会改变或删除该jQuery变量。为了避免这个问题，我们将其赋值给了一个局部变量jQuery，强制将其保持在即时函数的作用域内。</p> <p>也就是说，不管外包的变量发生了什么变化，在整个jQuery库代码中，我们都可以一直使用jQuery这个名字。我们不会关心其他的东西，在即时函数创建的世界中，名称jQuery的意义就是我们所希望的。因为路口不需要需要的所有函数和变量都进行了很好的封装，从而在如何使用方面，为最终用户提供了很大的灵活性。</p> <p>但这并不是唯一的实现方法，另外一种方式如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>var jQuery = (function() {
    var jQuery = window.jQuery = function(){
        // Initialize
    }
    //...

    return jQuery;
})();
</code></pre></div><p>这段代码和之前的那个例子实现了同样的效果，只是代码组织形式不同而已。这里，我们在匿名函数作用域中定义了一个jQuery函数，它可以自由的存在于该作用域中，然后将其返回，并赋值给一个全局变量，名称同样式jQuery。通常在只输出一个变量的时候，有限使用这种技巧，这样看起来能体现出赋值的意义。</p> <h2 id="原型与面向对象"><a href="#原型与面向对象" class="header-anchor">#</a> 原型与面向对象</h2> <h3 id="实例化和原型"><a href="#实例化和原型" class="header-anchor">#</a> 实例化和原型</h3> <p>所有的函数在初始化的时候都有一个prototype属性，该属性的初始值事一个空对象。只有函数在作为构造器的时候，prototype属性才会发挥更大的作用。在前面，我们使用new关键字调用一个函数，使得该函数可以作为构造器进行实例化，并产生一个新的空对象实例作为其上下文。</p> <h4 id="对象实例化"><a href="#对象实例化" class="header-anchor">#</a> 对象实例化</h4> <p>创建一个对象最简单的方法只有一条语句:<code>var o={};</code></p> <p>上述语句将创建一个新的空对象，然后通过赋值语句可以在给它添加一些属性:</p> <div class="language- extra-class"><pre class="language-text"><code>var o={};
o.name = &quot;Saito&quot;;
o.occupation = &quot;marksman&quot;;
o.cyberizationLevel = 20;
</code></pre></div><p>对于有面向对象编程背景的开发人员来说，根本用不了封装和类构造器的概念:声明一个函数，并将对象初始化到已知的初始化状态。毕竟，如果我们要创建多个相同类型的对象实例，分别对属性进行赋值，布局代码冗长，而且还容易出错。我们希望，可以将对象的属性集和方法都放在同一个地方。</p> <p>JavaScript提供了这样一个机制，但与其他大多数语言存在一个很大的差别。与面向对象语言Java或C++不同，JavaScript通过构造器执行new操作符来初始化一个新对象，而没有类的定义。而new操作符在构造器函数上应用以后，就会触发创建一个新分配的对象。</p> <h5 id="原型作为对象概览"><a href="#原型作为对象概览" class="header-anchor">#</a> 原型作为对象概览</h5> <p>让我们来看一份简单的函数例子调用，一个使用new操作符，一个不实用new操作符，看一下prototype属性是如何为新实例提供属性的。使用原型方法创建一个新实例代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个函数，什么都不做，也不返回任何值
function Ninja(){}
//在该函数的原型上添加一个方法
Ninja.prototype.swingSword = function(){
    return true;
}
//将函数作为函数进行调用，测试验证什么事情都没有发生
var ninja1 = Ninja();
assert(ninja1===undefined,&quot;No instance of Ninja created.&quot;);

//将函数作为构造器进行调用，测试确认，不仅新对象实例被创建了，而且函数原型上的方法也可以调用了
var ninja2 = new Ninja();
assert(ninja2&amp;&amp;ninja2.swingSword&amp;&amp;ninja2.swingSword(),&quot;Instance exists and method is callable.&quot;);

//输出:
//No instance of Ninja created.
//Instance exists and method is callable.
</code></pre></div><p>代码中，我们定义了一个看似无用的函数Ninja(),随后我们将以两种方法进行调用:作为普通函数进行调用，作为构造器进行调用。创建函数以后，我们再在它的prototype上添加一个swingSword()方法。然后我们对函数进行测试。</p> <p>首先，我们像普通函数一样调用，并将其结果存储在变量ninja1中。看一下该函数体，起始它没返回任何东西，所以我们期望ninja1的值为undefined时才是正确的。作为一个如此简单的函数，Ninja()好像也没有那么大的作用。</p> <p>接着，使用new操作符将其作为构造器进行调用，其调用结果完全不一样了。这一次，函数再次被调用了，但此时，新创建了一个对象，并且成了函数的上下文。new操作符返回的结果是该新对象的引用。测试两个内容:ninja2引用的是新创建对象，并且该新对象有一个swingSword()方法可以让我们进行调用。</p> <p>注意，我们并没有在构造器里显式做任何事情。通过将swingSword()方法添加到构造器的prototype属性上，swingSword()方法就可以附加到新对象上了。</p> <h5 id="实例属性"><a href="#实例属性" class="header-anchor">#</a> 实例属性</h5> <p>使用new操作符将函数作为构造器进行调用的时候，其上下文被定义为新对象实例。这意味着，除了通过原型给函数附加属性的形式以外，我们还可以在构造器函数内通过this参数初始化。</p> <p>观察初始化活动的优先级:</p> <div class="language- extra-class"><pre class="language-text"><code>function Ninja(){
    //创建一个实例变量，并赋一个布尔值false
    this.swung = false;
    //创建一个实例方法，返回实例变量swung的反转值
    this.swingSword = function(){
        return !this.swung;
    }
}
//使用同样的名称定义一个原型方法
Ninja.prototype.swingSword = function(){
    return this.swung;
}
//创建Ninja实例进行测试，断言测试方法会覆盖同名的原型方法。测试会通过吗
var ninja = new Ninja();
assert(ninja.swingSword(),&quot;Called the instance method,not the prototype method.&quot;);
</code></pre></div><p>在浏览器中运行页面测试时，我们看到测试通过了！这表明在构造器内创建的实例方法会阻隔在原型上定义的同名方法。</p> <p>初始化操作的优先级是很重要的，优先级如下:</p> <ul><li>通过原型给对象实例添加的属性。</li> <li>在构造器函数内给对象添加的属性。</li></ul> <p>在构造器内的绑定操作优先级永远高于在原型上的绑定操作优先级。因为构造器this上下文指向的是实例自身，所以我们可以在构造器内对核心内容执行初始化操作。</p> <h5 id="协调引用"><a href="#协调引用" class="header-anchor">#</a> 协调引用</h5> <p>在上述代码可能会让我们认为:当创建一个新对象，并传递给构造器时，构造器原型的属性会被赋值到该对象上。然后必定时构造器内的属性赋值覆盖了原型上面的值。但是事实证明，如果真像我们想象的这样，会有一些行为不是很合理。</p> <p>假设原型上面的值只是简单复制给该对象，那么对象创建以后，原型上的任何改变都应该反应在刚才创建的对象上了。是这样吗？让我们重新组织一下代码，看看会发生什么，实例如下:</p> <div class="language- extra-class"><pre class="language-text"><code> //定义一个构造器Ninja，并设置一个布尔类型的属性
function Ninja(){
    
    this.swung = true;
}
//使用new操作符调用构造器，初始化一个Ninja实例
var ninja = new Ninja();
//对象创建后，在构造器的原型上添加一个方法
Ninja.prototype.swingSword = function(){
    return this.swung;
}
//测试该方法是否存在于对象实例上
assert(ninja.swingSword(),&quot;Method exists,even out of order.&quot;);

//Method exists,even out of order.
</code></pre></div><p>上述代码测试是通过的。很显然，在对象创建时，不仅仅时简单复制属性那么简单。</p> <p>事实是，原型上的属性并没有复制到其他地方，而是附加到新创建的对象上了，并可以和对象自身属性引用一起协调运行。</p> <p>如下是一过程的简单概述。</p> <ul><li>在引用对象的一个属性时，首先检查该对象本身是否拥有该属性。如果有，则直接返回，如果没有......</li> <li>则，再查看对象的原型，检查该原型上是否有所要的属性，如果有，则直接返回，如果没有......</li> <li>则，该值是undefined。</li></ul> <p>如图:</p> <p><img src="/book/25F009FCE9E2.png" alt=""></p> <p>JavaScript中的每个对象，都有一个名为construct的隐式属性，该属性引用的时创建该对象的构造器。由于prototype是构造器的一个属性，所以每个对象都有一种方式可以找到自己的原型。</p> <p>在Chrome浏览器中运行上述实例代码时，该图显示的是JavaScript控制台的捕获。</p> <p><img src="/book/1600224308731.jpg" alt="">;</p> <p>在控制台输入ninja.constructor引用时，我们看到的时所期望的Ninja()函数，这是因为该对象是使用次函数作为构造器进行创建的。一个更深层次的ninja.constructor.prototype.swingSword引用，说明了我们可以通过这种方式访问对象实例的原型属性。</p> <p>这就解释了，为什么对象创建之后原型的更改会生效。原型是实时附加在对象上的，可以很好的与该对象的自身属性引协调在一起。引用时，可以随时使用原型。</p> <p><img src="/book/1600224915794.jpg" alt=""></p> <p>在该图中，被变量ninja引用的对象有member1和member2两个属性。这些引用是通过这些属性来完成的。如果一个对象上不存在的属性被引用，其就会需找构造器的原型。由于member4的引用在任何地方都不存在，所以它的值是undefined。</p> <div class="language- extra-class"><pre class="language-text"><code>function Ninja(){
    this.swung = true;
    //定义一个和原型方法同名的实例方法
    this.swingSword = function(){
        return !this.swung;
    }
}
var ninja = new Ninja();
//定义一个和实例方法同名的原型方法
Ninja.prototype.swingSword = function(){
    return this.swung;
}
//测试哪个方法先被调用
assert(ninja.swingSword(),&quot;Called the instance method,not the prototype method.&quot;);
</code></pre></div><p>从上述代码输出来看，即便是在实例化对象之后，再在原型方法添加方法，实例方法也会优先考虑原型上的该方法这一切都很有道理。在对象自身对属性引用进行查询失败之后，原型查找是唯一的方式。由于对象直接拥有了swingSword属性，原型版本的属性则不发挥任何作用，即便该版本的方法是最新创建的。</p> <p>其关键点是，查询属性引用时，首先查询对象自身，如果不存在，才在原型上进行查找。</p> <h4 id="通过构造器判断对象"><a href="#通过构造器判断对象" class="header-anchor">#</a> 通过构造器判断对象</h4> <p>JavaScript不仅可以利用原型协调属性引用，还可以很方便的让我们获知时哪个构造器创建了对象实例。</p> <p>正如我们所看到的，对象的构造器可以通过constructor属性获得。任何时候我们都可以重新引用该构造器，甚至可以使用它进行类型检查，代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>function Ninja(){}
var ninja = new Ninja();
//使用typeof判断ninja类型，除了告诉我们它只是一个object以外，就没有别的内容了
assert(typeof ninja=='object',&quot;The type of the instance is object.&quot;);
//使用instanceof判断ninja的类型，得到了更多信息----该对象是通过Ninja函数进行构造的
assert(ninja instanceof Ninja,&quot;Instanceof identifies the constructor.&quot;);
//使用constructor属性判断ninja的类型，可以得知其确实时构造器函数的引用
assert(ninja.constructor == Ninja,&quot;The ninja object was created by the Ninja function.&quot;);
</code></pre></div><p>在上述代码中，我们定义一个构造器，并使用该构造器创建了一个对象实例。然后，使用typeof操作符判断该实例的类型。其检查结果并不是很有用，只是告诉我们该实例只是一个对象而已，因为该检查结果总是返回&quot;object&quot;。更有趣的是instanceof操作符，这才是真正有用的，该操作符告诉了我们一个很明确的方法，来确定一个实例是否是由特定的函数构造器所创建。</p> <p>除此之外，我们还可以使用construct属性，我们此时知道，该属性作为创建该对象的原始函数的引用，被添加在所有的实例上。利用该属性，我们可以验证实例的起源。</p> <p>使用constructor属性实例化一个新对象:</p> <div class="language- extra-class"><pre class="language-text"><code>function Ninja(){}
var ninja = new Ninja();
//通过第一个Ninja创建第二个Ninja
var ninja2 = new ninja.constructor();
//证明新对象也是一个Ninja
assert(ninja2 instanceof Ninja,&quot;It's Ninja!&quot;);
//不是同一个对象，也不是同一个实例
assert(ninja!==ninja2,&quot;But not the same Ninja!&quot;);
</code></pre></div><p>上述代码测试结果表明，成功创建了第二个Ninja对象，并且该变量指向的并不是同一个实例。</p> <p>特别有意思的是，我们不用摘掉原有的构造器函数就可以再次创建一个新实例，即便原始的构造器在作用域内已经不存在了，我们也完全可以在幕后使用该引用。</p> <p>注意:<code>尽管对象的constructor属性可以被修改，这样做没有任何直接或很明显的目的(尽管有人可能会认为这是恶意的)，只是告知对象是在哪里被创建的。如果constructor属性被覆盖，那么创建该对象的原始函数就丢失了。</code></p> <h4 id="继承与原型链"><a href="#继承与原型链" class="header-anchor">#</a> 继承与原型链</h4> <p>instanceof操作符还有另外一个功能，我们可以利用它作为对象继承的一种形式。要使用该功能，我们需要理解继承在JavaScript中是如何工作的，以及原型链所扮演的角色。</p> <p>尝试用原型实例实现继承:</p> <div class="language- extra-class"><pre class="language-text"><code>//通过构造器和原型定义一个舞者
function Person(){}
Person.prototype.dance = function(){};
//定义一个Ninja构造器
function Ninja(){}
//通过Person的prototype将dance方法复制给Ninja，尝试让Ninja拥有跳舞的能力
Ninja.prototype = {dance:Person.prototype.dance};
var ninja = new Ninja();
assert(ninja instanceof Ninja,&quot;ninja receives functionality from the Ninja prototype&quot;);
assert(ninja instanceof Person,&quot;...and the Person prototype&quot;);
assert(ninja instanceof Object,&quot;...and the Object prototype&quot;);
//ninja receives functionality from the Ninja prototype
//失败了
//...and the Object prototype
</code></pre></div><p>上述代码测试结果，尽管我们可能已经教会了忍者跳舞，但是没能让忍者(Ninja)成为一个人(Person)。虽然Ninja可以像人一样跳舞，但Ninja并没成为一个Person。这不是继承而是复制。</p> <p>这种方法是一个巨大的失败。但没有太大的损失，因为使用这种方法，我们需要将Person的每个属性都单独复制到Ninja原型上。这种方法做不到继承。</p> <p>注意:<code>有个很有趣的地方需要注意，即时没做任何事情，所有的对象也都会是Object的实例。在浏览器的调试器里执行console.log({}.constructor) 得到ƒ Object() { [native code] }</code></p> <p>我们真正想要实现的是一个原型链(prototype chain),这样一个忍者(Ninja)可以是一个人(Person)，并且一个人(Person)可以是一个哺乳动物(Mammal),而一个哺乳动物(Mammal)则又是一个动物(Animal)等，直到最终是一个Object。</p> <p>创建这样一个原型链最好的方式是，使用一个对象的实例作为另外一个对象的原型:SubClass.prototype = new SuperClass();</p> <p>例如:</p> <p>Ninja.prototype = new Person();</p> <p>这样保持原型链，是因为SubClass实例的原型将是SuperClass的一个实例，该实例不仅拥有原型，还持有SuperClass的所有属性，并且该原型指向其自身超类的一个实例，以此类推。</p> <p>使用原型实现继承:</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(){}
Person.prototype.dance = function(){};
function Ninja(){}
Ninja.prototype = new Person();
var ninja = new Ninja();
assert(ninja instanceof Ninja,&quot;ninja receives functionality from the Ninja prototype&quot;);
assert(ninja instanceof Person,&quot;...and the Person prototype&quot;);
assert(ninja instanceof Object,&quot;...and the Object prototype&quot;);
assert(typeof ninja.dance == &quot;function&quot;,&quot;...and can dance!&quot;);
//ninja receives functionality from the Ninja prototype
//...and the Person prototype
//...and the Object prototype
//...and can dance!
</code></pre></div><p>上述代码运行后成功。</p> <p>这里得到一个非常重要的结论是，通过执行instanceof操作，可以判断函数是否继承了其原型链中任何对象的功能。</p> <p>注意:<code>大家可能会想起另外一个技巧，但是我们强烈建议不要使用，那就是直接将Person的原型对象赋值给Ninja的原型，像这样:Ninja.prototype = Person.prototype;。这样做的话，Ninja原型傻姑娘的任何修改都会影响到Person的原型，因为他们是同一个对象，这样做肯定会有不良的副作用</code></p> <p>这种原型继承方式还是有一个比较好的 副作用是，所有原型中继承的函数都是实时更新。本例中，原型链应用的方式如图:</p> <p><img src="/book/1600229346388.jpg" alt=""></p> <p>所有原生JavaScript对象构造器(如Object,Array,String,Number,RegExp,Function)都有可能被操作和扩展的原型属性，这是有道理的，因为每个对象构造器自身就是一个函数。这证明原型是这门语言的一个非常强大的特性。利用原型，我们可以扩展这门语言自身的功能，从而给这门语言引用新的特性或丢失的特性。</p> <p>forEach()方法的一种不过时的实现:</p> <div class="language- extra-class"><pre class="language-text"><code>//先判断该方法是否已经存在，如果已经存在就不用在重新定义了
if (!Array.prototype.forEach) {
    //在Array的原型上添加该方法，之后，所有的数组都有这样一个方法了
    Array.prototype.forEach = function(callback,context) {
        for (var i=0;i&lt;this.length;i++){
            //在每个数组条目上都调用callback函数
            callback.call(context||null,this[i],i,this);
        }
    }
}
[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;].forEach(function(value,index,array){
assert(value,&quot;Is in position &quot; + index + &quot;out of&quot; + (array.length-1));
});
</code></pre></div><p>再订一个可能已经存在的方法之前，我们需要检查一下，确保Array上没有定义forEach()方法，如果已经定义了，就不在定义了。这使得代码可以向前兼容，因为如果执行JavaScript的环境里定义了该方法，就会转而使用该原生方法。</p> <p>如果确定该方法不存在，就开始将其添加到Array原型上，并使用传统的for循环遍历该数组，为每一条目都调用一下callback方法。传递给callback的是当前所遍历的条目，索引以及原始数组。注意，context||null表达式可以防止我们将undefined传递给call()。</p> <p>所有的内置对象，比如Array，包括其原型，我们都可以按照自己的一元来扩展它。但需要记住的重点是，在原始对象上引入新的属性或方法，与在全局作用域内声明一个变量一样危险，因为原生对象的原型只有一个实例，所以由发生命名冲突的重大可能性。</p> <p>同时，如果原生对象原型的自定义实现是向前兼容，那就会有危险，因为我们的预期实现可能不圈钱匹配最后的实现，从而在浏览器最终实现该方法的时候导致严重问题发生。在涉及这些操作时，我们要非常小心才行。</p> <h4 id="html-dom原型"><a href="#html-dom原型" class="header-anchor">#</a> HTML DOM原型</h4> <p>通过HTMLElement的原型，给所有HTML元素都添加一个新方法:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;parent&quot;&gt;
    &lt;div id=&quot;a&quot;&gt;I'm going to be removed.&lt;/div&gt;
    &lt;div id=&quot;b&quot;&gt;Me too!&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    //通过给HTMLElement的原型添加一个新方法，从而给所有的元素都添加上该方法
    HTMLElement.prototype.remove = function(){
        if(this.parentNode){
            this.parentNode.removeChild(this);
        }
    }
    //用原来的方式删除一个节点
    var a=document.getElementById(&quot;a&quot;);
    a.parentNode.removeChild(a);

    //用新方式删除一个节点，简短又清晰
    document.getElementById(&quot;b&quot;).remove();
    assert(!document.getElementById(&quot;a&quot;),&quot;a is gone.&quot;);
    assert(!document.getElementById(&quot;b&quot;),&quot;b is gone too.&quot;);

&lt;/script&gt;
</code></pre></div><p>在这段代码中，通过增强HTMLElement构造器的原型，我们为所有的DOM元素都添加了一个新方法remove()。然后，先用原生方式删除a，紧接着使用新方法删除b。我们认为，这两种方式都可以将元素从DOM中删除。</p> <p>一个大量使用这种特性的JavaScript库是Prototype，该库在现有DOM元素上增加了大量的功能，包括HTML的诸如和CSS的操作。</p> <p>另外一个需要注意的问题是，HTML元素是否可以直接通过构造器进行实例化。我们可以这样做:<code>var elem = new HTMLElement();</code></p> <p>但是这样不管用。尽管浏览器暴露了基构造器和原型，他们选择性的禁用了通过构造器创建元素的能力(有可能限制只能在内菜用)。</p> <p>还有一点要记住，该特性兼容旧版本浏览器，因为如果我们想让方法附加到DOM元素上，那么代码会既简洁又相当引人注目。</p> <h3 id="疑难陷阱"><a href="#疑难陷阱" class="header-anchor">#</a> 疑难陷阱</h3> <h4 id="扩展对象"><a href="#扩展对象" class="header-anchor">#</a> 扩展对象</h4> <p>我们也许会犯的极其严重的错误就是去拓展原生Object.prototype。其原因是，在扩展该原型时，所有的对象都会接收这些额外的属性。在我们遍历对象属性的时候，这个问题特别验证，新属性的出现可能会导致各种意想不到的行为。</p> <p>给Object原型添加额外属性会发生意想不到的行为:</p> <div class="language- extra-class"><pre class="language-text"><code>//在Objects原型上添加一个方法
Object.prototype.keys = function(){
    var keys = [];
    for(var p in this)keys.push(p);

    return keys;
}
创建一个对象进行测试
var obj = {a:1,b:2,c:3};
//通过检查数组长度验证新方法
assert(obj.keys().length==3,&quot;There are three properties in the object.&quot;);
</code></pre></div><p>通过测试却没有通过，毫无疑问，问题肯定出现在了给Object添加的keys()方法上。我们给所有的对象都添加了这一个属性，并且会出现现在计数中。这会影响到所有对象，并迫使所有的代码都必须要考虑到这个额外的属性。可能会破坏页面开发人员的合理代码。很明显这时不可接受的。所以不要这样做!</p> <p>JavaScript提供一个名为hasOwnProperty()的方法，使用该方法可以确定一个属性是在对象实例上定义的，还是从原型里导入的。</p> <p>使用hasOwnProperty()方法辨别Object原型扩展:</p> <div class="language- extra-class"><pre class="language-text"><code>Object.prototype.keys = function(){
    var keys = [];
    for(var p in this)
        if (this.hasOwnProperty(p)) keys.push(p);

    return keys;
}
var obj = {a:1,b:2,c:3};
assert(obj.keys().length==3,&quot;There are three properties in the object.&quot;);
</code></pre></div><p>这样运行就测试通过了。</p> <p>但是，不能仅仅因为它能解决这个问题，就滥用它，从而使其成为我们代码的用户的一个负担。循环对象属性是一个非常常见的行为，但通常我们不在自己页面上hasOwnProperty()。一般来说，我们应该使用这种解决方法保护自己的代码免受影响，但我们永远不应期望其他作者必须要保护自己的代码免受我们代码的影响。</p> <h4 id="扩展数字"><a href="#扩展数字" class="header-anchor">#</a> 扩展数字</h4> <p>在Number原型上添加一个方法:</p> <div class="language- extra-class"><pre class="language-text"><code>//在Number的原型上定义一个新方法
Number.prototype.add = function(num){
    return this+num;
}
var n=5;
//使用一个变量测试该方法
assert(n.add(3)==8,&quot;It works when the number is in a variable.&quot;);
//使用表达式测试该新方法
assert((5).add(3)==8,&quot;Also works if a number is wrapped in parentheses.&quot;);
//使用字面量格式测试该新方法
assert(5.add(3)==8,&quot;What about a simple literal?&quot;);
</code></pre></div><ul><li>用数字变量验证新方法。</li> <li>用数字表达式验证新方法。</li> <li>直接用数字字面量验证新方法。</li></ul> <p>当我们尝试在浏览器中加载页面时，页面不会加载。结果是语法解析器不能处理字面量这种情况。</p> <p>有些库无视这些问题继续在Number的原型上做扩展，只是简单规定它们的使用。这当然是一种选择，尽管该库需要良好的文档和教程来解释这些问题，但一般来说，除非我们真的需要，最好避免在Number的原型上做扩展。</p> <h4 id="子类化原生对象"><a href="#子类化原生对象" class="header-anchor">#</a> 子类化原生对象</h4> <p>所谓原生对象的子类化，就是一个对象是Object的子类(因为它是所有原型链的根)。</p> <p>子类化Array对象:</p> <div class="language- extra-class"><pre class="language-text"><code>function myArray() {}
myArray.prototype = new Array();
var min = new myArray();
min.push(1,2,3);
assert(min.length == 3,&quot;All the items are in our sub-classed array.&quot;);
assert(min instanceof Array,&quot;Verify that we implement Array functionality.&quot;)

//All the items are in our sub-classed array.
//Verify that we implement Array functionality.
</code></pre></div><p>对Array进行子类化时，我们使用了一个自定义构造器MyArray()，除了在Internet Explorer浏览器上运行该代码以外，该代码在其他地方都能正常使用。length属性相当特殊，密切关系到Array的数字指标，但IE的实现却不能很好的反应length的值。</p> <p>模拟Array功能，而不是扩展出子类:</p> <div class="language- extra-class"><pre class="language-text"><code>function MyArray(){};
MyArray.prototype.length = 0;
(function(){
    var methods = ['push','pop','shift','unshift','slice','splice','join'];
    for (var i = 0; i &lt;methods.length; i++)(function(name){
        MyArray.prototype[name] = function(){
            return Array.prototype[name].apply(this,arguments);
        }
    })(methods[i]);
})();
var mine = new MyArray();
mine.push(1,2,3);
assert(mine.length == 3,&quot;All the items are on our sub-classed array.&quot;);
assert(!(mine instanceof Array),&quot;We are not subclassing Array,though.&quot;)
</code></pre></div><p>在上述代码中，我们为类定义了一个新的构造器，名为MyArray,并给出了它自己的length属性。我们并没有将其继承于Array，因为我们已经知道不是所有的浏览器都能用，所以我们使用了一个即时函数，使用apply()方法，将从Array中选中的方法复制到新类上。注意，使用数组里的方法名是为了保持整洁性，且易于扩展。</p> <h4 id="实例化问题"><a href="#实例化问题" class="header-anchor">#</a> 实例化问题</h4> <p>函数有两中用途:作为&quot;普通&quot;的函数，以及作为构造器。</p> <p>让我们先看一个简单的例子，在错误使用的情况下发生的情况，代码如下。</p> <p>函数调用时不使用new操作符时的结果:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个含有name属性的User类
function User(first,last) {
    this.name = first + &quot; &quot; + last;
}
//创建一个测试user，传入简单的名字
var user = User(&quot;Ichigo&quot;,&quot;Kurosaki&quot;);
//验证该对象已经被实例化了
assert(user,&quot;User instantiated&quot;);
//验证构造器对name进行了赋值
assert(user.name == &quot;Ichigo Kurosaki&quot;,&quot;User name correctly assigned&quot;);
</code></pre></div><p>运行上述代码时，出现了严重的错误。</p> <p><img src="/book/1600342789841.jpg" alt=""></p> <p>测试表明,第一个测试的失败说明该对象没有被实例化，从而导致第二个测试也抛出一个错误。</p> <p>快速检查代码，可能不会立即发现，我们实际上时忘记了在User()函数上调用new操作符了。这种情况下，new操作符的缺失，将会导致函数是作为普通函数进行调用的，而不是构造器，而且并没有实例化一个新对象。很容易误入这个陷阱，不使用操作符调用该函数，将导致意想不到的结果(例如，user不会被定义)。</p> <p>除了导致意想不到的错误以外，构造器函数如果作为普通函数进行调用的话，会产生微妙的副作用，如污染当前作用域(通常是全局命名空间)，从而导致更多意想不到的结果。实例代码如下。</p> <p>不小心将变量引入到全局命名空间中:</p> <div class="language- extra-class"><pre class="language-text"><code>function User(first,last) {
    this.name = first + &quot; &quot; + last;
}
//创建一个全局变量
var name = &quot;Rukia&quot;;
//不正确的方式调用构造器
var user = User(&quot;Ichigo&quot;,&quot;Kurosaki&quot;);
//测试全局变量
assert(name == &quot;Rukia&quot;,&quot;Name was set to Rukia&quot;);
</code></pre></div><p>这段代码与之前的示例类似，只不过这一次，碰巧在全局命名空间内声明了一个全局变量name。这段代码和上例犯了同样的错误:忘记使用new操作符。</p> <p>但是这一次，我们捕获错误的测试。而新的测试表明，全局变量name的值被覆盖了，因为测试在执行的时候失败了。</p> <p>先从构造器找原因。函数作为构造器调用时，函数调用的上下文是新分配的对象。但作为普通函数调用时，其上下文是什么呢？其上下文是全局作用域，也就是说this.name引用执行的不是新创建对象的name属性，而是全局作用域内的name变量。</p> <p>判断函数是否是作为构造器进行调用的:</p> <div class="language- extra-class"><pre class="language-text"><code>function Test() {
    return this instanceof arguments.callee;
}
assert(!Test(),&quot;We didn't instantiated,so it returns false&quot;);
assert(new Test(),&quot;We did instantiated,returning true&quot;);
</code></pre></div><ul><li>通过arguments.callee可以得到当前执行函数的引用</li> <li>&quot;普通&quot;函数的上下文是全局作用域(除非有人做了强制修改)</li> <li>利用instanceof操作符测试已构建对象是否构建于指定的构造器</li></ul> <p>基于这些事实，函数在作为构造器进行执行的时候，表达式:<code>this instanceof arguments callee</code>，它的结果是true，作为普通函数执行，则返回false。</p> <p>这意味着，在一个即将被作为构造器的函数内，我们可以判断在调用的时候是否少了new操作符。</p> <p>在调用上修复该问题:</p> <div class="language- extra-class"><pre class="language-text"><code>function User(first,last){
    //判断如果不是按照正确的方法进行调用的话，就修复这个错误
    if(!(this instanceof arguments.callee)){
        return new User(first,last);
    }
    this.name = first + &quot; &quot; + last;
}
var name = &quot;Rukia&quot;;
var user = User(&quot;Ichigo&quot;,&quot;Kurosaki&quot;);

assert(name == &quot;Rukia&quot;,&quot;Name was set to Rukia.&quot;);
assert(user instanceof User,&quot;User instantiated&quot;);
assert(user.name == &quot;Ichigo Kurosaki&quot;,&quot;User name correctly assigned.&quot;);
</code></pre></div><p>通过上述代码，判断函数是否按不正确的方法进行了调用，如果是，则在实例化User自身，将其作为函数的结果进行返回。这样做的结果是，无论我们函数调用的时候是否是作为普通函数进行调用的，最终都返回一个User实例，可以通过我们的测试进行验证。这样就非常容易使用。</p> <p>但是，我们需要看一下这种做法是否正确。如下内容需要思考。</p> <ul><li>callee属性在新版本JavaScript中废弃，并且不支持严格模式。该解决方案只支持非严格模式的环境。展望未来，我们为什么不使用严格模式呢？</li> <li>这真的是一个好的编程实战妈？这是一个整洁的技术，但它的&quot;优秀&quot;可能是有争议的。</li> <li>我们100%确定自己知道用户的意图吗？我们是否太相信自己了？</li></ul> <p>记住，只是因为我们可以想出一个巧妙的解决方法，并不总是意味着我们就应该用这种方式。</p> <h3 id="编写类的风格的代码"><a href="#编写类的风格的代码" class="header-anchor">#</a> 编写类的风格的代码</h3> <p>JavaScript可以让我们通过原型实现继承，许多开发人员，尤其是哪些有传统面向对象背景的开发人员，都希望将JavaScript的继承系统简化并抽象成一个他们更熟悉的系统。</p> <p>所以，这不可避免的引导我们走向类(class)的领域。类(class)是面向对象开发人员所期望的内容，尽管JavaScript本身不支持传统的类继承。</p> <p>通常，大家都希望它有如下特性:</p> <ul><li>一套可以构建新构造器函数和原型的轻量级系统。</li> <li>一种简单的方式来执行原型继承。</li> <li>一种可以访问被函数原型所覆盖的方法的途径。</li></ul> <p>很多现有的JavaScript库都模拟传统的类继承，但是其中两个比较有标识性:base2和Prototype的实现。虽然每个库都有大量的高级特性，其面向对象核心仍是这些库的一个重要组成部分。我们将提取其精华并进行展示，以便使得这些特性，让科班出身的面向对象开发人员看起来更自然。</p> <p>经典继承语法示例:</p> <div class="language- extra-class"><pre class="language-text"><code>//通过subclass()方法，创建一个Person类作为Object的一个子类，该方法最后再实现
var Person = Object.subClass({
    init: function(isDancing) {
        this,dancing = isDancing;
    },
    dance: function(){
        return this.dancing;
    }
});
//通过继承Person类，创建一个Ninja子类
var Ninja = Person.subClass({
    //需要一种调用父类构造器的方法----这里展示我们将这样做
    init:function(){
        this._super(false);
    },
    dance:function(){
        return this._super();
    },
    swingSword:function(){
        return true;
    }
});
//创建一个实例对Person类进行测试，看其是否能够跳舞
var person = new Person(true);
assert(person.dance(),&quot;The person is dancing&quot;);
//创建一个实例对Ninja类进行测试，看其是否有swingSword方法以及继承过来的dance方法
var ninja = new Ninja();
assert(ninja.swingSword(),&quot;The sword is swinging.&quot;);
assert(!ninja.dance(),&quot;The ninja is not dancing.&quot;);
//执行instanceof测试，验证类的继承
assert(persong instanceof Person,&quot;Persong is a Person.&quot;);
assert(ninja instanceof Ninja&amp;&amp;ninja instanceof Person,&quot;Ninja is a Ninja and a Person.&quot;);
</code></pre></div><p>再上述代码，有几点重要的注意事项:</p> <ul><li>通过调用现有构造器函数的subClass()方法可以创建一个新&quot;类&quot;，例如，通过Object创建一个Person类，以及通过Person创建一个Ninja类。</li> <li>为了让构造器的创建更加简单。我们建议的语法是，为每个类只通过一个init()方法，就像Person和Ninja提供的init()方法一样。</li> <li>我们所有的&quot;类&quot;最终都继承于一个祖先:Object。因此，如果要创建一个新类，它必须是Object的一个子类，或者是一个再层级上继承于Object的类</li> <li>该语法的最大挑战是访问被覆盖的方法，而且有时这些方法的上下文也有可能被修改了。通过this._super()调用Person超类的原始init()和dance()方法，我们就可以了解这种用法。</li></ul> <p>子类方法:</p> <div class="language- extra-class"><pre class="language-text"><code>(function(){
    var initializing = false, 
    //粗糙的正则表达式用于判断函数是否可以被序列化。
    superPattern = /xyz/.test(function(){xyz;})?/\b_super\b/ : /.*/;
    //给Object添加一个subClass()方法
    Object.subClass = function(properties){
        var _super = this.prototype;
        //初始化超类
        initializing = true;
        var proto = new this();
        initializing = false;
        //将属性复制到prototype里
        for(var name in properties){
            proto[name] = typeof properties[name] == &quot;function&quot; &amp;&amp; 
                            typeof _super[name] == &quot;function&quot; &amp;&amp; 
                            superPattern.test(properties[name])?
                            //定义一个重载函数
                            (function(name,fn){
                            return function(){
                                var tmp = this._super;
                                this._super = _super[name];
                                var ret = fn.apply(this, arguments);
                                this._super = tmp;
                            }
                            })(name,properties[name]):properties[name];
        }
        //创建一个仿真构造器
        function Class(){
            if(!initializing &amp;&amp; this.init){
                this.init.apply(this, arguments);
            }
        }
    }
    //设置类的原型
    Class.prototype = proto;
    //重载构造器引用
    Class.constructor = Class;
    //让类继续可扩展
    Class.subClass = arguments.callee;
    return Class;
})();

</code></pre></div><p>上述代码，使得&quot;类&quot;的概念作为一种结构，保持继承简单，并且允许调用超类方法。</p> <p>该实现的两个最重要部分是初始化以及超类方法处理部分。对这两个部分进行深入了解有助于理解整个实现。但它会很容易和复杂的代码混淆起来，所以我们从开头开始，按照从上往下的方法进行理解。</p> <h4 id="检测函数是否可序列化"><a href="#检测函数是否可序列化" class="header-anchor">#</a> 检测函数是否可序列化</h4> <p><code>函数序列化就是简单接收一个函数，然后返回该函数的源码文本</code></p> <p>再大多数现代浏览器中，函数的toString()方法都会奏效。一般来说，一个函数在其上下文中序列化成字符串，会导致它的toString()方法被调用。所以，可以用这种方式测试函数是否可以序列化。</p> <p>在设置一个名为initializing的变量为false之后，我们使用如下表达式测试一个函数是否能够被序列化:<code>/xyz/.test(function(){xyz;})</code></p> <p>该表达式创建一个包含xyz的函数，将该函数传递给正则表达式的test()方法，该正则表达式对字符串&quot;xyz&quot;进行测试。如果函数能够正常序列化(test()方法将接收一个字符串，然后将触发函数的toString()方法)，最终结果将返回true。</p> <p>使用该文本表达式，我们在随后的代码中使用了该正则表达式:<code>superPattern = /xyz/.test(function(){xyz;})?/\b_super\b/:/.*/;</code></p> <p>建立了一个名为superPattern的变量，稍后用它来判断一个函数是否包含字符串&quot;_super&quot;。只有函数支持序列化才能进行判断，所以在不支持序列化的浏览器上，我们使用一个匹配任意字符串的模式进行代替。</p> <h4 id="子类的实例化"><a href="#子类的实例化" class="header-anchor">#</a> 子类的实例化</h4> <p>此时，我们准备开始定义一个方法用于子类化父类，我们用如下代码进行实现:
<code>Object.subClass = function(properties){ var _super = this.prototype;</code></p> <p>给Object添加一个subClass()方法，该方法接收一个参数，该参数是我们期望添加到子类的属性集。</p> <p>为了用函数原型模拟继承，我们使用签名讨论过的技术:创建一个父类的一个实例，并将其赋值给子类的原型。如果不使用我们之前的实现，其实现代码类似如下:</p> <div class="language- extra-class"><pre class="language-text"><code>function Person(){}
function Ninja(){}
Ninja.prototype = new Person();
assert((new Ninja()) instanceof Person,&quot;Ninjas are people too!&quot;);
</code></pre></div><p>该代码的具有挑战之处是我们想从instanceof运算符中受益，而不是实例化Person对象并运行其构造器。为了抵消这一点，我们在代码中定义了一个initializing变量，每当我们想使用原型实例化一个类的时候，都将该变量设置为true。</p> <p>因此，在构造实例时，我们可以确保不在实例化模式下进行构建实例，并可以相应地运行或跳过init()方法:</p> <div class="language- extra-class"><pre class="language-text"><code>if(!initializing &amp;&amp; this.init)
    this.init.apply(this, arguments);
</code></pre></div><p>尤其重要的是,init()方法可以运行各种昂贵的启动代码(连接到服务器，创建DOM元素，还有其他未知内容)，所以如果只是创建一个实例作为原型的话，我们要规避任何不必要的昂贵启动代码。</p> <h4 id="保留父级方法"><a href="#保留父级方法" class="header-anchor">#</a> 保留父级方法</h4> <p>大多数支持继承的语言中，在一个方法被覆盖时，我们保留了访问被覆盖方法的能力。这是很有用的，因为有时候我们是想完全替换方法的功能，但有时候我们却只是想增加它。在我们的特定实现中，我们创建一个名为_super的临时新方法，该方法只能从子类方法内部进行访问，并且该方法引用的是父类中的原有方法。</p> <p>在我们想调用父类构造器的时候，我们用了如下代码:</p> <div class="language- extra-class"><pre class="language-text"><code>var Person = Object.subClass({
    init: function(isDancing){
        this.dancing = isDancing;
    }
});
var Ninja = Person.subClass({
    init: function(){
        this._super(false);
    }
})
</code></pre></div><p>在Ninja构造器内，我们调用了Person的构造器，并传入了一个相应的值。这可以防止重新复制代码----我们可以重用父类中已经编写好的代码。</p> <p>该功能的实现是一个多步骤的过程。为了增强子类，我们向subClass()方法传入了一个对象哈希，只需要将父类的属性和传入的属性合并在一起就可以了。</p> <p>首先，使用如下代码，创建一个超类的实例作为一个原型:</p> <div class="language- extra-class"><pre class="language-text"><code>initializing = true;
var proto = new this();
initializing = false;
</code></pre></div><p>注意，我们是如何&quot;保护&quot;初始化代码的。</p> <p>现在，是时候将传入的属性合并到proto对象(一个原型的原型)中了。如果不在意父级函数，合并代码将非常简单:<code>for(var name in properties) proto[name] = properties[name];</code></p> <p>但是，我们需要关系父类的函数，所以前面的代码和除了调用父类函数的函数之外是等价的。重写函数时，可以通过_super调用父函数，我们需要通过名为_super的属性，将子类函数和父类函数的引用进行包装。</p> <p>但在完成该操作之前，我们需要检测即将被包装的子类函数。可以使用如下添加表达:<code>typeof properties[name] == 'function' &amp;&amp; typeof _super[name] == 'function' &amp;&amp; superPattern.test(properties[name])</code></p> <p>此表达式包含三个检测条件:</p> <ul><li>子类属性是否是一个函数？</li> <li>超类属性是否是一个函数？</li> <li>子类函数是否包含一个_super()引用?</li></ul> <p>只有三个添加为true的时候，我们才能做所要做的事情，而不是复制属性。注意，我们使用了在前面设置的正则表达式，和函数序列化一起，测试函数是否会调用等效的父类。</p> <p>如果条件表达式表明我们必须包装功能，我们通过给即时函数的结果进行赋值，将该结果作为子类的属性:</p> <div class="language- extra-class"><pre class="language-text"><code>(function(name,fn) {
    return function(){
        var tmp = this._super;
        this._super = _super[name];
        var ret = fn.apply(this,arguments);
        this._super = tmp;

        return ret;
    };
})(name,properties[name])
</code></pre></div><p>该即时函数创建并返回了一个新函数，该新函数包装并执行了子类的函数，同时可以通过_super属性访问父类函数。首先，我们需要先保持旧的this._super引用(不管它是否存在)，然后处理完以后再次恢复该引用。这在同名变量已经存在的情况下会很有用</p> <p>接下来，创建新的_super方法，它只是在父类原型中已经存在的一个方法的引用。值得庆幸的是，我们不需要做任何额外的代码修改或作用域修改。当函数成为我们对象的一个属性时，该函数的上下文会自动设置(this引用的时当前的子类实例，而不是父类实例)。</p> <p>最后，调用原始的子类方法执行自己的共振(也有可能使用了_super)，然后将_super恢复成原来的状态，并将方法调用结果进行返回。</p> <h2 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h2> <h3 id="为什么正则表达式很牛"><a href="#为什么正则表达式很牛" class="header-anchor">#</a> 为什么正则表达式很牛</h3> <p>假设我们要验证一个字符串，有可能时网站用户在表单中输入的，遵循一个9位的美国邮政编码格式<code>99999-9999</code></p> <p>其中每个9代表一个十进制数字。该格式前面有5位数字，然后紧接着时一个连字符，连字符后面跟着另外4位数字。如果使用其他格式，那么包裹和信件就会被转移到手工筛选部门，至于什么时候才能再见天日，那就看运气了。</p> <p>让我们创建一个函数，对一个字符串进行验证，验证其是否符合美国邮政服务编码的格式。</p> <p>在字符串中测试特殊模式:</p> <div class="language- extra-class"><pre class="language-text"><code>function isThisAZipCode(candidate){
    //先把明显不符合条件的字符串处理掉
    if(typeof candidate!='string'||candidate.length!=10)return false;
    for(var i=0; i &lt;candidate.length; i++){
        var c=candidate[i];
        //根据字符索引执行测试验证
        switch(i){
            case 0:case 1:case 2:case 3:case 4:
            case 6:case 7:case 8:case 9:
                if(c&lt;'0'||c&gt;'9')return false;
                break;
            case 5:
                if(c!='-')return false;
                break;

        }
    }
    //如果都成功了，就说明符合格式
    return true;
}
</code></pre></div><p>根据字符在字符串中的位置，我们只需要两个不同检查即可，这段代码就利用了这一点。在运行时，我们依然需要比较9次，但是我们只需要为每个比较编写一次代码。</p> <p>现在考虑这样一种方式:</p> <div class="language- extra-class"><pre class="language-text"><code>function isThisAZipCode(candidate){
    return /^\d{5}-\d{4}$/.test(candidate);
}
</code></pre></div><p>这就是正则表达式的威力，而且这只是它冰山的一角。如果语法看起来像键盘上爬行的蝎子的话，也不要担心。</p> <h3 id="正则表达式进阶"><a href="#正则表达式进阶" class="header-anchor">#</a> 正则表达式进阶</h3> <h4 id="正则表达式解释"><a href="#正则表达式解释" class="header-anchor">#</a> 正则表达式解释</h4> <p>&quot;正则表达式&quot;这个词源于中世纪的数学，当时，一个名叫SStephen Kleene的数学家，使用了名为&quot;正则集合&quot;的数学符号描述自动计算模式。但这不会帮助我们了解任何关于正则表达式的内容，那么让我们把它简单化，正则表达式通常被成为一个模式，是一个用简单方式描述或者匹配一系列集合某个句法规则的字符串。表达式本身包含了允许定义这些模式的术语和操作符。我们很快就会看到这些术语和操作符。</p> <p>在JavaScript中，与大多数其他对象类型一样，有两种方法可以创建正则表达式:通过正则表达式字面量，或者通过构造RegExp对象的实例。</p> <p>例如，如果要创建一个一般的正则表达式，用于精确匹配字符串&quot;test&quot;，可以使用正则字面量:<code>var pattern = /test/;</code></p> <p>正斜杠可能看起来有点奇怪，但是就像字符串是用引号进行界定的一样，字面量是用正斜杠进行界定的。</p> <p>或者，我们可以构造一个RegExp实例，将正则作为字符串传入:<code>var pattern = new RegExp(&quot;test&quot;);</code></p> <p>这两种格式在pattern变量中创建的正则表达式都是一样的。</p> <p>开发过程中，如果正则是已知的，则优先选择字面量语法，而构造器方式则是用于在运行时，通过动态构建字符串来构建正则表达式。</p> <p>字面量语法优先于字符串的其中一个原因时反斜杠字符在正则表达式中发挥重要的左右。但由于反斜杠字符在普通字符串中也是一个转义字符，所以，如果要在字符串内表示反斜杠，我们就要使用\(两个反斜杠)。这会让本来语法就很什么的正则表达式变得更加怪异了。</p> <p>除了表达本身，还有三个标志可以与正则表达式进行关联。</p> <ul><li>i----让正则表达式不区分大小写，所以/test/i不仅可以匹配&quot;test&quot;,还可以匹配&quot;Test&quot; &quot;TEST&quot; &quot;tEsT&quot;等。</li> <li>g----匹配模式中的所有实例，而不是默认只匹配第一次出现的结果。</li> <li>m----允许匹配多个行，比如可以匹配文本区元素中的值。</li></ul> <p>这些标志将附加到字面量尾部(例如，/test/ig)或者作为RegExp构造器的第二个参数(new RegExp(&quot;test&quot;,&quot;ig&quot;))。</p> <h4 id="术语与操作符"><a href="#术语与操作符" class="header-anchor">#</a> 术语与操作符</h4> <h5 id="精准匹配"><a href="#精准匹配" class="header-anchor">#</a> 精准匹配</h5> <p>如果一个字符不是特殊字符或操作符，则表示该字符必须在表达式中出现。例如，在/test/正则中，有4个术语，它们表示这些字符必须在一个字符串中出现，才能匹配该模式。</p> <p>一个接着一个的字符，隐式表达了&quot;后面跟着&quot;这样一个操作。所以，/test/的意思是说，&quot;t&quot;后面跟着&quot;e&quot;，&quot;e&quot;后面跟着&quot;s&quot;，&quot;s&quot;后面又跟着&quot;t&quot;。</p> <h5 id="匹配一类字符"><a href="#匹配一类字符" class="header-anchor">#</a> 匹配一类字符</h5> <p>很多时候，我们并不想匹配一个特定的字符，而是想匹配一个有限字符集中的某个字符。我们可以通过将字符集放到中括号内，来指定该字符集操作符:[abc]。</p> <p>上述示例，是说我们要匹配&quot;a&quot;,&quot;b&quot;和&quot;c&quot;中任何一个字符。注意，即使这样表达式横跨五个字符，但是它只能匹配候选字符串中的一个字符。</p> <p>有时候，我们想要匹配一组优先字符集以外的字符。可以通过在中括号第一个开括号的后面加一个插入符，比如:<code>[^abc]</code></p> <p>其意义将改变为:除了&quot;a&quot; &quot;b&quot; 或 &quot;c&quot;以外的任意字符。</p> <p>在字符集操作方面，还有一个更加重要的变异操作:指定一个范围。例如，如果要匹配&quot;a&quot;和&quot;m&quot;之间的任何一个小写字母，我们可以这样些[abcdefghijklm]。但可以写成更加简单的:<code>[a-m]</code> 中横线表示从&quot;a&quot;到&quot;m&quot;之间的所有字符(包含a和m,按字典顺序)都在该字符集内。</p> <h5 id="转义"><a href="#转义" class="header-anchor">#</a> 转义</h5> <p>并不是所有的字符和其字符字面量都是等价的。当然，所有的字母和十进制数字字符都能代表自己，但是，我们很快就会发现，像$和点(.)这样的特殊字符，表示的是它们自身以外的东西，或者表示为验证术语的操作符。事实上，我们已经看到了如何用[、]、-和^字符表示它们自身以外的东西。</p> <p>如果我们需要匹配[、$、^或其他这样的特殊字符，该怎么办？在正则里，使用反斜杠可以对任意字符进行转义，让被转义字符作为字符本身进行匹配。所以，[表示要匹配[字符，而不是匹配表达式的开括号。两个反斜杠(\)则匹配一个反斜杠。</p> <h5 id="匹配开始与匹配结束"><a href="#匹配开始与匹配结束" class="header-anchor">#</a> 匹配开始与匹配结束</h5> <p>我们可能继承需要确保模式匹配一个字符串的开始，或者一个字符串的结束。插入符号(^)，如果作为正则表达式的第一个字符，则表示要从字符串的开头进行匹配，这样/^test/就只能匹配以&quot;test&quot;开头的字符串了。(注意，这只是^字符的一个重载，它还可以用于否定一个字符类集。)</p> <p>类似的，美元符合($)表示该模式必须出现在字符串的结尾:/test$/。</p> <p>同时使用^和$则表明指定的口试必须包含整个候选字符串:/^test$/</p> <h5 id="重复出现"><a href="#重复出现" class="header-anchor">#</a> 重复出现</h5> <p>如果要匹配连续的四个&quot;a&quot;字符，我们可以用/aaaa/这样表示，但是如果我们想匹配任意数量的相同字符呢？</p> <p>在重复选项上，正则表达式提供了很多方式:</p> <ul><li>在一个字符后面加一个问号(?)，可以定义为该字符是可选的。例如，/t?est/可以匹配&quot;test&quot;和&quot;est&quot;。</li> <li>如果一个字符要出现一次或多次，可以使用加号(+)。例如，/t+est/可以匹配&quot;test&quot; &quot;ttest&quot; &quot;tttest&quot;，而不能匹配&quot;est&quot;。</li> <li>也可以在字符后面的花括号里指定一个数字来表示重复次数。例如，/a{4}/表示匹配含有连续四个&quot;a&quot;字符的字符串。</li> <li>也可以在字符后面的花括号里面自定两个数字(用逗号隔开)来表示重复次数区间。例如，/a{4,10}/表示匹配任何含有连续4个至10个&quot;a&quot;字符的字符串。</li> <li>次数区间的第二个值是可选的(但是要保留逗号)，其表示一个开区间，例如，/a{4,}表示匹配任何含有4个或多于4个&quot;a&quot;字符的字符串。</li></ul> <p>这些重复操作符可以是贪婪的或非贪婪的。默认情况下，它们是贪婪的:它们匹配所有的字符组合。在操作符后面加一个问号？字符(?操作符的一个重载)，如a+?,可以让该表达式编程成为非贪婪的:进行最小限度匹配。</p> <p>举个例子，如果我们对字符串&quot;aaa&quot;进行匹配，正则表达式/a+/将匹配所有这三个字符，而非贪婪表达式/a+?/则只匹配一个a字符，因为一个a字符就可以满足a+术语。</p> <h5 id="预定义字符类"><a href="#预定义字符类" class="header-anchor">#</a> 预定义字符类</h5> <p>有一些我们想匹配的字符，是不可能用字面量字符来表示的(如像回车这样的控制字符)，还有一些我们可能经常想匹配的字符类，比如小数数位或一组空白字符。正则表达式提供了很多表示这些字符或常用类的预定义术语，这样在正则表达式中，我们就可以用这些控制字符进行匹配了，因此，我们不需要再去依靠常用的字符集了。</p> <p>列出了这些术语以及它们表示的字符或字符集:</p> <div class="language- extra-class"><pre class="language-text"><code>\t                  水平制表符
\b                  空格
\v                  垂直制表符
\f                  换页符
\r                  回车
\n                  换行符
\cA:\cZ             控制符，例如，\cM匹配一个Control-M
\x0000:\xFFFF       十六进制Unicode码
\x00:\xFF           十六进制ASCII码
.                   匹配除了新行(\n)之外的任意字符
\d                  匹配任意数字，等价于[0-9]
\D                  匹配任意非数字，等价于[^0-9]
\w                  匹配包括下划线的任意单词字符，等价于[A-Za-z0-9_]
\W                  匹配任何非单词字符，等价于[^A-Za-z0-9_]
\s                  匹配任何空白字符，包括空格，制表符，换页符等
\S                  匹配任何非空白字符
\b                  匹配单词边界
\B                  匹配非单词边界

</code></pre></div><h5 id="分组"><a href="#分组" class="header-anchor">#</a> 分组</h5> <p>到目前为止，我们看到的操作符(如+和*)只能影响前面的术语。如果将操作符应用于一组术语，可以想数学表达式一样在该组上使用小括号。例如，/(ab)+/匹配一个或多个连续出现的子字符串&quot;ab&quot;。</p> <p>当正则表达式有一部分是用括号进行分组时，它具有双重责任，同时也创建所谓的捕获。</p> <h5 id="或操作符-or"><a href="#或操作符-or" class="header-anchor">#</a> 或操作符(OR)</h5> <p>可以用竖线(|)字符表示或者的关系。例如:/a|b/匹配&quot;a&quot;或&quot;b&quot;字符，/(ab)+|(cb)+/则匹配出现一次或多次的&quot;ab&quot;或&quot;cd&quot;。</p> <h5 id="反向引用"><a href="#反向引用" class="header-anchor">#</a> 反向引用</h5> <p>正则表达式中最复杂的术语是，在正则中所定义的捕获的反向引用。</p> <p>这些术语表达式是在反斜杠后面加一个要引用的捕获数量，该数字从1开始，如\1、\2等。</p> <p>举例来说，/^([dtn])a\1/可以任意一个以&quot;d&quot;,&quot;t&quot;或&quot;n&quot;开头，且后面跟着一个a字符，并且在后面跟着的是和第一个捕获相同字符的字符串。后面这一点很重要！它和/[dtn]a[dtn]/不一样，a后面的字符有可能不是&quot;d&quot;,&quot;t&quot;或&quot;n&quot;中的一个字符，但这个字符肯定是以触发该匹配的其中一个字符(&quot;d&quot;,&quot;t&quot;或&quot;n&quot;)开头。因此，\1匹配的字符需要在执行的时候才能确定。</p> <p>在匹配XML类型标记元素的时候它可能会很有用。思考下面的正则表达式:<code>/&lt;(\w+)&gt;(.+)&gt;\/\1&gt;/</code>，要匹配像&quot;<strong>whatever</strong>&quot;这样的简单元素，不使用反向引用，是无法做到的，因为我们无法知道关闭标签和开始标签是否匹配。</p> <h3 id="编译正则表达式"><a href="#编译正则表达式" class="header-anchor">#</a> 编译正则表达式</h3> <p>正则表达式是一个多阶段处理过程，理解每个阶段发生的事情之后，利用正则表达式可以帮助我们优化JavaScript代码。正则表达式的两个重要阶段是编译和执行。</p> <p>编译发生在正则表达式第一次被创建的时候。而执行则是发生在我们使用编译过的正则表达式进行字符串匹配的时候。</p> <p>在编译期间，表达式通过JavaScript引擎进行解析，并转换成其内部表示。解析和转换这个过程，在每个正则表达式创建的时候都会发生(浏览器会进行一些内部优化工作)。</p> <p>通常，浏览器可以很智能地判断相同地正则表达式在何时被使用，并缓存该特定表达式地编译结果。但我们不能指望所有地浏览器都这么智能。特别是对于一些复杂地表达式，通过对稍后要使用地正则表达式进行预定义，我们可以获得一些明显的速度提升。</p> <p>正如在前面地正则表达式概述中所学，在JavaScript中，有两种表达式可以创建编译后地正则表达式:通过字面量方式，或通过构造器方式。让我们来看一个例子，示例如下。</p> <p>创建编译后正则表达式地两种方式:</p> <div class="language- extra-class"><pre class="language-text"><code>var re1 = /test/i;
var re2 = new RegExp(&quot;test&quot;,'i');
assert(re1.toString()==&quot;/test/i&quot;,&quot;Verify the contents of the expression&quot;);
assert(re1.test(&quot;TesT&quot;),&quot;YES,it's case-insensitive.&quot;);
assert(re2.test(&quot;TesT&quot;),&quot;This one is too.&quot;);
assert(re1.toString() == re2.toString(),&quot;The regular expressions are equal.&quot;);
assert(re1!=re2,&quot;But they are different objects.&quot;);
</code></pre></div><p>在本例中，正则表达式在创建之后都处于编译后地状态。如果我们将re1地引用在替换成/test/i字面量，那么同一个正则表达式可能又被编译多次，所以正则表达式只编译一次，并将其保存在一个变量中以供后续使用，这是一个重要地优化过程。</p> <p>注意，每个正则表达式都有一个独立地对象表示:每次创建正则表达式，都会为此创建一个新地正则表达式对象。这和其他地原始类型(如字符串，数组等)不太一样，因为其结果将永远是独一无二地。</p> <p>特别重要的一点，用构造器(new RegExp(...))创建正则表达式地使用。这种技术允许我们，在运行时通过动态创建地字符串构建和编译一个正则表达式。对于构建大量重用地复杂表达式来说，这是非常有用地。</p> <p>例如，要确定文档中地哪个元素拥有特定地样式名称，但这些样式名称在运行地时候才知道。由于一个元素可能绑定多个样式名称，这是一个在运行时进行正则表达式编译地有趣例子。</p> <p>编译一个稍后使用地运行时正则表达式:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;samurai ninja&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;ninja samurai&quot;&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
    function findClassInElements(className,type) {
        var elems = document.getElementsByTagName(type||&quot;*&quot;);
        var regex = new RegExp(&quot;(^|\\s)&quot;+className+&quot;(\\s|$)&quot;);
        var results = [];
        for (var i = 0; i &lt; elems.length; i++){
            if(regex.test(elems[i].className)){
                results.push(elems[i]);
            }
        }
        return results;
    }

    assert(findClassInElements(&quot;ninja&quot;,&quot;div&quot;).length==2,&quot;The right amount of div ninjas was found.&quot;);
    assert(findClassInElements(&quot;ninja&quot;,&quot;span&quot;).length==1,&quot;The right amount of span ninjas was found.&quot;);
    assert(findClassInElements(&quot;ninja&quot;).length==3,&quot;The right amount of ninjas was found.&quot;);
&lt;/script&gt;
</code></pre></div><p>在上述代码中，首先，先建立几个<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>元素，并赋值各种样式名称。然后，定义样式名称检查函数，该函数接收要查询样式地样式名称和要查询元素地类型。</p> <p>然后，收集所有指定类型地原生，并设置正则表达式。注意，基于传递给函数地样式名称，使用new RegExp()构造器来编译正则表达式。这是一个我们无法用正则字面量实现地实例，因为我们不知道要搜索地样式名称是什么。</p> <p>我们对该表达式只构建一次，是为了避免频繁和不必要地重新编译。由于表达地内容是动态地(取决于传入地className参数)，所以通过这种方式，我们可以节约大量地性能。</p> <p>该正则表达式匹配地字符串要以字符串或空格开始，而后跟着指定样式名称，并且紧随其后地是一个空白字符或结束字符串。在该正则中，要注意双反斜杠(\)的使用:\s。创建带有反斜杠的字面量正则表达式时，只需要提供一个反斜杠即可。但是，由于我们在字符串中写反斜杠，所以需要反斜杠进行转义。可以肯定地是，这很麻烦，但我们必须知道，我们是用字符串来构建正则表达式。</p> <p>一旦正则表达式被编译了，就可以利用该表达式地test()方法收集匹配地元素。</p> <h3 id="捕获匹配地片段"><a href="#捕获匹配地片段" class="header-anchor">#</a> 捕获匹配地片段</h3> <p>正在表达式地实用性表现在捕获已匹配地结果上，这样我们便可以在其中进行处理。简单判断一个字符串是否匹配一个模式显然是我们需要做地第一步，但在很多情况下确定匹配地内容也是很有用地。</p> <h4 id="执行简单地捕获"><a href="#执行简单地捕获" class="header-anchor">#</a> 执行简单地捕获</h4> <p>假设我们要从一个复杂地字符串中，将嵌入地数值提取出来。一个很好的例子就是，在旧版本浏览器声明地透明度里就有一个数值。</p> <p>与其他浏览器只是给opacity设置一个数字值不同，IE8和早期版本地浏览器设置透明度地规则如下:<code>filter:alpha(opacity=50);</code></p> <p>捕获嵌入值地简单函数:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;opacity&quot; style=&quot;opacity:0.5;filter:alpha(opacity=50);&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    function getOpacity(elem){
        var filter = elem.style.filter;
        return filter?filter.indexOf(&quot;opacity=&quot;)&gt;=0?(parseFloat(filter.match(/opacity=([^)]+/)[1])/100)+&quot;&quot;:&quot;&quot;:elem.style.opacity;
    }
    window.onload = function () {
        assert(getOpacity(document.getElementById(&quot;opacity&quot;))==&quot;0.5&quot;,&quot;The opacity of tje element has been obtained.&quot;);
    }
&lt;/script&gt;
</code></pre></div><p>定义了一个指定透明度的元素作为测试对象。然后创建一个函数，并返回一个从0.0到1.0的标准透明度值，而不用管它是如何定义地。</p> <p>透明度值地解析代码咋一看似乎有点混乱，但如果分解出来在看，就不会那么糟糕了。首先，要判断是否有filter属性需要解析。如果没有，则直接返回样式地opacity属性值。如果存在filter属性，则需要在确认它是否包含opacity字符串。我们使用indexOf()进行判断。</p> <p>在这一点上，我们可以提取到实际地透明值。如果匹配成功地话，正则表达式地match()方法返回一个捕获数值地数组；如果匹配失败，则返回null。在本例中，我嫩可以确信肯定会匹配成功，我们已经通过indexOf()判断过了。</p> <p>match返回地数组地第一个索引地值总是该匹配地完整结果，然后是每个后续捕获结果。</p> <p>因此，第0个索引值将是完整地匹配值filter:alpha(opacity=50),与此同时，下一个匹配则是50。</p> <p>记住，捕获是由正则表达式中的小括号所定义。因此，当匹配透明度以后，该透明度地值应该是在数组地[1]位置上，因为正则中唯一地捕获，我们是通过在opacity=后面指定地小括号所创建地。</p> <p>该实例使用了一个局部正则表达式和match()方法。使用全局表达式时，则稍微有点变化。</p> <h4 id="用全局表达式进行匹配"><a href="#用全局表达式进行匹配" class="header-anchor">#</a> 用全局表达式进行匹配</h4> <p>在前面我们利用String对象地match()方法，使用局部正则表达式(没有全局标记)会返回一个数组，该数组包含了在匹配操作中成功匹配地整个字符串以及其他捕获结果。</p> <p>但当应用全局正则表达式(添加一个g标记)时，返回的东西却不一样了。返回值依然是第一个数组，但在全局正则表达式地情况下，匹配所有可能地匹配结果，而不仅仅是第一个匹配结果，返回地数组包含了全局匹配结果。在这种情况下，每个匹配地捕获结果是不会返回的。</p> <p>使用macth()进行全局搜索和局部搜索时的不同:</p> <div class="language- extra-class"><pre class="language-text"><code>var html = &quot;&lt;div class='test'&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;&quot; ;
var results = html.match(/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/);

assert(results[0]==&quot;&lt;div class='test'&gt;&quot;,&quot;The entire match.&quot;)
assert(results[1]==&quot;&quot;,&quot;The (missing) slash.&quot;)
assert(results[2]==&quot;div&quot;,&quot;The tag name.&quot;)
assert(results[3]==&quot; class='test'&quot;,&quot;The attributes.&quot;)

var all = html.match(/&lt;(\/?)(\w+)([^&gt;]*?)&gt;/g);
assert(all[0] == &quot;&lt;div class='test'&gt;&quot;,&quot;opening div tag.&quot;)
assert(all[1] == &quot;&lt;b&gt;&quot;,&quot;Opening b tag.&quot;)
assert(all[2] == &quot;&lt;/b&gt;&quot;,&quot;Closing b tag.&quot;)
assert(all[3] == &quot;&lt;i&gt;&quot;,&quot;Opening i tag.&quot;)
assert(all[4] == &quot;&lt;/i&gt;&quot;,&quot;Closing i tag.&quot;)
assert(all[5] == &quot;&lt;/div&gt;&quot;,&quot;Closing div tag.&quot;)
</code></pre></div><p>我们看到，在进行局部正则逼迫时，只有一个实例被匹配了，并且该匹配的捕获结果也返回了；但是在进行全局正则匹配时，返回的却是匹配结果的列表。</p> <p>如果捕获对我们来说很重要，我们可以使用正则表达式的exec()方法，在全局正则匹配时恢复捕获功能。该方法可以对一个正则表达式进行多次调用，每次调用都可以返回下一个匹配的结果。典型的使用方式，如下所示。</p> <p>使用exec()方法进行捕获和全局搜索:</p> <div class="language- extra-class"><pre class="language-text"><code>var html = &quot;&lt;div class='test'&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;&quot; ;
var tag = /&lt;(\/?)(\w+)([^&gt;]*?)&gt;/g,match;
var num = 0;
while((match = tag.exec(html))!==null) {
assert(match.length == 4,&quot;Every match finds each tag and 3 capture.&quot;);
num++;
}
assert(num==6,&quot;3 opening and 3 closing tags found.&quot;);
</code></pre></div><p>在本例中，我们反复调用了exec()方法，该方法保存了上一次调用的状态，这样每个后续调用旧可以继续下去了，直到全局匹配。每个调用返回的都是下一个匹配及其捕获内容。</p> <h4 id="捕获的引用"><a href="#捕获的引用" class="header-anchor">#</a> 捕获的引用</h4> <p>有两种方法，可以引用捕获到的匹配结果:一个是自身匹配，一个是替换字符串(在某些适用的情况下)。</p> <p>适用反向引用匹配HTML标签内容:</p> <div class="language- extra-class"><pre class="language-text"><code>var html = &quot;&lt;div class='test'&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;i&gt;world!&lt;/i&gt;&lt;/div&gt;&quot; ;
//使用捕获的反向引用
var pattern = /&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/1&gt;/g;
//在测试字符串上进行匹配
var match = pattern.exec(html);

assert(match[0] == &quot;&lt;b class='hello'&gt;Hello&lt;/b&gt;&quot;,&quot;The entire tag,start to finish.&quot;);

assert(match[1] == &quot;b&quot;,&quot;The tag name.&quot;);

assert(match[2] == &quot; class='hello'&quot;,&quot;The tag attributes.&quot;);

assert(match[3] == &quot;Hello&quot;,&quot;The contents of the tag.&quot;);

match = parser.exec(html);

assert(match[0] == &quot;&lt;i&gt;world!&lt;/i&gt;&quot;,&quot;The entire tag,start to finish.&quot;);

assert(match[1] == &quot;i&quot;,&quot;The tag name.&quot;);

assert(match[2] == &quot;&quot;,&quot;The tag attributes.&quot;);

assert(match[3] == &quot;world!&quot;,&quot;The contents of the tag.&quot;);
</code></pre></div><p>在代码中，我们适用\1引用了表达式中的第一个捕获，在代码中，该捕获是标签名称。使用这些信息，我们可以匹配相应的结束标签，反向引用到匹配的捕获结果。(当然，还有一个假设，那就是在当前标签内没有嵌入任何同名标签，所以这不是一个详尽的标签匹配示例。)</p> <p>此外，还有一个方法可以获得捕获的引用，那就是通过调用repalce()方法替换字符串的时候。与代码中的反向引用代码不同，在这里，我们使用$1,$2,$3语法表示每个捕获的数字。如下是这种方式的示例用法:
<code>assert(&quot;fontFamily&quot;.repalce(/([A-Z])/g,&quot;-$1&quot;).toLowerCase() === &quot;font-family&quot;,&quot;Convert the camelCase into dashed notation.&quot;);</code></p> <p>在上述代码中，首先获取的捕获值(本例中是大写字母F)，在替换字符串(repalce string)中进行了引用。这种方式允许我们指定一个替换字符串，即便是在运行之前还不知道它的值。</p> <p>这种可以引用正则表达式捕获结果的能力，让很多本来很复杂困难的代码变得相当简单。其富有表现力的特性，将本来可能很迟钝，复杂且冗长的代码，最终变成了一些简短的语句。</p> <p>由于捕获和表达式分组都使用了小括号，所以无法告诉正则表达式处理引擎，哪个小括号是用于分组，以及哪个是用于捕获的。所以会将小括号即视为分组，→视为捕获，由于有时候需要指定一些正则表达式分组，所以会导致捕获的信息比我们预期的还要多。</p> <h4 id="没有捕获的分组"><a href="#没有捕获的分组" class="header-anchor">#</a> 没有捕获的分组</h4> <p>小括号有双重责任:不仅要进行分组操作，还可以指定捕获。这通常不是什么问题，但如果在正则表达式中有大量的分组，就会引起很多不必要的捕捉，可能会让捕获结果的整理工作变的枯燥乏味。</p> <p>思考下如下的正则表达式:<code>var pattern = /((ninja-)+)sword/;</code>,在这里，我们的目的是创建一个这样的正则表达式，在单词&quot;sword&quot;之前，允许前缀&quot;ninja-&quot;出现一次或多次，并且希望捕获整个前缀。这个正则表达式需要两套小括号。</p> <ul><li>定义捕获(sword之前的所有字符串)的小括号。</li> <li>针对+操作符，对&quot;ninja-&quot;文本进行分组的小括号。</li></ul> <p>一切运行正常，但由于括号分组的功能，不仅是单一目标捕获。</p> <p>要让一组括号不进行结果捕获，正则表达式的语法允许我们在开始括号后加一个?:标记。这就是所谓的被动子表达式。</p> <p>将我们正则表达式修改成如下这样:<code>var pattern = /((?:ninja-)+)sword/;</code>，该表达式只会为外层的括号创建捕获。内层括号被转换为一个被动子表达式。</p> <p>要验证这一点，查看如下代码。</p> <p>不带捕获的分组:</p> <div class="language- extra-class"><pre class="language-text"><code>var pattern = /((?:ninja-)+)sword/;
var ninjas = &quot;ninja-ninja-sword&quot;.match(pattern);

assert(ninjas.length==2,&quot;Only one capture was returned.&quot;);
assert(ninjas[1]==&quot;ninja-ninja-&quot;,&quot;Matched both words,without any extra capture.&quot;);
</code></pre></div><p>运行这些测试，我们可以看到，被动子表达式可以阻止不必要的捕获。</p> <p>不管在什么地方使用正则表达式，在不需要捕获的时候，我们都应该尽可能的使用非捕获(被动)分组，以便让表达式引起在记忆和返回捕获工作上做更少的工作。如果不需要捕获的结果，也没用必要寻求它们的帮助。</p> <h3 id="利用函数进行替换"><a href="#利用函数进行替换" class="header-anchor">#</a> 利用函数进行替换</h3> <p>String对象的replace()方法是一个强大且灵活的方法。将正则表达式作为repalce()方法的第一个参数时，导致在该模式的匹配元素(全局匹配的话，就是多个匹配元素)上进行替换，而不是在固定字符串上进行替换。</p> <p>举个例子，加入需要让所有的大写字符串都替换成&quot;X&quot;。我们可以这样编写:<code>&quot;ABCDEfg&quot;.repalce(/[A-Z]/g,&quot;X&quot;)</code>,其结果为&quot;XXXXXfg&quot;。</p> <p>不过，或许replace()最强大的特性是可以接受一个函数作为替换值，而不是一个固定的字符串。</p> <p>当替换值(第二个参数)是一个函数时，每个匹配都会调用该函数(记住，全局搜索会在源字符串中匹配所有的模式实例)并带有一串参数列表。</p> <ul><li>匹配的完整文本。</li> <li>匹配的捕获，一个捕获对应一个参数。</li> <li>匹配字符在源字符串中的索引。</li> <li>源字符串。</li></ul> <p>函数的返回值是即将要替换的值。</p> <p>例如，在如下代码中，我们使用一个函数，动态的将中横线分隔的字符转换成等价的驼峰拼写字符串。</p> <div class="language- extra-class"><pre class="language-text"><code> function upper(all,letter) {
    return letter.toUpperCase();
}
assert(&quot;border-bottom-width&quot;.replace(/-(\w)/g,upper),&quot;Camel cased a hyphenated string.&quot;);
</code></pre></div><p>在这里，我们提供了一个正则表达式，用于匹配中横线字符后的任意一个字符。全局正则中的捕获结果就是该匹配的字符(不包括中横线)。函数在每次被调用的时候，传入完整的字符串作为第一个参数，捕获结果作为第二个参数。我们对其他参数不感兴趣，所以没有指定它们。</p> <p>函数在第一次被调用的时候，传入了&quot;-b&quot;和&quot;b&quot;，第二次被调用的时候传入的时&quot;-w&quot;和&quot;w&quot;,在本例中，将捕获字符转换成大写，并作为替换值返回。最周将&quot;-b&quot;替换成了&quot;B&quot;,将&quot;-w&quot;替换成了&quot;W&quot;。</p> <p>由于全局正则在每次成功匹配的时候都会调用这样的替换函数。这种技术甚至可以超越简单的机械替换，并且可以作为字符串遍历的一种手段，而不用像签名看到的那样，在while循环中hi下exec()方法。</p> <p>举例来说，我们想让一个查询字符串转换成另外一个符合我们需求的格式。比如，将<code>foo=1&amp;foo=2&amp;blah==a&amp;blah=b&amp;foo=3</code>转换成如下这样格式:<code>foo=1,2,3&amp;blah=a,b</code> 其解决方案时，使用正则表达式以及replace()可以将其转换成特别简洁的代码，实例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>function compress(source) {
    //保存局部键(key)
    var keys = {};
    //提取键值对(key/value)信息
    source.replace(
        /([^=&amp;]+)=([^&amp;]*)/g,
        function(full,key,value) {
        keys[key] = (keys[key]?keys[key]+&quot;,&quot;:&quot;&quot;)+value;
        return &quot;&quot;;
        }
    )
    //收集键(key)的信息
    var result = [];
    for (var key in keys) {
        result.push(key+&quot;=&quot;+keys[key]);
    }
    //使用&amp;将结果进行合并
    return result.join(&quot;&amp;&quot;);
}

assert(compress(&quot;foo=1&amp;foo=2&amp;blah==a&amp;blah=b&amp;foo=3&quot;)==&quot;foo=1,2,3&amp;blah=a,b&quot;,&quot;Compression is OK!&quot;);
</code></pre></div><p>上述代码中，最有趣的一点是如何使用字符串的replace()方法来遍历一个字符串，而不是一个实际的搜索替换机制。其关键点有两个:传递一个函数作为替换值参数，该函数并不是返回实际的值，而是简单的利用它作为一种搜索手段。</p> <p>示例代码首先声明一个哈希，用于保持在源查询字符串中找到的键值对(key/value)。然后在源字符串上调用replace()方法，传入匹配键值对的正则，并捕获匹配的键(key)和值(value)。我们还传入了一个函数，该函数将接收完整匹配值，捕获的键(key)，捕获的值(value)作为参数。这些捕获的值将保存在哈希中，以供稍后进行引用。</p> <p>注意，在函数里，我们只是简单返回一个空字符串，因为我们却是不关注源字符串中发生的替换操作----我们只需要利用该函数的副作用，而不需要实际替换结果。</p> <p>在replace()返回后，我们声明一个数组，然后遍历查找到的keys，并且每个结果都集合到该数组中。最后，使用&amp;分隔符，将数组中的所有结果都合并成一个字符串，然后返回该字符串。</p> <p>利用这种技巧，我们可以使用String对象的replace()方法作为字符串搜索机制。搜索结果不仅快速，而且简单，有效。</p> <h3 id="利用正则表达式解决常见问题"><a href="#利用正则表达式解决常见问题" class="header-anchor">#</a> 利用正则表达式解决常见问题</h3> <h4 id="修剪字符串"><a href="#修剪字符串" class="header-anchor">#</a> 修剪字符串</h4> <p>将字符串前后多余的空格进行删除是一种常见的需求，但String对象却没有这种功能(最近才有)。对于没有String.trim()方法的旧浏览器，几乎所有的JavaScript库都提供了一种实现。</p> <p>例如，从字符串中剔除空格的常见解决方案:</p> <div class="language- extra-class"><pre class="language-text"><code>function trim(str){
    return (str||&quot;&quot;).replace(/^\s+|\s+$/g,&quot;&quot;);
}
assert(trim(&quot; #id div.class&quot;)==&quot;#id div.class&quot;,&quot;Extra whitespace trimmed from a selector string.&quot;);
</code></pre></div><p>不是遍历每个字符来判断是否需要修剪，而是只调用了一次replace()方法，并传入一个匹配字符串开头和结尾空格的正则来完成这项工作的。</p> <p>在这些解决方案中，有两个方案特别有趣。第一个是使用正则表达式来完成，但没有使用\s+和操作符，示例如下。</p> <p>双重替换的修剪实现方式:</p> <div class="language- extra-class"><pre class="language-text"><code>function trim(str){
    return str.replace(/^\s\s*/,&quot;&quot;).replace(/\s\s*$/,&quot;&quot;);
}
assert(trim(&quot; #id div.class&quot;)==&quot;#id div.class&quot;,&quot;Extra whitespace trimmed from a selector string.&quot;);
</code></pre></div><p>该实现执行两次替换:一个是开头的空格，另一个是结尾的空格。</p> <p>另一种方案，完全放弃了用正则表达式从字符串结尾进行空格查找，而是手工来完成的。示例如下所示。</p> <p>使用字符串热slice方法剔除字符串尾部空格的方式:</p> <div class="language- extra-class"><pre class="language-text"><code>function trim(str){
    var str = str.replace(/^\s\s*/,&quot;&quot;),
        ws = /\s/,
        i=str.length;
    while (ws.test(str.charAt(--i)));
    return str.slice(0,i+1);
}
assert(trim(&quot; #id div.class&quot;)==&quot;#id div.class&quot;,&quot;Extra whitespace trimmed from a selector string.&quot;);
</code></pre></div><p>这种实现，使用一个正则表达式剔除字符串开头的空格，并使用slice操作符剔除字符串尾部的空格。</p> <p>对这些方案的性能进行比较，使用短字符串和文档级的字符串，有很明显的区别。下面是显示执行1000次trim()迭代所花费的毫秒时间：</p> <div class="language- extra-class"><pre class="language-text"><code>       trim()实现                      短字符串                        文档
     字符串中剔除空格                     8.7ms                       2075.8ms
      双重替换的修剪                      8.5ms                       3706.7ms
字符串热slice方法剔除字符串尾部空格         13.8ms                      169.4ms
</code></pre></div><p>从比较结果很容易看出，哪些实现是最可伸缩的。字符串热slice方法剔除字符串尾部空格 的实现，在短字符串变现不加，但在更长的(文档)字符串操作时，却超越了另外两种方案。</p> <h4 id="匹配换行符"><a href="#匹配换行符" class="header-anchor">#</a> 匹配换行符</h4> <p>在执行一个搜索时，有时候会用点(.)术语，用于匹配除换行符以外的任意字符。在其他语言中的正则表达式实现中，可以用一个标识来标记是否包含换行符，但是JavaScript的实现里却没有这么做。</p> <p>在JavaScript中可以避免该漏洞的两种方法，代码如下。</p> <p>匹配所有的字符，包括换行符:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个测试对象
var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;World&lt;/i&gt;&quot;;
//显示换行符没有被匹配到
assert(/.*/.exec(html)[0]===&quot;&lt;b&gt;Hello&lt;/b&gt;&quot;,&quot;A normal capture doesn't handle endlines.&quot;);
//使用空白符匹配方式匹配所有的元素
assert(/[\S\s]*/.exec(html)[0] === &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;World&lt;/i&gt;&quot;,&quot;Matching everything with a character set.&quot;);
//用另外一种方式匹配所有元素
assert(/(?:.|\s)*/.exec(html)[0],&quot;Using a non-capturing group to match everything.&quot;);
</code></pre></div><p>在代码中，我们定义了一个包含换行符的测试字符串。然后尝试用多种方式匹配字符串中的所有字符。</p> <p>在第一个测试中，我们验证换行浮不会被点(.)操作符匹配到。</p> <p>在接下来测试中，用另外一个正则表达式来匹配,/[|S\s]*/，在该表达式中，我们定义一个字符类，用于匹配任何不是空白字符的字符，以及匹配任意的一个空白字符。所以，该联合结果就是匹配所有的字符。</p> <p>接下来的另外一种方法是，使用另外一个正则表达式:/(?:,|\s)*/，在该表达式里，我们用点(.)匹配除换行符以外的所有内容，以及所有是空白的字符，包括换行符。其结果也是包含换行符在内的所有字符。请注意，被动子表达式的使用，是用于防止任何以外的捕获。</p> <p>根据代码的简单性(以及隐式性能效益)，/[\S\s]*/提供的解决方案通常被认为是最佳方案。</p> <h4 id="unicode"><a href="#unicode" class="header-anchor">#</a> Unicode</h4> <p>使用正则表达式的时候，我们经常希望匹配字母型字符，比如ID选择器在CSS选择器引擎中的实现。但如果假设字母只能是英文字母，那目光就太短浅了。</p> <p>有时候将字符扩展到Unicode字符是可取的，以显示支持没有被传统字母字符集覆盖到其他多种语言，示例如下。</p> <div class="language- extra-class"><pre class="language-text"><code>var test = &quot;\u5FCD\u8005\u30D1\u30EF\u30FC&quot;;

var matchAll = /[\w\u0080-\uFFFF_-]+/;

assert((text).match(matchAll),&quot;Our regexp matches unicode!&quot;);
</code></pre></div><p>在上述代码中，通过创建一个包括\w术语的字符类，可以将字符匹配范围扩展到整个Unicode字符集，在加上一套字符代码在128(十六进制为0x80)以上的字符，从而匹配所有的&quot;正常&quot;字符。从128开始，不仅可以匹配所有的Unicode字符，也可以匹配ASCII字符。</p> <p>精明的人可能会注意到，通过在\u0080上添加整个Unicode字符集，我们不仅可以匹配字母字符，还可以匹配到所有的Unicode标点符号，以及其他特殊字符(例如，剪头)。不过这样没问题的，该示例的目的是展示如何匹配Unicode字符。如果要匹配特定范围的字符，可以在这个例子上添加任何字符范围。</p> <h4 id="转义字符"><a href="#转义字符" class="header-anchor">#</a> 转义字符</h4> <p>对于页面开发人员来说，给页面元素赋值一个符合程序标识符规范的id值，是一项很普通的工作，但这只是一个惯例。id值可以包含&quot;单词&quot;以外的字符，包括标点符号。例如，Web开发人员可能会将元素的id值设置为form:update。</p> <p>库开发人员，在编写CSS选择器引擎时，要通过转义字符来支持这项功能。这允许用户可以指定不符合典型命名约定的复杂名字。让我们开发一个正则表达式，以便能够匹配转义字符。</p> <p>在CSS选择器中匹配转义字符:</p> <div class="language- extra-class"><pre class="language-text"><code>//该正则表达式允许匹配一个单词字符，或一个反斜杠及后面跟随任意字符(甚至是另外一个反斜杠),
//或者两者都可以匹配
var pattern = /^((\w+)|(\\.))+$/;
//设置不同的测试对象，除了最后一个都应该通过测试，因为其未能匹配到非单词字符(:)
var tests = [
    &quot;formUpdate&quot;,
    &quot;form\\.update\\.whatever&quot;,
    &quot;form\\:update&quot;,
    &quot;\\f\\0\\r\\m\\u\\p\\d\\a\\t\\e&quot;,
    &quot;form:update&quot;
];
for (var i = 0; i &lt; tests.length; i++) {
    assert(pattern.test(tests[i]),tests[i]+&quot; is a valid identifier&quot;);
}
</code></pre></div><p>这个特殊表达式允许匹配一个单词字符序列，或在一个反斜杠后面跟随任何字符的序列。</p> <h2 id="驯服线程和定时器"><a href="#驯服线程和定时器" class="header-anchor">#</a> 驯服线程和定时器</h2> <p>在JavaScript中，定时器是一个经常被误用且不被众人所知的特性，但如果能在复杂应用程序中正确应用定时器的话，就会给开发人员带来非常多的好处。</p> <p>注意，我们说，定时器可以在JavaScript中使用，但我们没说它是JavaScript自身的一个功能----定时器不是JavaScript的一项功能。定时器作为对象和方法的一部分，才能在浏览器中使用。也就是说，如果我们在非浏览器环境中使用JavaScript，很有可能定时器就不存在了。我们不得不使用特定实现的功能(如Rhino中的线程)，来实现我们自己的定时器版本。</p> <p>定时器提供了一种让一段嗲吗在一定毫秒之后，在异步执行的能力。由于JavaScript是单线程的特性(同一时间只能执行一处JavaScript代码)，定时器提供了一种跳出这种限制的方法，以一种不太直观的方式来执行代码。</p> <h5 id="注意-html-web-worker将会对定时器做出很多改变-但目前现代浏览器还都不支持-所以-理解当前浏览器是如何执行定时器的-仍然是很重要的。"><a href="#注意-html-web-worker将会对定时器做出很多改变-但目前现代浏览器还都不支持-所以-理解当前浏览器是如何执行定时器的-仍然是很重要的。" class="header-anchor">#</a> 注意:HTML Web worker将会对定时器做出很多改变，但目前现代浏览器还都不支持，所以，理解当前浏览器是如何执行定时器的，仍然是很重要的。</h5> <h3 id="定时器和线程是如何工作的"><a href="#定时器和线程是如何工作的" class="header-anchor">#</a> 定时器和线程是如何工作的</h3> <h4 id="设置和清除定时器"><a href="#设置和清除定时器" class="header-anchor">#</a> 设置和清除定时器</h4> <p>JavaScript提供了两种方式，用于创建定时器以及两个相应的清除方法(删除)。这些方法都是window对象()全局上下文上的方法。</p> <p>JavaScript定时器的操作方法(均为window方法):</p> <p><img src="/book/1601022334188.jpg" alt=""></p> <p>这些方法允许我们设置和清除定时器，可以让定时器在一个时间点之后触发，也可以每隔一段时间之后再触发。实际过程中，大多数浏览器都允许使用clearTimeout()或clearInterval()取消定时器，但如果不确定，那么就建议成对使用。</p> <p>有一个需要理解的重要概念，就是JavaScript定时器的延时时间是不能保证的。原因和JavaScript线程的本质有很大关系。</p> <h4 id="执行线程中的定时器执行"><a href="#执行线程中的定时器执行" class="header-anchor">#</a> 执行线程中的定时器执行</h4> <p>再Web worker可用之前，浏览器中的所有JavaScript代码都是再单线程中执行的。是的只有一个线程。</p> <p>这种情况的不可避免的结果就是:异步事件的处理程序，如用户界面事件和定时器，再线程中没有代码执行的时候才进行执行。这就是，处理程序再执行时必须进行排队执行，并且一个处理程序并不能中断另外一个处理程序的执行。</p> <p><img src="/book/1601022972942.jpg" alt=""></p> <p>有很多信息需要消化，但完全理解以后，就会对JavaScript的异步执行工作有一个更好的理解。该图是一张一维图，运行时间(以毫秒为单位)沿着x轴从左到右。盒子表示的是JavaScript代码的执行部分，以及执行的时间。例如，第一个主线JavaScript代码块大约执行了18毫秒，鼠标单击代码块执行了大约10毫秒等。</p> <p>由于JavaScript的单线程特性，JavaScript再同一时间只能执行一个代码块，这些代码块的执行就阻塞了异步事件的处理。这意味着，当一个异步事件发生时(如，鼠标单击，定时器触发甚至是XMLHttpRequest的完成事件)，它就会排队，并且再线程空闲时才进行执行。实际上，每个浏览器的排队机制是不同的，所以我们认为它就是简单的进行排队，但这足够我们对这个概念进行很好的理解了。</p> <p>从0毫秒开始，第一个JavaScript块要持续执行18毫秒才结束，在其执行期间，发生了一些重要的事件。</p> <ul><li>在0毫秒时，启动一个10毫秒延迟的定时器，以及一个10毫秒延迟的间隔定时器。</li> <li>在第6毫秒时，进行鼠标单击。</li> <li>在10毫秒时，定时器和第一个间隔定时器都过期了。</li></ul> <p>在正常情况下，如果没有别的代码目前正在执行，我们期望在第6毫秒处，鼠标单击处理程序立即执行，并且在第10毫秒处，定时器处理程序也会执行。然而，由于第一个代码块还在执行，所以在这期间这些处理程序都不能被执行。由于JavaScript的单线程特性，处理程序需要进行排队，并在线程可用的时候在进行执行。</p> <p>初始代码块在18毫秒处结束执行时，有三个代码块在排队执行:click单击处理程序，timeout处理程序以及interval第一次调用时的处理程序。假设浏览器会使用FIFO机制(先进先出)，但是请记住，如果这样做的话，浏览器可能会选择一个更复杂的算法。也就是等待click单击处理程序开始执行(我们原来时假设要在10毫秒处进行执行的)。</p> <p>在timeout处理程序执行时，第二个interval在20毫秒处也到期了。再一次，由于timeout处理程序占用了线程，所以interval处理程序是不能被执行的。但是这一次，由于已经有一个interval回调的实例在排队并等待执行了，所以这一次的调用将被废弃。浏览器不会对特定interval处理程序的多个实例进行排队。</p> <p>click处理程序在第28毫秒处结束执行，并等待我们期望在第10毫秒就要运行的timeout处理程序，最终会在第28毫秒处才开始执行。这就是之前所说的，无法保证指定延迟是否能够决定处理程序何时执行。</p> <p>在30毫秒处，interval又触发了，但是，再一次，由于队列中已经有了interval定时器的实例，所以这次触发又作废了。</p> <p>在34毫秒处，timeout处理程序执行结束，队列中的interval处理程序将开始执行。但由于该处理程序需要执行6毫秒，所以在执行期间，另外一个interval在40毫秒处又触发了，从而导致新的interval处理程序又进行了排队等候。第一个调用在第42毫秒处结束以后，这个在队列中排队的处理程序就可以开始执行了。</p> <p>这一次，该处理程序在47毫秒处完成了执行，遭遇下一个interval触发的50毫秒处。所以第5个处理程序触发时，不需要进行排队，就立即执行了。</p> <p>从这一切可用看出一个重要的概念就是，由于JavaScript是单线程的，在特定的时间点只能运行一个执行代码，而且我们也不能确定定时器处理程序到底是在什么时候执行的。</p> <p>尤其是interval处理程序。在本例中，我们可以看到，尽管我们开启了一个预期在第10毫秒，第20毫秒，第30毫秒，第40毫秒，第50毫秒处进行触发的interval定时器，但只有其中三个实例在第35毫秒，42毫秒处进行了执行。</p> <h4 id="timeout与interval之间的区别"><a href="#timeout与interval之间的区别" class="header-anchor">#</a> timeout与interval之间的区别</h4> <p>interval间隔定时器可能像是周期性执行的timeout定时器一样。但是它们的不同之处要更多一些。举个例子来说setTimeout()和setInterval()之间的差异，实例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个timeout定时器，每10毫秒都重新调度自己
setTimeout(function repeatMe(){
    setTimeout(repeatMe,10);
},10);
//定义一个interval定时器，每10毫秒都触发一次
setInterval(function(){},10)
</code></pre></div><p>上述代码中，功能似乎是相同的，但实际上不是。值得注意的是，在setTimeout()代码中，要在前一个callback回调执行结束并延迟10秒就尝试执行callback回调，而不是关注上一个callback是如何执行的。</p> <p>回顾前面的实例，定时器回调从来不保证执行的具体时间。它并非像interval定时器那样每隔10毫秒触发一次，而是在执行之后重新设置定时器10毫秒后再次触发。</p> <ul><li>JavaScript引擎是单线程执行，异步事件必须要排队等待才能执行。</li> <li>如果无法立即执行定时器，该定时器会被推迟到下一个可用的执行时间点上(可能更长，但不会比指定的延迟时间更少)。</li> <li>如果一直被延迟，到最后，Interval间隔定时器可能会无延迟执行，并且同一个interval处理程序的多个实例不能同时进行排队。</li> <li>setTimeout()和setInterval()在触发周期的定义上完全不同的。</li></ul> <h3 id="定时器延迟的最小化及其可靠性"><a href="#定时器延迟的最小化及其可靠性" class="header-anchor">#</a> 定时器延迟的最小化及其可靠性</h3> <p>很明显，虽然我们可以将定时器的延迟指定为秒，分，小时----或任意需要的间隔值----但不明显的是，我们不知道如何选择定时器延迟的最小值。</p> <p>在某种程度上，对于定时器的准确执行，浏览器无法提供好的延迟建议，因为它们本身受操作系统的时间限制。</p> <p>几年前，将延迟指定为10毫秒会被任务是过于乐观的选择。但最近有很多人关注了JavaScript在浏览器中的性能改善，所以我们来测试一下。设置一个interval间隔定时器，指定1毫秒的延迟，对前100次触发进行测试，测试每个间隔调用之间的实际延迟时间。</p> <p>测试结果如下:</p> <p><img src="/book/1601026529171.jpg" alt=""></p> <p><img src="/book/1601026806934.jpg" alt=""></p> <p>这些图表示的是，在100次间隔运行中每个延迟值出现的次数。</p> <p>在OS X操作系统下，我们发现，Firefox的平均值约为4毫秒，几乎比预期延迟时间都长，有一个甚至达到了22毫秒。Chrome的表现相对一致，平均值约为4毫秒或5毫秒，但Safari却表显得相当慢，平均都在10毫秒。Opera11则是最快的浏览器，100次运行中，有高达56次都是延迟1毫秒。</p> <p>在Windows操作系统下的测试显示，Firefox的延迟时间依然是零分分部的，在整个图上没有明显的峰值。Chrome表现良好，平均4毫秒，而IE9则相当悲惨，大多数的都是21毫秒。而Opera再一次领先，机会每个延迟都是1毫秒。</p> <h5 id="注意-这些测试配置如下-macbook-pro-2-5ghz-intel-core2双核处理器-4gb内存-osx-10-6-7操作系统-windows7笔记本-intel-quad-q9550-2-83ghz处理器-4gb内存。"><a href="#注意-这些测试配置如下-macbook-pro-2-5ghz-intel-core2双核处理器-4gb内存-osx-10-6-7操作系统-windows7笔记本-intel-quad-q9550-2-83ghz处理器-4gb内存。" class="header-anchor">#</a> 注意:这些测试配置如下，MacBook Pro:2.5GHz Intel Core2双核处理器，4GB内存，OSX 10.6.7操作系统；Windows7笔记本:Intel Quad Q9550 2.83GHZ处理器，4GB内存。</h5> <p>我们可以得出结论，现代浏览器通常无法实现1毫秒粒度的可持续间隔，但某些浏览器的实现却真的非常接近。</p> <p>在我们的测试中，我们指定的延迟时间是1毫秒，但也可以指定为0毫秒。不过，IE浏览器有个缺陷:当我们对setInterval()设置0毫秒的延迟时，该定时器的callback回调只会执行一次。和使用setTimeout()的效果一样。</p> <p>从这些图标中，我们还可以学到另外一些东西。最重要的是强化了之前学到的知识:浏览器不保证我们指定的延迟间隔。虽然可以指定特定的延迟值，但其准确性却并不总是能够保证，尤其是在延迟值很小的时候。</p> <p>在应用程序中使用定时器的时候需要考虑这些因素。如果觉得10毫秒和15毫秒的差异有问题，或者如果需要提供比例浏览器更细粒度的延迟值的话，我们可能需要冲洗考虑一下我们的方法，因为浏览器不能包装这种细粒度的延迟。</p> <h5 id="注意-在大多数情况下-是使用闭包来给定时器或间隔定时器-传递-数据的。但现代webkit-mozilla和opera浏览器-但不包括ie9和之前的任何版本-也允许我们在声明这些定时器的时候传入额外的参数。例如-settimeout-callback-interval-arg1-arg2-arg3-会给callback回调传递arg1-arg2-arg3三个参数。"><a href="#注意-在大多数情况下-是使用闭包来给定时器或间隔定时器-传递-数据的。但现代webkit-mozilla和opera浏览器-但不包括ie9和之前的任何版本-也允许我们在声明这些定时器的时候传入额外的参数。例如-settimeout-callback-interval-arg1-arg2-arg3-会给callback回调传递arg1-arg2-arg3三个参数。" class="header-anchor">#</a> 注意:在大多数情况下，是使用闭包来给定时器或间隔定时器&quot;传递&quot;数据的。但现代WebKit,Mozilla和Opera浏览器(但不包括IE9和之前的任何版本)，也允许我们在声明这些定时器的时候传入额外的参数。例如，setTimeout(callback,interval,arg1,arg2,arg3)会给callback回调传递arg1, arg2,arg3三个参数。</h5> <h3 id="处理昂贵的计算过程"><a href="#处理昂贵的计算过程" class="header-anchor">#</a> 处理昂贵的计算过程</h3> <p>JavaScript的单线程本质可能是JavaScript复杂应用程序开发中的最大&quot;陷阱&quot;。在JavaScript执行繁忙的时候，浏览器中的用户交互，最好的情况是操作稍有缓慢，最差的情况则是反应迟钝。这可能会导致浏览器很卡或者似乎要挂掉，因为在JavaScript执行的时候，页面渲染的所有更新操作都要暂停。</p> <p>因此，如果要保持页面有良好的响应能力，减少运行时间超过几百毫秒的复杂操作，将其控制在可管理状态是非常必要的。此外，如果一段脚本的运行时间超过5秒，有些浏览器将弹出一个对话框警告用户该脚本&quot;无法响应&quot;。而其他浏览器，比如iPhone上的浏览器，将默认终止运行时间超过5秒钟的脚本。</p> <p>一段代码如果一直在执行，肯定也会让人很不爽快，而且会产生不响应的用户页面。但在处理大量数据的时候，几乎肯定会出现这种情况，比如，在操纵上千个DOM元素的时候。</p> <p>这时候，定时器就可以来拯救我们了，其会变的特别有用。作为定时器，它在一段时间之后，可以有效暂停一段JavaScript代码的执行，定时器还可以将代码的各个部分，分解成不会让浏览器挂掉的碎片。</p> <p>考虑到这一点，我们可以将强循环和操作转化为非阻塞操作。</p> <p>一个长时间运行的任务:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;script&gt;
    //查找&lt;tbody&gt;元素，我们将在该元素上面创建大量的行元素
    var table = document.getElementsByTagName(&quot;tbody&quot;)[0];
    //创建20000个行，达到一个量级
    for (var i = 0; i &lt; 20000;i++) {
        //单独创建的行
        var tr = document.createElement(&quot;tr&quot;);
        //对于每个行，都创建6个列，每个列包含一个文本节点
        for (var t = 0; t&lt;6; t++) {
            var td = document.createElement(&quot;td&quot;);
            td.appendChild(document,createTextNode(i+&quot;,&quot;+t));
            tr.appendChild(td);
        }
        //将每个行元素都附件到父元素上
        tbody.appendChild(tr);
    }

&lt;/script&gt;
</code></pre></div><p>在本例中，我们创建了240000个DOM节点，并使用大量的单元格来填充一个表格。这是非常昂贵的操作，很明显会增加浏览器的执行时间，从而阻止正常的用户交互操作。</p> <p>在本例代码中的这种情况，我们可以引入定时器，在代码执行的时候定期暂停休息，示例如下。</p> <p>利用定时器分解长时间运行的任务:</p> <div class="language- extra-class"><pre class="language-text"><code>var rowCount = 20000;
var divideInto = 4;
var chunkSize = rowCount / divideInto;
var iteration = 0;

var table = document.getElementsByTagName(&quot;tbody&quot;)[0];

setTimeout(function generateRows(){
var base = (chunkSize)*iteration;
for (var i = 0; i &lt; chunkSize;i++){
    var tr = document.createElement(&quot;tr&quot;);
    for(var t=0;t&lt;6;t++){
        var td = document.createElement(&quot;td&quot;);
        td.appendChild(document.createTextNode((i+base)+&quot;,&quot;+t+&quot;,&quot;+iteration));
        tr.appendChild(td);
    }

    table.appendChild(tr);
}
iteration++;
if (iteration&lt;divideInto) {
    setTimeout(generateRows,0);
}
},0)
</code></pre></div><p>在该版本的示例中，我们将冗长的操作拆分成四步小操作，每个操作创建自己的DOM节点。这些较小的操作，则不太可能让浏览器挂掉。</p> <p>注意:我们是如何进行设置的，以便让数据值的控制操作可以根据变量很容易的调整，比方说，我们应该发现，我们需要将操作拆分成10个部分，而不是4个部分。</p> <p>还有一个与数学有点关系的重要内容需要注意，我们需要跟踪上一次迭代中断的地方，以及如何自动安排下一个迭代，一直到全部结束。</p> <p>令人印象深刻的是，为了适应这种新的异步方式，我们只需要改动很少一部分代码。我们还需要做一些额外的工作，来跟中执行的代码，确保操作正确进行，以及调度其他执行部分。除此之外，核心代码和之前的代码，看起来非常类似。</p> <p>从用户角度来看，这种技术带来的最明显变化，是很卡的浏览器页面，换成了四部分(或者我们可以选择更多部分)可以进行视觉变化更新的页面。尽管浏览器会尝试尽快执行我们的代码段，但在每一个定时器执行之后，浏览器还是会渲染DOM更新的。在初始版本的代码中，需要等待一次大的批量更新。</p> <p>很多时候，这些类型的更新操作，用户是无法察觉的，但重要的是要记住，它们有可能发生，我们应该努力确保，在页面中引入的代码不会明显中断浏览器的正常运行。</p> <p>在大学生排课系统的应用程序构建中使用该技术。刚开始，该应用程序是一个典型CGI程序(客户端与服务器进行通信，排课表在服务器端进行计算并返回)，但转换以后，所有的排课计算都转义到客户端上了。排课计算的屏幕视图，如图所示:</p> <p><img src="/book/1601044858169.jpg" alt=""></p> <p>这些操作是相当昂贵的(需要贯穿成千上万的排列，才能找到正确的结果)。性能问题是通过将排列计算分解成切实可行的小块，在执行的过程中，通过完成的百分比来更新用户界面。最终，为用户呈现了一个快速，灵敏且高度可用的可用界面。</p> <h3 id="中央定时器控制"><a href="#中央定时器控制" class="header-anchor">#</a> 中央定时器控制</h3> <p>使用定时器可能出现的问题是对大批量定时器的管理。这在处理动画时尤其重要，因为在试图操纵大量属性的同时，我们还需要一种方式来管理它们。</p> <p>管理多个定时器会出现很多问题，原因有很多。存在的问题不仅是要保留大量间隔定时器的引用，然后迟早还必须取消它们(尽管我们知道可以使用闭包来管理这种换乱)，而且还干扰了浏览器的正常运行。我们之前看到，确保定时器处理程序不吃香过于冗长的操作，可以防止我们的代码阻塞其他操作，但也有一些其他浏览器已经考虑这方面了。其中之一就是垃圾回收。</p> <p>同时创建大量的定时器，将会在浏览器中增加垃圾回收任务发生的可能性。大致说来，垃圾回收就是浏览器遍历其分配过的内存，并视图删除没有任何应用的未使用对象的过程。定时器是一个特殊的问题，因为通常它们是在JavaScript单线程引擎之外的流程中进行管理的(通过其他浏览器线程)。</p> <p>有些浏览器可以很好的处理这种情况，但其他一些浏览器的垃圾回收周期则很长。大家可能已经注意到了，一个动画在某个浏览器中很漂亮，很刘畅，但在另外一个浏览器中却很卡顿。减少同时使用定时器的数量，将大大有助于解决这种问题，这就是为什么是所有现代动画引擎都使用一种成为中央定时器控制的技术。</p> <p>在多个定时器中使用中央定时器控制，可以带来很大的威力和灵活性。</p> <ul><li>每个页面在同一时间只需要运行一个定时器。</li> <li>可以根据需要暂停和恢复定时器。</li> <li>删除回调函数的过程变得很简单。</li></ul> <p>让我们看一个使用该技术来管理多个函数的例子，被管理的这些函数分别操作不同的动画属性。首先，创建一个定时器以及用于管理多个处理程序的函数，示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>var timers = {
    timerID:0,
    timers:[],
    add:function(fn){
        this.timers.push(fn);
    },
    start:function(){
        if(this.timerID) return;
        (function runNext(){
            if (timers.timers.length&gt;0) {
                for(var i=0;i&lt;timers.timers.length;i++){
                    if(timers.timers[i]()===false){
                        timers.timers.splice(i,1);
                        i--;
                    }
                }
                timers.timerID = setTimeout(runNext,0);
            }
        })()
    },
    stop: function(){
        cleaTimeout(this.timerID);
        this.timerID = 0;
    }
};
</code></pre></div><p>在代码中，我们创建了一个中央控制结构，我们可以在该结构上添加任意数量的定时器回调函数，而且还可以通过它，启动和停止该结构的执行。此外，在任何时候如果callback回调函数返回了false值，都允许将其删除，这比典型的clearTimeout()更方便。</p> <p>一开始，所有的回调函数都存储于一个名为timers的数组中，还包括当前定时器的一个ID。这些变量是定时器唯一需要维护的内容。</p> <p>add()方法接受一个callback回调，并简单将其添加到timers数组中。</p> <p>真正的核心是start()方法。在该方法内，首先确认没有定时器在运行(通过检查timerID是否有值)，如果确认没有定时器在执行，立即执行一个即时函数来开启中央定时器。</p> <p>在即时函数内，如果注册了处理程序，就遍历执行每个处理程序。如果有处理程序返回false，我们就从数组中将其删除，最后进行下一次调度。</p> <p>使用这个中央定时器，我们需要创建一个元素进行动画操作:<code>&lt;div id=&quot;box&quot;&gt;Hello!&lt;/div&gt;</code> 然后，使用如下代码开启动画:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;box&quot;&gt;Hello!&lt;/div&gt;

var box = document.getElementById(&quot;box&quot;),x=0,y=20;
timers.add(function(){
    box.style.left = x+&quot;px&quot;;
    if(++x&gt;50)return false;
})
timers.add(function(){
    box.style.top = y+&quot;px&quot;;
    y+=2;
    if (y&gt;120) return false;
})

timers.start();
</code></pre></div><p>获取该元素的引用，添加一个处理程序用于水平移动该元素，再添加一个处理程序用于垂直移动该元素，接着开启整个动画过程。</p> <p>重要的是要注意，以这种方式组织定时器，可以确保回调函数总是按照添加的顺序进行执行。而普通的定时器通常不会保证这种顺序，有可能后面的一个处理程序在前面就执行了。</p> <p>这种方式的定时器组织，对于大型应用程序或任何形式的JavaScript动画来说都是至关重要的。制定这样一种解决方案，必然后有利于未来应用程序的开发，尤其是动画创建。</p> <h3 id="异步测试"><a href="#异步测试" class="header-anchor">#</a> 异步测试</h3> <p>中央定时器控制带来很大便利的另外一种情形是在执行异步测试的时候。异步测试的问题是，当我们要对还没完成操作的代码(如定时器处理程序，甚至是XMLHttpRequest)执行测试时，我们需要将这种测试从测试套件中分离出来，以便该测试能完全异步。</p> <p>当需要异步测试时，我们需要分离出所有的测试，分别对它们进行处理，示例如下。</p> <p>简单的异步测试套件:</p> <div class="language- extra-class"><pre class="language-text"><code>(function(){
        //保存状态表
    var queue = [],paused = false;
    //定义测试注册的函数
    this.test = function(fn){
        queue.push(fn);
        runTest();
    }
    //定义停止测试的函数
    this.pause = function(){
        paused = true;
    }
    //定义恢复测试的函数
    this.resume = function(){
        paused = false;
        setTimeout(runTest,1);
    }
    //运行测试
    function runTest(){
        if (!paused&amp;&amp;queue.length) {
            queue.shift()();
            if (!queued) resume();
        }
    }

 })();
</code></pre></div><p>在代码中，最重要的一个方面是，传递给test()方法的每个函数，最多只包含一个异步测试。它们的异步性由pause()和resume()的使用所定义，这两个方法分别在异步事件之前或之后进行调用。确实，这段代码只不过是一种确保让包含异步行为的函数，以特定的属性进行执行的方式而已。(不是必要用于测试用例，但对于测试用例确实特别有用。)</p> <p>这些功能包含在resume()和runTest()函数中。它的行为非常类似于前面示例中的start()方法，只不过处理的是数据队列。该队列唯一的目的是在等待执行的时候，出列一个函数并进行执行。构造，就完全停止运行一个时间间隔。</p> <p>这里的要点是，由于队列处理代码是完全异步的(被包含在一个interval定时器中)，这保证在我们调用pause()函数以后，可以再次尝试执行。</p> <h2 id="忍者点金术-运行时代码求值"><a href="#忍者点金术-运行时代码求值" class="header-anchor">#</a> 忍者点金术:运行时代码求值</h2> <h3 id="代码求值机制"><a href="#代码求值机制" class="header-anchor">#</a> 代码求值机制</h3> <p>在JavaScript中，有很多不同的代码求值机制。每个机制都有其优缺点，我们需要根据所使用的上下文，谨慎选择使用哪个机制。</p> <p>这些不同的代码求值方法包括:</p> <ul><li>eval()函数。</li> <li>函数构造器。</li> <li>定时器。</li> <li><code>&lt;script&gt;</code>元素。</li></ul> <h4 id="用eval-方法进行求值"><a href="#用eval-方法进行求值" class="header-anchor">#</a> 用eval()方法进行求值</h4> <p>eval() 方法可能是在运行时进行代码求值的最常用方式了。作为定义在全局作用域内的eval()方法，该方法将在当前上下文内，执行所传入字符串形式的代码。执行返回结果则是最后一个表达式的执行结果。</p> <h4 id="基本功能"><a href="#基本功能" class="header-anchor">#</a> 基本功能</h4> <p>eval()的基本功能:</p> <ul><li>该方法将执行传入代码的字符串。</li> <li>在调用eval()方法的作用域内进行代码求值。</li></ul> <p>eval()方法的基本测试:</p> <div class="language- extra-class"><pre class="language-text"><code> //测试一个简单的表达式
assert(eval(&quot;5+5&quot;)===10,&quot;5 and 5 is 10&quot;);
//测试一个无用的代码求值
assert(eval(&quot;var ninja = 5;&quot;)===undefined,&quot;no value was returned&quot;);
//验证副作用
assert(ninja===5,&quot;The variable ninja was created&quot;);
//测试求值作用域
(function() {
    eval(&quot;var ninja=6;&quot;);
    assert(ninja===6,&quot;evaluated within the current scope.&quot;);
})();
//测试&quot;遗漏&quot;的作用域
assert(window.ninja === 5,&quot;the global scope was unaffected&quot;);

assert(ninja===5,&quot;the global scope was unaffected&quot;);

输出:
//5 and 5 is 10
//no value was returned
//The variable ninja was created
//evaluated within the current scope.
//the global scope was unaffected
//the global scope was unaffected
</code></pre></div><p>首先，给eval()方法传入一个包含简单表达式的字符串，验证它是否产生预期的结果。</p> <p>然后，尝试传入一个不产生任何值的语句，赋值语句ninja=5,并验证返回的预期的值(没有值)。但是等一下，测试还不充分。我们期望没有返回结果，但这是因为表达式执行后确实没有返回结果，还是表达式根本没有执行？还需要进一步测试。</p> <p>我们期望代码在当前作用域内被求值执行，在本例中是全局作用域，所以我们希望代码求值的副作用是创建一个名为ninja的全局作用域变量。其实，另一个简单的测试也证明了这种说法。</p> <p>接下来，在非全局作用域内，我们也想测试代码求值能够正常工作。创建一个即时函数，并在里面执行var ninja=6;,然后验证变量与期望值都存在。但是，测试依然不是很充分。是因为我们在局部作用域内创建了一个新变量，还是因为我们直接对全局作用域进行了修改，测试的ninja变量赋值为6？</p> <p>进一步测试证明了全局作用域里的ninja变量没有被修改。</p> <h4 id="求值结果"><a href="#求值结果" class="header-anchor">#</a> 求值结果</h4> <p>eval()方法将返回传入字符串中最后一个表达式的执行结果。例如，如果我们调用如下语句:<code>eval('3+4;5+6')</code> 结果将返回11。</p> <p>应该指出的是，任何不是简单变量，原始值，赋值语句的内容都需要在外卖包装一个括号，以便返回正确的结果。例如，如果我们想使用eval()创建一个简单的对象，可能编写如下语句:<code>var o=eval('{ninja:1}')</code> 但是，结果不是我们所期望的。我们需要在对象字面量外面包装一个括号，实例如下:<code>var o=eval('({ninja:1})')</code></p> <p>测试eval()返回结果:</p> <div class="language- extra-class"><pre class="language-text"><code> //从一个包含对象字面量的字符串中创建一个对象，并测试不仅创建了对象，而且该对象还有了期望的name属性
var ninja = eval(&quot;({name:'Ninja'})&quot;);
assert(ninja!=undefined,&quot;the ninja was created&quot;);

assert(ninja.name === &quot;Ninja&quot;,&quot;and with the expected property&quot;);
//从一个包含函数字面量的字符串中创建一个函数，并测试不仅创建了函数，而且函数的返回值也是符合预期的
var fn = eval(&quot;(function(){return 'Ninja'})&quot;);
assert(typeof fn==='function',&quot;the function was created&quot;);

assert(fn()===&quot;Ninja&quot;,&quot;and returns expected value&quot;);
//对第一个测试，创建另外一个版本，去除小括号。第一个测试通过了(创建了内容)，但第二个测试却失败了，
//因为对象没有对象没有按照预期进行创建(可以通过JavaScript调试器看看创建了什么内容。)
var ninja2 = eval(&quot;{name:'Ninja'}&quot;);
assert(ninja2!=undefined,&quot;ninja2 was created&quot;);
assert(ninja2.name === &quot;Ninja&quot;,&quot;and with the expected property&quot;);
</code></pre></div><p>在这里，我们使用eval()动态创建了一个对象和一个函数。注意，在这两种情况下，要求值多的语句都包装在小括号里面了。</p> <p>如果在IE8或之前版本的浏览器上运行该测试，可能会有一个令人惊讶的结果。IE9之前版本的浏览器在执行特定语法的时候有些问题。我们要被迫使用布尔表达式，才能让eval()进行正确的调试。如下代码，是jQuery在上述版本浏览器种使用eval()创建函数的代码:</p> <div class="language- extra-class"><pre class="language-text"><code>var fn=eval(&quot;false||function(){return true;}&quot;);
assert(fn()===true,&quot;The function was created correctly.&quot;);
</code></pre></div><p>该问题已在IE9中得到了修复。</p> <p>就像我们用普通方式在特定作用域内创建函数一样，eval()创建的函数会继承该作用域内的闭包----局部作用域内执行eval()时的衍生结果。</p> <h4 id="用函数构造器进行求值"><a href="#用函数构造器进行求值" class="header-anchor">#</a> 用函数构造器进行求值</h4> <p>JavaScript的所有函数都是Function的实例。可以通过像<code>functionname(...){...}</code>这样的语法创建命名函数，或者省略名称创建匿名函数。</p> <p>但是，也可以直接使用Function构造器来实例化函数，实例如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>var add= new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a+b;&quot;);
assert(add(3,4)===7,&quot;Function created and working！&quot;);
</code></pre></div><p>Function构造器可变参数列表的最后一个参数，始终是要创建函数的函数体内容。前面的参数则表示函数的形参名称。</p> <p>所以，上述代码等价于如下代码:<code>var add=function(a,b){return a+b}</code></p> <p>虽然这些代码在功能上是等同的，但采用Function构造器方式有一个明显的区别，函数体由运行时的字符串所提供。</p> <p>另外一个及其重要的实现区别是，使用Function构造器创建函数的时候，不会创建闭包。也不想承担任何不相关闭包的开销时，这可能是一件好事。</p> <h4 id="用定时器进行求值"><a href="#用定时器进行求值" class="header-anchor">#</a> 用定时器进行求值</h4> <p>还有另外一种方式，可以让代码字符串进行求值，而且是异步的，那就是通过定时器进行求值。</p> <p>通常我们给定时器传递一个内联函数或函数引用。这是setTimeout()和setInterval()方法推荐使用的方式，但是这些方法也可以接受字符串的传入，从而定时器触发的时候进行求值。</p> <p>示例如下:<code>var tick = window.setTimeout('alert(&quot;Hi！&quot;)'，100)</code></p> <h4 id="全局作用域内的求值操作"><a href="#全局作用域内的求值操作" class="header-anchor">#</a> 全局作用域内的求值操作</h4> <p>再讨论eval()方法的时候我们强调，求值执行的作用域就是调用eval()时的作用域。但我们通常可能希望代码字符串再全局作用域内进行求值，而不是当前执行作用域内。</p> <p>例如，在有些函数内，我们可能想在全局作用域内执行代码，示例如下：</p> <div class="language- extra-class"><pre class="language-text"><code>(function(){
    eval(&quot;var test=5&quot;)
})();
assert(test===5,&quot;Variable created in global scope&quot;);//失败
</code></pre></div><p>如果我们期望即时函数的执行结果是在全局作用域内创建变量test，我们的测试结果将会令人是我----失败了。因为求值的执行作用域是在即时函数内部，变量作用域也是如此。</p> <p>这种情况的描述，如图所示:</p> <p><img src="/book/1601207463757.jpg" alt=""></p> <p>一个天真的解决方案，是将代码修改成如下方式:<code>eval(&quot;window.test=5&quot;)</code></p> <p>尽管这种方式可以将变量定义在全局作用域内，但这并不能改变求值的作用域，我们仍期望作用域内是局部作用域，而不是全局作用域。在本例种，我们简单赋值一个数组字面量，但是，如果我们将变量从局部作用域做指向的话，这就变得很重要了。</p> <p>但是还有一个策略，我们可以使用现代浏览器来实现我们的目标:将要执行的代码放在动态的<code>&lt;script&gt;</code>内，并将标签注入到文档中。</p> <p>在全局作用域内求值代码:</p> <div class="language- extra-class"><pre class="language-text"><code>function globalEval(data){
    //定义一个全局eval函数
    data=data.replace(/^\s*|\s*$/g,&quot;&quot;);
    if(data){
        var head = document.getElementsByTagName(&quot;head&quot;)[0]||document.documentElement,
        //创建一个script节点
        script = document.createElement(&quot;script&quot;);
        script.type=&quot;text/javascript&quot;;
        script.text = data;
        //将script节点附加到DOM上
        head.appendChild(script);
        //再去删除它
        head.removeChild(script);
    }
}

window.onload = function () {
    (function () {
        globalEval(&quot;var test=5&quot;);
    })();
    assert(test === 5,&quot;The code was evaluated globally.&quot;);
}
</code></pre></div><p>上述代码出人意料的简单。在eval()方法中，我们定义了一个名为globalEval()的函数，以便在全局作用域内求值任何想要求值的内容。</p> <p>该函数去除了所传字符串中的所有前导和尾部空白字符,然后定位DOM中的<code>&lt;head&gt;</code> 元素或文档本身，并创建一个分离的<code>&lt;script&gt;</code>元素。</p> <p>设置script元素的类型，然后把需要求值的字符串加载到该script元素的body内。</p> <p>将script元素附加到DOM上，作为head元素的一个子字节，将会导致该脚本在全局作用域内进行求值。完成之后，script元素就可以随便丢掉了。</p> <h4 id="安全的代码求值"><a href="#安全的代码求值" class="header-anchor">#</a> 安全的代码求值</h4> <p>关于代码求值，进场出现的一个问题是，如何安全地执行JavaScript代码。换句话说，在不损害网站完整性的情况下，可以安全的执行不可信的JavaScript吗？毕竟，如果要求值的代码不是我们提供的，天知道它可能包含什么啊！</p> <p>有些异想天开的程序员可能会提供一段代码字符，执行无线循环，或删除必要的DOM元素，或搞砸所有重要的数据。或者，甚至更糟糕的是，有恶意的程序员会有目的的注入威胁网站安全的代码。</p> <p>一般来说，这个问题的答案是&quot;无解&quot;。有太多的方式可以让任意代码回避哪些防御性代码，从而可能导致这些代码获得不应该获得的信息，或引起其他问题。</p> <p>举个例子，看一下如下代码:</p> <div class="language- extra-class"><pre class="language-text"><code>var test = true;
(function(){var foo=5;})();
Function.prototype.toString = function(){};
</code></pre></div><p><img src="/book/1601210236514.jpg" alt=""></p> <p>注意，上述代码广泛使用了原生方法和属性来验证数据的完整性，其中大部分是在运行时进行验证的。还要之处的是，使用多个下划线的粗糙名称，是为了强调避免与页面上可能用到的名称重名。</p> <p>渴望安全地执行随机JavaScript代码，通常源于想要创建混合网站和嵌入性广告，而又不用担心信息安全泄漏。在这个领域，我们肯定看到很多工作，Google Caja可能就是领导者。</p> <h3 id="函数反编译"><a href="#函数反编译" class="header-anchor">#</a> 函数反编译</h3> <p>大多数JavaScript实现，还提供一种将已求值过的JavaScript代码进行&quot;反编译&quot;的功能。</p> <p>将函数反编译成字符串:</p> <div class="language- extra-class"><pre class="language-text"><code>fucntion test(a){return a+a;}
assert(test.toString()===&quot;function test(a){return a+a;}&quot;,&quot;Function decompiled&quot;);
</code></pre></div><p>在测试中，我们创建一个简单的test函数，然后断言函数的toString()方法会返回函数的原始文本。</p> <p>需要注意的一件事是:toString()的返回值包含原始声明的所有空格，包括行结束符。出于测试目的，在代码中，我们剔除了这些字符，定义了一个只有一行的简单函数。如果复制该文件，并对其进行格式化操作，那么测试就会失败，除非字符串匹配的一模一样。所以请注意，在反编译函数的时候，需要考虑空格和函数体的格式。</p> <p>反编译行为有很多潜在的用途，尤其是在宏指令和代码重写的时候。在Prototype JavaScript库中，有一个比较有趣的应用是，将函数进行反编译从而读取该函数的参数，然后将这些参数名称保存到一个数组中。这是非常常用的，通常用于确定函数想得到什么样的参数值。</p> <p>查找函数参数名称的函数:</p> <div class="language- extra-class"><pre class="language-text"><code>function argumentNames(fn){
    //查找参数列表
    var found = /^[\s\(]*function[^(]*\(\s*([^)]*?)\s*\)/.exec(fn.toString());
    //分隔参数列表
    return found&amp;&amp;found[1]?found[1].split(/,\s*/):[];
}
//测试零参数场景
assert(argumentNames(function(){}).length===0,&quot;Works on zero-arg functions.&quot;);
//测试一个参数的场景
assert(argumentNames(function(){})[0]===&quot;x&quot;,&quot;Single argument working.&quot;);
//测试多个参数的场景
var results = argumentNames(function(a,b,c,d,e){});
assert(results[0]=='a'&amp;&amp; 
        results[1]=='b'&amp;&amp;
        results[1]=='c'&amp;&amp;
        results[1]=='d'&amp;&amp;
        results[1]=='e',
        &quot;Multiple arguments working!&quot;
);
//输出:
//Works on zero-arg functions.
//Single argument working.
//Multiple arguments working!
</code></pre></div><p>该函数只有几行代码，但在这几行语句中，却使用了很多JavaScript高级特性。首先，该函数反编译传入的函数，并使用正则表达式，将这些参数从逗号分隔的参数列表抽取出来。</p> <p>注意，由于exec()方法接收一个字符串做参数，所以我们在这里也可以不用toString()，因为不用的话，该函数也会隐式调用它。我们在这里显示调用它，是为了清晰展示。</p> <p>接下来，将抽取的结果保存在组件值中，并执行检查，确保也考虑零个参数等场景。</p> <p>以这种方式反编译函数时，需要考虑一个很重要的问题:有浏览器可能不支持反编译。虽然不是很多，但其中之一就是Opera Mini浏览器。如果浏览器支持列表中有Opera Mini，就需要考虑要不要使用函数反编译的功能了。</p> <p>正如签名所强调的，我们当然不希望通过浏览器检测来确定是否支持反编译功能。而是要使用特性仿真来测试浏览器是否支持反编译功能，其中一种方式的示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>var FUNCTION_DECOMPILATION = /abc(.|\n)*xyz/.test(function(abc){xyz;});
assert(FUNCTION_DECOMPILATION,&quot;Function decopilation works in this browser&quot;);
</code></pre></div><p>再一次使用了正则表达式，向test()方法传入一个函数(这里让其进行toString()的隐式调用，因为该方法要接收一个字符串)，并将结果存储在一个变量中，以供稍后使用。</p> <h3 id="代码求值实战"><a href="#代码求值实战" class="header-anchor">#</a> 代码求值实战</h3> <h4 id="json转化"><a href="#json转化" class="header-anchor">#</a> JSON转化</h4> <p>运行时求值的最广泛使用方式是将JSON字符串转换为JavaScript对象表示法。由于JSON数据仅仅是JavaScript语言的一个子集，它是完全能够被求值为JavaScript代码。</p> <p>大多数的现代浏览器，都支持带有parse()和stringify()方法的原生JSON对象，但早期的一些浏览器却不提供这样的JSON对象。对于这些早期浏览器，制导在没有window.JSON的清空下如何对JSON进行处理依然是非常重要的。</p> <p>但是，最好的计划也会经常出现一些问题，有一个小陷阱我们必须考虑。为了求值，我们需要将描述结构的文本包装在小括号内。实施起来非常简单，只需要记住它就行了。代码如下:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个JSON源，描述一个单属性对象
var json = '{&quot;name&quot;:&quot;Ninja&quot;}';
//将JSON转换为JavaScript对象
var object = eval(&quot;(&quot;+json+&quot;)&quot;);
//验证转换是否成功
assert(object.name === &quot;Ninja&quot;,&quot;My name is Ninja!&quot;);
</code></pre></div><p>非常简单----在大多数JavaScript引擎中都表现良好。</p> <p>但使用eval()做JSON解析时需要注意的主要是:通常，JSON数据来自于远程服务器，，而且，就像前面所支出的，盲目执行远程服务器上的不可信代码，基本是不可取的。</p> <p>最受欢迎的JSON转换器脚本是由JSON标记的创造者Douglas Crockford所编写。</p> <p>Douglas Crockford的函数在实际求值之前，执行一些重要的预处理操作。</p> <ul><li>防范一些可能在某些浏览器上引起问题的Unicode字符。</li> <li>防范恶意显示的非JSON内容，包括赋值运算符和new操作符。</li> <li>确保只包含了符合JSON规范的字符。</li></ul> <p>如果我们要求值的JSON来自于我们自己的代码和服务器，或其他的可信来源，通常不需要担心恶意代码注入(尽管可能还要在检测一下，但这样做从来都不是一件坏事)。但是当我们没有理由相信要求值的JSON时，使用像Douglas Crockford所提供的保障措施是一个谨慎做法。</p> <h4 id="导入有命名空间的代码"><a href="#导入有命名空间的代码" class="header-anchor">#</a> 导入有命名空间的代码</h4> <p>在前面，我们谈到了使用命名空间化的代码防止污染当前上下文----通常是全局上下文。这是一件好事。但是如果要将命名空间化的代码引入当前上下文，那又该如何做呢？</p> <p>这个问题很有挑战性，考虑到在JavaScript语言中没有简单或支持的方法。大多数时候，我们不得不使用类似如下这样的代码:</p> <div class="language- extra-class"><pre class="language-text"><code>var DOM = base2.DOM;
var JSON = base2.JSON;
</code></pre></div><p>对于将命名空间导入到当前上下文，base2库提供了一个非常有趣的解决方案。因为没有办法将该问题进行自动化操作，因此我们可以利用运行时求值该实现变得更简单。</p> <p>每当一个新类或模块添加到base2包的时候，构造可执行代码的字符串，对其进行求值，可以将产生的函数引入到当前上下文中，实例如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义要导入的名称
base2.namespace = &quot;var Base=base2.Base;var Package=base2.Package;&quot;+
                  &quot;var Abstract=base2.Abstract;var Module=base2.Module;&quot;+
                  &quot;var Enumerable=base2.Enumerable;var Map=base2.Map;&quot;+
                  &quot;var Collection=base2.Collection;var RegGrp=base2.RegGrp;&quot;+
                  &quot;var Undefined=base2.Undefined;var Null=base2.Null;&quot;+
                  &quot;var This=base2.This;var True=base2.True;var False=base2.False;&quot;+
                  &quot;var assignID=base2.assignID;var delect=base2.delect;&quot;+
                  &quot;var global=base2.global;var lang=base2.lang;&quot;+
                  &quot;var JavaScript=base2.JavaScript;var JST=base2.JST;&quot;+
                  &quot;var JSON=base2.JSON;var IO=base2.IO;var MiniWeb=base2.MiniWeb;&quot;+
                  &quot;var DOM=base2.DOM;var JSB=base2.JSB;var code=base2.code;&quot;+
                  &quot;var doc=base2.doc;&quot;;
//求值之前先进行测试，确保要定义的名称还没有存在
assert(typeof This === &quot;undefined&quot;,&quot;The This object doesn't exist.&quot;)
//对要导入的内容进行求值
eval(base2.namespace);
//求值之后，测试这些名称都成功导入了
assert(typeof This=== &quot;function&quot;,&quot;And now the namespace is imported.&quot;);
assert(typeof Collection===&quot;function&quot;,&quot;Verifying the namespace import.&quot;);
</code></pre></div><p>这是一个用于解决复杂问题的非常巧妙的方法。它可能不是最优雅的方式，但在未来版本的JavaScript支持这种功能之前，我们不得不使用已有的方法来解决问题。</p> <h4 id="javascript压缩和混淆"><a href="#javascript压缩和混淆" class="header-anchor">#</a> JavaScript压缩和混淆</h4> <p>客户端代码的一个现实情况是，需要以某种方式将代码获取到客户端上。因此，保持传输占用量尽可能小是主要目标。我们可以尝试将代码编写的尽可能的少，但这会导致产生糟糕且难以阅读的代码。最好是将代码编写的越清晰越好，然后在进行压缩传输。</p> <p>对于帮助解决第二部分功能的JavaScript软件，有一个很流行的JavaScript软件是Dean Edwards的Packer。该压缩器可以很智能的压缩JavaScript代码，提供了一个明显比原始文件小很多的JavaScript文件，同时仍然能够自解压并且执行。</p> <p>使用该工具的结果是将JavaScript代码转换为一个编码字符串，然后使用eval()函数进行求值。结果通常看起来像如下这样:</p> <div class="language- extra-class"><pre class="language-text"><code>eval(function(p,a,c,k,e,r){e=function(c){return(c&lt;a?'':e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return '\\w+'};c=1};while(c--)if(k[c])p=p.repalce(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p})
</code></pre></div><p>虽然这种结束很只能也很有趣，但它有一些基本的缺陷，每次加载压缩脚本的开销都很昂贵。</p> <p>在分发一段JavaScript代码时，通常认为，最小的代码在下载和加载时速度是最快的。但这并不总是如此----小代码可能下载得很快，但求值不一定很快。归根结底，下载和求值之间得组合对页面得性能才是最重要得。分解成如下简单得公式:<code>load time = download time + evaluation time</code> 加载时间=下载时间+求值时间</p> <p>让我们来看以三种形式加载jQuery的不同速度:</p> <ul><li>正常(为压缩)。</li> <li>最小化，使用雅虎得YUI Compressor删除空白并执行其他一些简单得技巧。</li> <li>使用Dean Edwards得Packer进行打包，使用eval()进行大规模得重写和解压。</li></ul> <p>根据文件大小进行排序，打包方式是最小的，然后是最小化方式，最后是未压缩方式，并且我们预计文件得下载和文件大小成正比。但打包方式却有很大的开销:它必须在客户端先解压在求值。这个解压操作浪费了很多加载时间，最后，最小化方式得加载时间比打包方式要快的多，尽管其文件大小比打包方式还大。</p> <p><img src="/book/1601283050127.jpg" alt=""></p> <p>这并不是说，使用Packer压缩是不值得的----远非如此。但是如果我们得目标只是性能，它可能不是我们得最佳选择。</p> <p>但是性能不一定总是我们得首要关注点。即使有额外得开销，如果需要代码混淆，Packer也可以是一个有价值得工具。不像服务器端代码，一个合理安全得Web应用程序是完全无法从客户端进行访问得，JavaScript代码必须被发送到客户端进行执行。比较，浏览器不能执行任何没有接收到的代码。</p> <p>回到Web页面上得最复杂脚本来实现简单得活动，如图像翻转，没有人关心代码是如何被发送到客户端得，并且代码也可以让任何人查看。但最近一段时间，在高度使用Ajax得页面和所谓单页面应用程序上，代码得数量和复杂性越来越高，并且一些组织也向公众公开了相关代码。</p> <h4 id="动态重写代码"><a href="#动态重写代码" class="header-anchor">#</a> 动态重写代码</h4> <p>由于我们可以使用函数得toString()方法反编译现有得JavaScript函数，我们可以从现有函数中提取并加工原有函数得内容，从而创建一个新函数。</p> <p>Screw.Unit使用库中提供了函数，将现有测试函数中得内容进行了动态重写。例如，一个典型得Screw.Unit测试应该像如下这样:</p> <div class="language- extra-class"><pre class="language-text"><code>describe(&quot;Matchers&quot;,function(){
    it(&quot;invokes the provided matcher on a call to expect&quot;,function(){
        expect(true).to(equal,true);
        expect(true).to_not(equal,false);
    })
})
</code></pre></div><p>注意这些方法:describe(),it()以及expect()。这些方法在全局作用域内都不存在。要让这段代码正常运行，Screw.Unit重写了这段代码，使用多个with(){}语句，将函数内部得内容注入到需要执行得函数中。示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>var contents = fn.toString().match(/^[^{]*{((.*\n*)*)}/m)[1];
var fn = new Function(&quot;matchers&quot;,&quot;specifications&quot;,&quot;with (specifications){with(mathers){&quot;+contents+&quot;}}&quot;);
fn.call(this,Screw.Mathcers,Screw.Specifications);
</code></pre></div><h4 id="面向切面得脚本标签"><a href="#面向切面得脚本标签" class="header-anchor">#</a> 面向切面得脚本标签</h4> <p>AOP，或面向方面变成，维基百科将其定义为&quot;一种旨在通过分离横切关注点而增加模块化得编程范式&quot;。</p> <p>追根究底，AOP技术可以在运行时将代码进行注入并执行一些&quot;横切&quot;代码，如日志记录，缓存，安全性检查等。AOP引擎将在运行时添加日志代码，而不是在原有代码中添加大量得日志语句，以便让开发人员在开发期间不用关注这些事情。</p> <p>定义自定义脚本类型是非常简单的，因为浏览器会忽略任何无法识别得脚本类型。通过使用一个不标准得类型值，我们可以强制浏览器完全忽视一个脚本块。</p> <p>如果要创建得新类型名为&quot;onload&quot;,我们可以很容易的，通过指定如下脚本块来实现:<code>&lt;script type=&quot;x/onload&quot;&gt; ...custom script here...&lt;/script&gt;</code></p> <p>注意，我们使用统一约定得&quot;x&quot;表示自定义类型。我们打算用这样得块来包含正常得JavaScript代码，以便在页面加载时进行执行，而不是通常得内联执行。</p> <p>创建一个在页面加载后才执行得脚本标签类型:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
        //查找所有的脚本块
        var scripts = document.getElementsByTagName(&quot;script&quot;);
        //判断并执行&quot;x/load&quot;块
        for (var i = 0; i &lt; scripts.length; i++){
            if (scripts[i].type == &quot;x/onload&quot;) {
                globalEval(scripts[i].innerHTML);
            }
        }
    }

&lt;/script&gt;
&lt;script type=&quot;x/onload&quot;&gt;
    //提供自定义脚本
    assert(true,&quot;Executed on page load&quot;);
&lt;/script&gt;
</code></pre></div><p>在本例中，我们提供一个浏览器忽略执行得自定义脚本块。在页面得onload处理程序中，查询所有的脚本块，在筛选自定义类型的脚本块，最后用前面开发的globalEval()函数，在全局作用域内对脚本块得内容进行求值。</p> <p>这是一个简单得例子，但这种技术有更复杂且更有意义得用途。例如，将自定义脚本块和jQuery.tmpl()方法一起使用，用于提供运行时模块。利用它可以在用户界面上执行脚本，或者在准备操作DOM得时候，甚至是相邻元素上执行脚本。</p> <h4 id="元语言和领域特定语言"><a href="#元语言和领域特定语言" class="header-anchor">#</a> 元语言和领域特定语言</h4> <p>关于运行时代码求值得一个重要示例，可以在构建于JavaScript之上得其他编程语言实现中看到:元语言。如果你愿意，可以将其动态转换成JavaScript源代码并求值，通常，这种定制语言非常特别于开发人员得业务需求，并且已经创造了领域特定语言(DSL)这样得名字。</p> <h4 id="processing-js"><a href="#processing-js" class="header-anchor">#</a> Processing.js</h4> <p>Processing.js时Processing可视化语言得一部分，该可视化语言通常使用java实现。JavaScript得实现运行在HTML5得Canvas元素上，由John Resig创建。</p> <p>这种实现是一种完整得编程语言，可以用来操作绘图区域得视觉显示。可以说，Processing.js非常适合这个任务，能够使其成为一个高效得编程实现。</p> <p>如下时一个Processing.js示例代码，使用了类型为&quot;application/processing&quot;得脚本块:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script type=&quot;application/processing&quot;&gt;
    class SpinSpots extends Spin{
        float dim;
        SpinSpots(float x, float y,float s,float d){
            super(x,y,s);
            dim = d;
        }
        void display(){
            noStroke();
            pushMatrix();
            translate(x,y);
            angle+=speed;
            rotate(angle);
            ellipse(-dim/2,0,dim,dim);
            ellipse(dim/2,0,dim,dim);
            popMatrix();
        }
    }
&lt;/script&gt;
</code></pre></div><p>上述Processing.js代码，将被转换为JavaScript代码，并使用elval()进行调用。如下时生成得JavaScript代码:</p> <div class="language- extra-class"><pre class="language-text"><code>function SpinSpots(){
    with(this){
        var __self = this;function superMethod(){
            extendClass(__self,arguments,Spin);
            this.dim = 0;
            extendClass(__self,Spin);
            addMethod(this,'display',function(){
                noStroke();
                pushMatrix();
                translate(x,y);
                angle+=speed;
                rotate(angle);
                ellipse(-dim/2,0,dim,dim);
                ellipse(dim/2,0,dim,dim);
                popMatrix();
            });
            if (arguments.length==4) {
                var x=arguments[0];
                var y=arguments[1];
                var s=arguments[2];
                var d=arguments[3];
                superMethod(x,y,s);
                dim = d;
            }
        }
    }
}
</code></pre></div><p>通过使用Processing.js语言，我们获得一些使用JavaScript时所没有的直接好处。</p> <ul><li>从Processing高级语言特性中获益(如类和继承)。</li> <li>获取Processing的简单但强大的绘图API。</li> <li>可以使用Processing现有的文档和示例。</li></ul> <h4 id="objective-j"><a href="#objective-j" class="header-anchor">#</a> Objective-J</h4> <p>使用领域特定语言的第二个主要项目时Objective-J，是Objective-C编程语言的JavaScript实现，由280North公司创建，Objective-J被用于280Slides产品。</p> <p>280North团队有着丰富的OS X应用开发经验，主要是使用Objective-C语言，为了创造一个更有效率的工作环境，它们将Objective-C语言之外，Objective-J还允许JavaScript代码和Objective-C代码混在一起。一个例子如下所示:</p> <p><img src="/book/1601302977327.jpg" alt=""></p> <p>该Objective-C解析程序，是由JavaScript编写的，并可以在运行阶段转换Objective-J代码，它们使用轻量级表达式进行匹配并处理Objective-C语言代码，而不是干扰现有的JavaScript代码。其处理结果是一个JavaScript代码字符串，用于在运行时进行求值操作。</p> <h2 id="with语句"><a href="#with语句" class="header-anchor">#</a> with语句</h2> <h3 id="with是怎么回事"><a href="#with是怎么回事" class="header-anchor">#</a> with是怎么回事</h3> <p>with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。</p> <p>有很多使用with带来便利的场景。</p> <ul><li>对深层级对象的引用进行缩短。</li> <li>简化测试代码。</li> <li>将属性作为全局属性暴露给模板。</li> <li>其他更多场景。</li></ul> <h4 id="在with作用域内引用属性"><a href="#在with作用域内引用属性" class="header-anchor">#</a> 在with作用域内引用属性</h4> <p>首先，先让我们关注一下with语句的基本工作原理，示例如下。</p> <p>利用一个对象创建一个with作用域:</p> <div class="language- extra-class"><pre class="language-text"><code>//定义全局变量
var uer = &quot;other&quot;;
//创建一个对象
var katana = {
    isSharp:true,
    use:function(){
        this.isSharp = !this.isSharp;
    }
};
//建立一个with作用域
with(katana){
    //在作用域内进行测试
    assert(use!==&quot;other&quot;&amp;&amp;typeof use == &quot;function&quot;,&quot;use is a function from the katana object.&quot;);
    assert(this !== katana,&quot;context isn't changed;keeps its original value.&quot;);
}
//在作用域外进行测试
assert(use === &quot;other&quot;,&quot;outside the with use is unaffected.&quot;);
assert(typeof isSharp === &quot;undefined&quot;,&quot;outside the with the properties don't exist.&quot;);

//输出:
//use is a function from the katana object.
//context isn't changed;keeps its original value.
//outside the with use is unaffected.
//outside the with the properties don't exist.
</code></pre></div><p>在上述代码中，我们可以看到katana对象的属性是如何引入到with语句创建的作用域的。在该作用域内，我们可以直接引用属性名称，而不必使用katana前缀，好像它们就是全局变量和全局方法一样。</p> <p>为了验证这一点，我们首先定义一个名为use的顶级变量，然后创建一个内联对象，并使用同样的名字use作为该对象的属性，另外还有一个名为isSharp的属性。该变量由变量katana所引用。</p> <p>在使用katana建立with作用域的时候，事情变得有趣起来了。在该作用域内，katana的属性可以被直接引用，而无需使用katana前缀。通过验证可以看到，当前use的值不是全局变量use的值，而是一个函数，也就是我们所期望的katana.use()方法。</p> <p>在with语句之外的作用域继续测试，验证use引用的是顶级变量，而且isSharp属性也不再可用。</p> <p>注意，在with语句的作用域内，对象属性的优先级绝对高于在更高层级作用域内定义的同名变量。这是with被嘲笑的主要原因之一，with作用域内的代码意义可能是含糊不清的。</p> <p>我们也证明了函数上下文(this)是不受with语句影响的。</p> <h4 id="在with作用域内进行赋值"><a href="#在with作用域内进行赋值" class="header-anchor">#</a> 在with作用域内进行赋值</h4> <p>让我们来看一个在with作用域内进行赋值的例子，示例如下。</p> <p>with作用域内的赋值操作:</p> <div class="language- extra-class"><pre class="language-text"><code>//创建一个对象
var katana = {
    isSharp:true,
    use:function(){
        this.isSharp = !this.isSharp;
    }
};
with(katana){
    isSharp = false;
    //给现有属性进行赋值
    //测试赋值操作
    assert(katana.isSharp = false,&quot;properties can be assigned&quot;);
    //尝试创建新属性
    cut = function(){
        isSharp = false;
    }
    //测试赋值操作
    assert(typeof katana.cut == &quot;function&quot;,&quot;new properties can be created on the scoped object&quot;);
    assert(typeof window.cut == &quot;function&quot;,&quot;new properties can be created in the global scope&quot;);
}
</code></pre></div><p>在上述代码中，创建了一个和上述相同的katana对象，并拥有use和isSharp属性，然后再次利用该对象创建一个with作用域。这次不是要对属性进行引用操作，而是进行赋值操作。</p> <p>首先，给isSharp属性赋值为false。如果isSharp赋值的是katana的属性，预计该属性的值就会从初始的true转变为false。我们对该数学进行显示测试，测试是通过了。这证明了，我们可以使用无前缀引用对对象的属性进行读取和赋值操作。</p> <p>然后尝试一些不那么简单的操作:创建一个函数并赋值为cut。那么问题就来了，cut属性将在哪个作用域内进行创建？会因为赋值操作是在with作用域内进行的，就认为cut属性就在该作用域内创建吗？</p> <p>为了找出哪一种情况是对的，我们编写两个测试，其中只有一个能成功。第一个测试会断言该属性将在katana上进行创建，第二个测试则断言该属性会在全局作用域内被创建。</p> <p>由于第二个测试通过，对with作用域内不存在的属性进行赋值操作，将会导致在全局上下文内进行赋值操作。</p> <p>如果要在katana上创建新属性，就需要使用对象引用前缀，即便是在with作用域内也要这样做，示例如下:<code>katana.cut = funtion(){isSharp = false}</code></p> <p>好了，这种方式非常简单，就是除with作用域之外的场景所需要做的，但这与with作用域始终是第一优先级的目标相违背的。不管怎么说，使用with作用域的时候需要注意，属性名的简单错误可以导致奇怪且思想不到的结果，即引进了一个新的全局变量，而不是修改with作用域对象的现有属性。当然，这也就是我们通过需要注意的，所以需要像往常一样非常仔细的对代码进行测试。</p> <h4 id="性能方面的注意事项"><a href="#性能方面的注意事项" class="header-anchor">#</a> 性能方面的注意事项</h4> <p>使用with的时候，还有另外一个重要因素需要注意:它降低了所包含JavaScript代码的执行性能，而不仅仅是局限于与交互的对象。如下代码清单。</p> <p>with语句的性能测试:</p> <div class="language- extra-class"><pre class="language-text"><code>//声明一些变量
var ninja = {foo:&quot;bar&quot;},
value,
maxCount = 1000000,
n,
start,
elapsed;
//测试不用with时的情况
start = new Date().getTime();
for (n=0;n&lt;maxCount;n++) {
        value = ninja.foo;
}
elapsed = new Date().getTime()-start;

assert(true,&quot;Without with:&quot;+elapsed);
//测试with内的引用操作
start = new Date().getTime();
with(ninja){
    for(n=0;n&lt;maxCount;n++){
        value = foo;
    }
}

elapsed = new Date().getTime()-start;

assert(true,&quot;Without with(with access):&quot;+elapsed);
//测试with内的赋值操作
start = new Date().getTime();
with(ninja){
    for(n=0;n&lt;maxCount;n++){
        value = n;
    }
}

elapsed = new Date().getTime()-start;

assert(true,&quot;With(with assignment):&quot;+elapsed);
//测试with内不进行访问操作时的情况
start = new Date().getTime();
with(ninja){
    for(n=0;n&lt;maxCount;n++){
        value = &quot;no test&quot;;
    }
}
elapsed = new Date().getTime()-start;

assert(true,&quot;With (with access):&quot;+elapsed);

</code></pre></div><p>对于这些性能测试，我们声明了一些列变量，包括一个作为with作用域目标的(ninja)变量。然后运行四个测试，每个测试执行一百万次操作，然后显示其操作。</p> <ul><li>第一个测试，在没有声明任何with作用域的情况下，用ninja.foo属性的值进行赋值。</li> <li>第二个测试，执行了相同的赋值操作，但该赋值操作是在with作用域内进行的，并且引用foo属性的时候不使用前缀。</li> <li>第三个测试，在with作用域内，将一个值(循环计数器)赋值给不使用前缀的foo属性。</li> <li>最后一个测试，在with作用域内，对变量value进行赋值，而根本不访问ninja对象。</li></ul> <p><img src="/book/1601307224313.jpg" alt=""></p> <p>上述测试的运行结果如图,所有的测试都会在表中列出的浏览器上运行，上述浏览器系统配置是MacBook Pro,OS X Lion 10.7.3,2.8GHz Core i7处理器，8GB内存，IE测试是在并行虚拟机中的window7上运行的。所有的时间都以毫秒为单位。</p> <p>测试结果是戏剧性的且十分令人惊讶。不仅不同的浏览器之间有很大变化，而且不同的测试之间也有很大变化。</p> <h3 id="真实示例"><a href="#真实示例" class="header-anchor">#</a> 真实示例</h3> <p>毋庸置疑，使用with的最常见的原因是，在属性访问时，不必重复使用变量的引用。JavaScript库经常使用with作为简化语句的一种方式，否则视觉上看起来就很复杂。</p> <p>如下是一些主流库中的使用例子，先从Prototype中的一个例子开始，示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>Object.extend(String.prototype.escapeHTML,{
    div:document.createElement('div'),
    text:document.createTextNode('')
});
with(String.prototype.escapeHTML) div.appendChild(text); 
</code></pre></div><p>在这里，Prototype使用with语句，避免了String.prototype.escapeHTML的div和text属性的引用前缀，否则的话，每个属性都要使用前缀。</p> <p>但是，这里确实有必要使用with吗？是否能够想到我们已经讨论过的，可以实现相同目标而又不必使用with作用域的方法？考虑以下代码:</p> <div class="language- extra-class"><pre class="language-text"><code>(function(s){
    s.div.appendChild(s.text);
})(String.prototype.escapeHTML);
</code></pre></div><p>在即时函数的作用域内，长引用String.prototype.escapeHTML可以通过一个简单函数参数s进行引用。尽管和with作用域不完全相同----此处没有消除前缀，取而代之的是更短的引用----很多开发者都会认为，将一个复杂的引用转换成一个简单引用，远比完全消除前缀的方式要好。而且，由于with即将被废弃，使用即时函数可以让我们通过语言构造把复杂的引用转换为一个全新的别名，从而方便理解且继续得到支持。</p> <p>如下是另外一个with示例，源自base2 JavaScript库:</p> <div class="language- extra-class"><pre class="language-text"><code>with(document.body.style){
    backgroundRepeat = &quot;no-repeat&quot;;
    backroundImage = &quot;url(http://ie7-js.googlecode.com/svn/trunk/lib/blank.gif)&quot;;
    backgroundAttachment = &quot;fixed&quot;;
}
</code></pre></div><p>在该代码中，base2使用with就是为了使用简单的，不重复冗长的前缀，在本例中是document.body.style。这使得我们可以对DOM的样式对象进行一些非常简单的修改。</p> <p>另外一个源自base2的示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>var Rect = Base.extend({
    constructor:function(left,top,width,height){
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
        this.right = left+width;
        this.bottom = top+height;
    },
    contains:function(x,y){
        with(this)
            return x&gt;=left&amp;&amp;x&lt;=right&amp;&amp;y&gt;=top&amp;&amp;y&lt;=bottom;
    },
    toString:function(){
        with(this) return [left,top,width,height].join(&quot;,&quot;);
    }
});
</code></pre></div><p>第二个示例中，base2使用with用于实例属性的简单询问。通常情况下，这段代码会更长，但是使用with以后的简洁性，可以让代码更清晰。</p> <p>最后一个实例，源自于Firefox的Firebug开发人员扩展:</p> <div class="language- extra-class"><pre class="language-text"><code>const evalScriptPre = &quot;with(__scope__.vars){with(__scope__.api){&quot; + &quot; with(__scope__userVars){with(window){&quot;; const evalScriptPost=&quot;}}}}&quot;;
</code></pre></div><p>Firebug中的这些代码尤其复杂----在公用代码中，这可能是使用with时的最复杂的代码了。这些语句用于扩展的调试器部分，允许用户在JavaScript控制台里，访问局部变量，firebug API以及全局对象。这种方式的操作通常超出了大多数应用程序的范围，但它有助于显示with的功能，以及如何利用它简化复杂的代码片段。</p> <h3 id="导入有命名空间的代码-2"><a href="#导入有命名空间的代码-2" class="header-anchor">#</a> 导入有命名空间的代码</h3> <p>如前所示，with语句的最常见用途之一是简化有大量对象属性引用的语句。我们可以经常在命名空间代码中看到，在命名空间代码中定义一些对象，用于提供一个有组织的结构并命名代码。</p> <p>该技术的一个副作用是，一次又一次的重新输入对象名称空间，会让人感到乏味。</p> <p>观察如下代码中的两个语句，这两个语句都使用YUI JavaScript库执行了相同的操作。第一个语句是我们在不是用with时会编写的内容，第二个语句使用了with:</p> <div class="language- extra-class"><pre class="language-text"><code>YAHOO.util.Event.on(
    [YAHOO.util.Dom.get('item'),YAHOO.util.Dom.get('otheritem')],
    'click',function(){
        YAHOO.util.Dom.setStyle(this,'color','#c00');
    }
);
with(YAHOO.util.Dom){
    YAHOO.util.Event.on([get('item'),get('otheritem')],'click',
    function(){setStyle(this,'color','#c00');});
}
</code></pre></div><p>额外增加一个with语句，极大的增加了代码的简单性。</p> <h3 id="测试"><a href="#测试" class="header-anchor">#</a> 测试</h3> <p>在测试套件中测试代码功能的时候，有几件事必须要时刻注意。其中最重要的一次是在当前运行的断言方法和测试用例中，主张使用同步方法。通常这不是什么大问题，但在处理异步测试时，它会成为麻烦。</p> <p>该问题的通用解决方案时，为每个测试运行创建一个中央跟踪对象。Prototype和script.aculo.us库的测试运行器都遵循这种模式，提供一个中央对象作为每次测试时的上下文。该对象包含了所有需要的断言方法，并且可以很方便的将测试结果收集返回到中央位置。在如下代码中，可以看到这种方式的示例:</p> <div class="language- extra-class"><pre class="language-text"><code>new Test.Unit.Runner({
    testSliderBasics:function(){
        with(this){
            var slider = new Control.Slider('handle1','track1');
            assertInstanceOf(Control.Slider,slider);
            assertEqual('horizontal',slider.axis);
            assertEqual(false,slider.disabled);
            assertEqual(0,slider.value);
        }
    }
})
</code></pre></div><p>注意在上述测试运行中with(this)的使用。该实例变量包含了所有的断言方法(assertInstanceOf,assertEqual等)。这些断言方法也可以显示使用this.assertEqual，但通过with(this)引出我们要用的断言方法，可以得到更简单的代码。</p> <h3 id="使用with进行模板化"><a href="#使用with进行模板化" class="header-anchor">#</a> 使用with进行模板化</h3> <p>我们会考虑的最后一个，可能也是最具有说服力的with使用示例是:在一个简化的模板系统中使用with。</p> <p>模板系统的目标通常包括一下功能。</p> <ul><li>应该有一种运行嵌入式代码和打印数据的方法。</li> <li>应该有一种缓存编译模板的方法。</li> <li>访问映射数据应该很简单。</li></ul> <p>最后一点，就使用with变得特别有用。</p> <p>在了解如何在实现中使用with之前，先让我们看一个使用模板系统的模板示例，代码如下所示。</p> <p>生成HTML页面的实例模板:</p> <p><img src="/book/1601350428452.jpg" alt=""> <img src="/book/1601350493960.jpg" alt=""></p> <p>在上述模板中，特殊分隔符用于区分嵌入式JavaScript代码(&lt;%和%&gt;)和表达式求值(&lt;%=和%&gt;)。Java开发人员可能认识这些分隔符，其是用于匹配旧式的JSP1模板(JSP2在2002替换了JSP1)。</p> <p>现在，让我们在如下代码中，看一下模板系统的实现。</p> <p>使用with的模板解决方案:</p> <p><img src="/book/1601350732148.jpg" alt=""> <img src="/book/1601350818845.jpg" alt=""></p> <p>我们不会深入挖掘模板系统的实现细节，即使它没有用到任何我们还没有讲到的概念，它的实现方式依然相当复杂，如果此时没有完全理解它，也不应感觉很糟。重要的是，如何利用with作用域，将传入数据的属性提供给模板。这将使得data对象的属性，可以在模板中进行引用，就像它们时顶级变量一样。</p> <p>虽然很复杂，但这个模板系统却提供了一个快速上手的变量替换功能。通过运行用户传入一个对象(包含希望填充的模板变量的名称和值)，并通过简单的方式访问这些变量，其结果就是产生一个简单且可重要的系统。这很大程度上是由于with语句的存在，才可以很容易的让属性在模板中进行引用。</p> <p>模板系统是通过将提供的模板字符串转换成一个数组，然后最终连接起来的。比如，单独的语句&lt;%=name%&gt;，是一个先将其转换成更容易识别的name，然后将其折叠进数组内的构造过程。结果就是得到一个快速且有效的模板构建系统。</p> <p>此外，这些模板都是动态生成的(出于必要，因为内联代码是允许执行的)。为了方便重用已经生成的模板，我们可以将所有的模板构建都放在一个新的Function(...)函数里，从而生成一个模板函数，可以让我们积极的插入数据。</p> <p>完整的模板系统是将嵌入式模板的使用结合在一起。我们利用了现代浏览器和搜索引擎提供的一个很大的漏洞:对于一个<code>&lt;script&gt;</code>元素，如果它们不识别<code>&lt;script&gt;</code>元素的类型，它们将完全忽略。这意味着，我们可以使用脚本包含模板，将脚本的类型指定为&quot;text/tmpl&quot;，并赋值一个唯一ID，稍后在使用模板系统来抽取这些模板内容。</p> <h2 id="开发浏览器策略"><a href="#开发浏览器策略" class="header-anchor">#</a> 开发浏览器策略</h2> <h3 id="选择要支持的浏览器"><a href="#选择要支持的浏览器" class="header-anchor">#</a> 选择要支持的浏览器</h3> <p>在选择支持某个浏览器时，我们通常会做出如下承诺。</p> <ul><li>用我们的测试套件在该浏览器上进行积极测试。</li> <li>修复并回归测试该浏览器上的bug。</li> <li>浏览器将在一个合理的性能级别上执行我们的代码。
举例来说，大多数JavaScript库最终支持大约十几个浏览器。这些浏览器通常包括五大浏览器的之前版本，当前版本以及即将到来的测试版(如果有的话)。</li> <li>Internet Explorer.</li> <li>Firefox.</li> <li>Safari.</li> <li>Chrome.</li> <li>Opera.</li></ul> <p>有非常多的浏览器版本需要支持，尤其是我们需要将这些浏览器在多个平台上进行测试的时候，如IE这样的浏览器，同时有多个版本都在使用。主流的JavaScript库有大量的人员可以支配，而普通的页面设计者却没有。所以必须要做出支持哪些浏览器的选择。</p> <h5 id="注意-我们可以选择利用已经支持主流浏览器的主流javascript库-来自动支持这些浏览器-但并不假定我们在使用javascript库-而是要帮助大家选择在代码中支持哪些浏览器"><a href="#注意-我们可以选择利用已经支持主流浏览器的主流javascript库-来自动支持这些浏览器-但并不假定我们在使用javascript库-而是要帮助大家选择在代码中支持哪些浏览器" class="header-anchor">#</a> 注意:我们可以选择利用已经支持主流浏览器的主流JavaScript库，来自动支持这些浏览器，但并不假定我们在使用JavaScript库，而是要帮助大家选择在代码中支持哪些浏览器</h5> <p><img src="/book/1601362935502.jpg" alt=""></p> <p>要选择一个支持的浏览器集，可能需要创建一个浏览器支持矩阵，如图所示，按自己的目的进行填写。(此表的选择只是一个例子，不反应所选浏览器的任何值。)</p> <p>注意，如果不打算支持已经跨平台的浏览器，可能需要根据平台，进一步区分需要支持的浏览器。</p> <p>任何一段可重用的JavaScript代码，无论它是一个大众使用的JavaScript库还是我们自己的页面代码，都应该在尽量多的环境中进行开发，专注于对最终用户很重要的浏览器和平台。对于大众用的JavaScript库。要之处的浏览器更多，对于更有针对性的浏览器，要支持的浏览器可能会比较少。</p> <h3 id="五大开发关注点"><a href="#五大开发关注点" class="header-anchor">#</a> 五大开发关注点</h3> <p>对于任何重要的代码，都有很多开发问题需要关注。但对于JavaScript可重用代码来说，有5个重要的关注点是最大的挑战如图:</p> <p><img src="/book/1601363995517.jpg" alt=""></p> <p>如下是这5点内容:</p> <ul><li>浏览器的bug。</li> <li>浏览器的bug修复。</li> <li>浏览器缺失的功能。</li> <li>外部代码。</li> <li>浏览器回归。</li></ul> <p>分析我们的目标受众，开发资源以及进度，这些都是我们的决定因素。思考这些问题时，有一个公理可以参考。</p> <ul><li>记住过去。</li> <li>考虑未来。</li> <li>测试现在。</li></ul> <p>当努力开发可重用的JavaScript代码时，我们必须考虑所有的点，而且要关注当前已有的流行的浏览器。然后还必须考虑浏览器在未来版本中的变化。并且还必须努力维护更多的功能。</p> <h4 id="浏览器bug和浏览器差异"><a href="#浏览器bug和浏览器差异" class="header-anchor">#</a> 浏览器bug和浏览器差异</h4> <p>开发可重用JavaScript代码时，我们需要关注的首要问题是，在已经决定需要支持的浏览器中，处理各种浏览器的bug和API差异。我们代码中提供的任何功能，在所有这些浏览器中，都应该完全正确且可核实。</p> <p>我们实现这一目标的方式很简单，我们需要一个全面的测试套件，不仅要覆盖到代码的常见用例，还要覆盖到代码的边界用例。有了良好的测试覆盖率，在得知我们所开发的代码在支持的浏览器中会运行正常后，我们会很有安全感。假设浏览器没有打破向后兼容性的后续变化，我们会积极地认为我们的代码甚至能够在未来版本的浏览器中运行。</p> <h4 id="浏览器bug修复"><a href="#浏览器bug修复" class="header-anchor">#</a> 浏览器bug修复</h4> <p>假设某个浏览器将永远有一个特定的bug非常愚蠢----大部分浏览器的bug最终都会得到修复，依靠bug的存在是一个危险的开发策略。</p> <p>在编写可重用的JavaScript代码时，我们想确保它能持续运行很长一段时间。在编写网站的各种代码(CSS,HTML等)时，我们不想因为一个新版本浏览器的发布，回过头来再去修复该版本浏览器所损坏的代码。</p> <p>对浏览器bug进行假设，通常会导致网站的破坏:使用特定的hack解决浏览器存在的bug，会破坏浏览器在未来版本对该bug的修复。通过构建仿真代码功能可以规避这个问题，而不必对浏览器进行假设。</p> <p>处理浏览器bug的问题是双重的:</p> <ul><li>在bug最终被修复后，我们的代码很容易被破坏。</li> <li>我们可能最终告诫浏览器厂商不要修复bug，以免造成网站的破坏。</li></ul> <p>针对第二中情况，在开发Firefoex3的时候，有一个有趣的例子。其中有一处修改是，如果一个文档内的DOM节点要注入到另外一个文档(根据DOM规范的要求)，则强迫该文档的DOM节点需要被另外一个DOM文档所收养。</p> <p>如下的代码不应起作用:</p> <div class="language- extra-class"><pre class="language-text"><code>var node = documentA.createElement(&quot;div&quot;);
documentB.documentElement.appendChild(node);
</code></pre></div><p>如下才是正确的做法:</p> <div class="language- extra-class"><pre class="language-text"><code>var node = documentA.createElement(&quot;div&quot;);
documentB.adoptNode(node);
documentB.documentElement.appendChild(node);
</code></pre></div><p>但是因为Firefox有一个bug，让原本不应该能用的第一段代码能够正常工作了，由于它能正常运行，所以用户就用这种方式进行编码了。</p> <p>这引出了另外一个与bug有关的重要事项:在确定一个功能是否是bug时，始终要用规范对它进行验证。在上述情况下，Internet Explorer更有说服力，但用户确认为这是一个Internet Explorer的错误，并使用条件代码提供一个回退。这导致了一个这样的场景:用户只在一小部分浏览器中遵循了规范，且在其他浏览器中强力拒绝了该规范。</p> <p>浏览器bug也不同于一个不规范的API。重提一下浏览器规范是很重要的，因为这些都是浏览器才用的确切标准，目的是为了开发和改进代码。相比之下，一个不规范API的实现在任何时候都有可能改变。在不规范API这种不一致的情况下，应该一致测试预期输出，对特性仿真运行额外的测试。要时刻注意，在这些API固定时，可能会导致一些变化。</p> <p>此外，在bug修复和API变化之间有一个区别。bug修复很容易预知----浏览器最终会在它的实现中修复这个bug，即便要花很长时间----API变化就很难知道了。标准API不太可能改变，而不规范的API则更有可能发生变化。</p> <p>幸运的是，重击大部分Web应用程序的情况会很少发生。但是即便发生了，实际上也没有办法提前发现。这种类型的API编号，应该像其他回归一样进行处理。</p> <h4 id="与外部代码一起共存"><a href="#与外部代码一起共存" class="header-anchor">#</a> 与外部代码一起共存</h4> <p>任何可重用代码必须与围绕它的代码共存。不管我们是期望代码在我们自己编写的页面内运行正常，还是在其他人开发的网站上运行正常，我们都需要确保我们的代码和该页面上的其他任意代码能够共存。</p> <p>这是一把双刃剑:我们编写的代码不仅要承受编写的很糟糕的代码，还要负责自己不受这些共存代码的影响。</p> <p>我们在这一点上需要有多高的警惕度，很大成都上取决于我们希望使用代码的环境。举例来说，如果我们为某种程度上可以控制的单个或有限数量的网站编写可重用的代码，我们或许可以不用太关注外部代码的影响，因为我们知道代码要操作什么，在某种程度上可以控制的单个或有限数量的网站编写可重用的代码，我们或许可以不用太关注外部代码的影响，因为我们知道代码操作什么，在某种程度上，我们可以 解决任何问题。</p> <p>如果我们开发的代码，需要在未知和无法控制的环境中有广泛的适用性，我们需要再次确认代码是健壮的。</p> <h4 id="封装代码"><a href="#封装代码" class="header-anchor">#</a> 封装代码</h4> <p>要防止我们的代码影响页面上加载的其他代码片段，最好是才用封装。</p> <p>封装的字典定义是&quot;包装在一起或看似包装在一起&quot;，另外一个更为专业的定义是&quot;对某些对象的组件进行限制访问的一种语言机制&quot;。更简洁的总结&quot;做好自己的事儿就行了&quot;。</p> <p>在将我们的代码引入到页面的时候，保持一个非常小的全局分布。事实上，将我们的全局分布保存在一些全局变量上是很简单的。</p> <p>jQuery库就是一个很好的例子。它引入了一个名为jQuery的全局变量(函数)，以及该全局变量的一个别名$。jQuery库甚至支持，将$别名还给页面上的其他代码或可能希望使用的其他库。</p> <p>在jQuery中，几乎所有的操作都是通过jQuery函数进行的。所有其他的函数[所谓的使用函数]都是作为jQuery的属性来定义的，因此使用jQuery作为所有其他函数定义的名称空间。</p> <p>我们可以使用相同的策略。比方说，要定义一组函数自己使用，或让别人使用，我们会将代码组织在一个命名空间下----这里我们选择ninja。</p> <p>与jQuery一样，我们可以定义一个名为ninja()的全局函数，根据传入内容的不同来执行各种各样的操作。例如:<code>var ninja = function(){}</code></p> <p>使用该函数作为命名空间，定义我们自己的实用函数是很简单的:<code>ninja.hitsuke = function(){}</code></p> <p>如果我们不希望或不需要将ninja作为一个函数，而只是将其作为一个名称空间，我们可以这样定义:<code>var ninja={};</code></p> <p>上述代码将创建一个空对象，在该空对象上，我们可以定义属性和函数，从而防止这些名称被添加至全局命名空间。</p> <p>为了让代码封装起来，我们希望避免采用的另外一个实践是修改任何现有的变量，函数原型，甚至是DOM元素。除了我们自己的代码以外，页面上任何地方的修改，都有可能造成潜在的冲突和混乱。</p> <p>事情都有两面性，即使我们遵循最佳实践，谨慎的封装代码，我们也不能保证非自己编写的代码也会表现的一样好。</p> <h4 id="处理不太典范的代码"><a href="#处理不太典范的代码" class="header-anchor">#</a> 处理不太典范的代码</h4> <p>别的代码，即使是精心编写的，且是buggy的，也很可能会故意做修改函数原型，对象属性以及DOM元素的方法这样的事情。这种做法，不管有没有恶意，可以让我们掉进陷阱。</p> <p>这种情况性爱，我们的代码可以做一些无害的事情，比如使用JavaScript数组，我们简单假设JavaScript数组要表现的像JavaScript数组的时候，没有人会说是错的。但是如果页面上的其他代码修改了数组的工作方式，即便我们认为我们的代码觉得没错，最终也有可能无法安装预期的方式进行工作。</p> <p>可惜的是，在处理这种情况的时候，并没有多少固定规则，但我们可以才去一些步骤来减少这类问题的发生。</p> <h4 id="避免植入属性"><a href="#避免植入属性" class="header-anchor">#</a> 避免植入属性</h4> <p>第一种防御措施是，学会如何避免其他代码在我们背后可能引入的对象属性。</p> <p>要检测这种行为，我们要利用hasOwnProperty()函数。该函数继承于Object，所有的JavaScript对象都拥有该函数，并且可以测试一个对象是否拥有指定的属性。和JavaScript的in操作符很类似，不过有一个重要的区别是，它不检查原型链。因此，我们可以使用该函数检测Object.prototype扩展上添加的属性和直接在对象上添加的属性之间的不同。</p> <p>使用如下代码清单中所示的代码，可以测试观察该函数的行为。</p> <p>使用hasOwnProperty()测试继承属性:</p> <div class="language- extra-class"><pre class="language-text"><code>Object.prototype.ronin = &quot;ronin&quot;;
var object = {ninja:'value'};
object.samurai = &quot;samurai&quot;;

assert(object.hasOwnProperty('ronin'),&quot;ronin is a property&quot;);
assert(object.hasOwnProperty('ninja'),&quot;ninja is a property&quot;);
assert(object.hasOwnProperty('samurai'),&quot;samurai is a property&quot;);
</code></pre></div><p>上述测试的运行结果，如图所示:</p> <p><img src="/book/1601385228808.jpg" alt=""></p> <p>测试结果清楚的展示了，在Object的原型上添加ronin属性，不被视为新创建对象的自身属性。值得庆幸的是，使用这种技术的脚本很少，但如果原型上添加的属性混淆我们的代码，造成的损害却是很大的。</p> <p>使用for-in字句遍历一个对象属性的时候，尤其会出现问题。通过使用hasOwn-Property()判断是否应该忽略一个属性，我们可以克服这种并发症:</p> <div class="language- extra-class"><pre class="language-text"><code>for(var p in someObject){
    if(someObject.hasOwnProperty(p)){
        //do something wonderful
    }
}
</code></pre></div><p>上述代码片段展示了，如何使用hasOwnProperty()忽略被添加到对象原型中的属性。</p> <h4 id="贪婪id复制"><a href="#贪婪id复制" class="header-anchor">#</a> 贪婪ID复制</h4> <p>大多数浏览器会呈现一种反特证，它们会导致我们的代码不按预期执行。在使用原始元素id的时候，该特性会导致元素引用添加到其他元素上。当该id与其他元素已有的属性发生冲突时，可能就会发生很糟糕的事情。</p> <p>查看如下的HTML片段，观察这些称之为&quot;贪婪ID&quot;带来的丑陋结果:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;form id=&quot;form&quot; action=&quot;/conceal&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;action&quot;/&gt;
    &lt;input type=&quot;submit&quot; id=&quot;submit&quot;/&gt;
&lt;/form&gt;
</code></pre></div><p>此时，在浏览器中调用如下语句:<code>var what = document.getElementById('form').action;</code>没错，我们希望得到的是表单的action属性值。在大多数情况下，都会得到该值。但是如果检查变量what的值，我们发现，它是input#action元素的引用！</p> <p>让我们在试试别的东西:<code>document.getElementById('form').submit();</code> 这句话应该会让表单提交，然后我们得到一个脚本错误:<code>Uncaught TypeError:Property 'submit' of object #&lt;HTMLFormElement&gt; is not a function</code> 发生什么事了？</p> <p>这里发生的事情是，浏览器将表单里引用的每个input元素都作为<code>&lt;form&gt;</code> 元素的属性了。刚开始似乎很方便，但看到所添加属性的名称是input属性的id值时就发现问题了。如果id值恰好是form元素已经存在的属性，这些原始属性就会被新属性取而代之，如action或submit。</p> <p>因此，在创建input#submit元素之前，form.action引用指向的是<code>&lt;form&gt;</code>的action特性的值，创建元素之后，指向的就是input#submit元素了。同样的事情，也发生在form.submit上了。</p> <p>这个选择有点莫名其妙，因为这种行为的发生，input元素必须有一个id，如果有了id，就很容易获取了，而不必通过表单属性来获取了。</p> <p>无论如何，在我们的代码中，这个特殊的浏览器&quot;特性&quot;可以导致很多使人迷惑的问题，在这些浏览器中进行调试的时候必须牢记这些内容。如果我们遇到的属性貌似已经莫名其妙的变成其他不是我们所期望的东西时，我们就需要检查是否是贪婪ID引起的。</p> <p>幸运的是，通过在HTML标记中避免声明和标准属性名一样的id值，就可以避免这个问题。可以鼓励其他人也同样这样做。尤其是要避免id和name的值为submit，在出现令人失望且令人费解的行为时，这通常是一个常见的出错源。</p> <h4 id="样式表排序"><a href="#样式表排序" class="header-anchor">#</a> 样式表排序</h4> <p>我们尝尝需要在已经运行的页面上应用一些CSS规则。在JavaScript代码执行时，确保定义CSS样式表提供的规则的一个最佳方法是，将外部样式表在外部脚本文件之前进行引用。</p> <p>不这样做会导致意想不到的结果，因为JavaScript脚本会试图访问目前还未定义的样式信息。不过，这并不是一个可以很容易的通过纯JavaScript代码进行纠正并且可以在用户文档中进行处理的问题。</p> <h4 id="缺失的功能"><a href="#缺失的功能" class="header-anchor">#</a> 缺失的功能</h4> <p>如果一些浏览器不在我们的浏览器支持矩阵中，那么也不会从针对这些要支持浏览器所做的测试中收益，可能会缺失一些关键特性，而我们的代码要按预期运行就需要这些特性。</p> <p>甚至有的浏览器可能会缺乏必要的关键功能，而这些特性又是我们所需要的。</p> <h4 id="优雅降级"><a href="#优雅降级" class="header-anchor">#</a> 优雅降级</h4> <p>即使我们不会支持所有的浏览器，特别是哪些没有人选的，最好也要编写防御性代码，以便进行优雅降级，或为最终用户提供一些其他类型的浏览器来选择，而不是非要选择我们有足够资源进行测试的浏览器。</p> <p>我们此时的战略是，为我们的用户提供最大化的功能，在我们不能提供完整的功能时，进行优雅的失败出来。这就是所谓的优雅降级。</p> <p>优雅降级应该谨慎，且经过适当考虑。比如，如果一个浏览器能够初始化并隐藏页面上的导航，我们获取希望创建一个下拉菜单，但处理菜单的事件相关代码却不能用。结果就是一个半成品页面，帮不到任何人。</p> <p>即便是减少功能，也要确保我们得代码所提供的后备功能是可用的。</p> <h4 id="向后兼容"><a href="#向后兼容" class="header-anchor">#</a> 向后兼容</h4> <p>一个更好的策略是，将我们的代码尽可能设计成向后兼容，并主动获知失败的浏览器，从而讲也没或网站替换成一个另外一个版本，以适应于小众浏览器的特性。Yahoo！在大多数网站上都才用了这一策略，将浏览器拆分成几个级别进行支持。一定时间之后，他们就会将浏览器加入黑名单，并将该浏览器的用户引导至一个纯HTML版本的程序上。</p> <p>这意味着，他们的开发者人员可以为绝大多数用户提供最佳体验，通过给过时浏览器提供等价的功能。</p> <p>该策略要考虑如下要点。</p> <ul><li>对旧浏览器的用户体验没有假设。在一个浏览器不能被测试时，切断支持并提供一个简单的页面，或者根本旧不在支持了。</li> <li>保证所有当前和过去版本的浏览器用户都有一个可访问页面。</li> <li>假定未来和未知浏览器都能工作。</li></ul> <p>这一策略的主要缺点是，专注于旧版和未来版本浏览器的处理会带来额外的开发工作。如果不关注成本，这确实是一个明智的策略，因为它可以让应用程序得到更长时间的运行，而只需要有最新的更新和变化。</p> <h4 id="回归"><a href="#回归" class="header-anchor">#</a> 回归</h4> <p>在创建可重用及可维护的JavaScript代码时，回归是我们遇到的最困难的问题之一。浏览器引入的这些bug或非向后兼容的API变化，导致我们的代码以不可预知的方式被破坏了。</p> <h4 id="期待变化"><a href="#期待变化" class="header-anchor">#</a> 期待变化</h4> <p><img src="/book/1601393160264.jpg" alt=""></p> <h3 id="实现策略"><a href="#实现策略" class="header-anchor">#</a> 实现策略</h3> <h4 id="安全的跨浏览器修复"><a href="#安全的跨浏览器修复" class="header-anchor">#</a> 安全的跨浏览器修复</h4> <p>最简单的跨浏览器修复方式，都具有如下两个重要特征。</p> <ul><li>对其他浏览器来说，没有负面影响或副作用。</li> <li>不需要进行浏览器检测或特性检测。</li></ul> <p>能够使用这种方式进行修复的场景可能很少见，但它们是一种策略，我们应该尽量在应用程序中使用该策略。</p> <p>让我们来看一个例子。如下代码片段，是使用Internet Explorer时的一个修改(来自jQuery):</p> <div class="language- extra-class"><pre class="language-text"><code>//ignore negative width and height values
if((key == 'width'||key=='height')&amp;&amp;parseFloat(value)&lt;0&gt;)
    value = undefined;
</code></pre></div><p>在给height或width样式属性设置负值的时候，一些版本的IE浏览器会抛出异常，而所有其他的浏览器则会忽略负值输入。该方法的目的是让所有的浏览器都忽略负值。这种变化可以防止Internet Explorer抛出异常，并对其他任何浏览器都没有影响。向用户提供一个统一的API，这是一个无痛的改变。</p> <p>jQuery代码库的这种变化，不需要浏览器检测或特征检测，在所有浏览器中使用统一的API。这种行为仍然会导致一个异常，该异常在所有类型的浏览器中都是统一的。</p> <p>这种特殊方法，可能被认为是很有争议的----因为一个浏览器中的bug，而故意限制该库在所有浏览器中的功能。jQuery团队认真权衡了这一决策，并决定在开发跨域浏览器代码时，最好是有一个统一的，运行文档的API，而不是一个会意外失效的API。在开发我们自己的可重用代码库时，很有可能也会遇到这种情况，这时候就需要仔细考虑这样的限制方法是否适用于我们的用户。</p> <p>对于这些类型的代码改变，重要的是要记住，它们提供了一个可行的无缝跨浏览器解决方案，而无需进行浏览器检测或特征检测，使它们不受未来变化的影响。我们应该尽力才用这种方式的解决方案，即使应用实例少之又少。</p> <h4 id="对象检测"><a href="#对象检测" class="header-anchor">#</a> 对象检测</h4> <p>在编写夸浏览器代码时，对象检测是一种常用的方法，这种方式不仅简单，而且通常很有效。确定某一对象或对象属性是否存在，如果存在，则假设它包含了暗指的功能。</p> <p>大多数情况下，对象检测用于在提供重复功能的多个API之间进行选择。举例来说，对象检测用于选择合适的浏览器事件绑定API，再来看一下:</p> <div class="language- extra-class"><pre class="language-text"><code>function bindEvent(element,type,handle){
    if(element.addEventListener){
        element.addEventListener(type,handle,false);
    }else if (element.attachEvent) {
        element.attachEvent(&quot;on&quot;+type,handle);
    }
}
</code></pre></div><p>在本例中，检测是否存在名为addEventListener的属性，如果存在，则假设它就是我们要执行的函数，并且可以将事件绑定在该元素上。同样，也可以测试其他API，比如测试attachEvent是否存在。</p> <p>注意，我们首先测试的是W3C DOM事件规范中的标准方法addEventListener。我们是有意这样做的。</p> <p>只要有能，我们都应该使用默认的标准方式来执行操作。如前所述，这将有助于使我们的代码尽可能不会过时。此外，来自大规模使用库的压力，以及Twitter和其他社交媒体上的一些非常强烈和有影响力的声音，可以激励浏览器厂商致力于提供标准化的执行操作方法。</p> <p>对象检测的一个重要用途是发现浏览器环境提供的代码执行设施。我们可以将这些设施用于代码中，或利用这些设置确定是否需要提供备用方案。</p> <p>如下代码片段，展示了一个基本的示例:使用对象检查来判断浏览器特性，来确定我们是提供完整的应用程序功能还是提供缩减版本的备用方案:</p> <div class="language- extra-class"><pre class="language-text"><code>if (typeof document !== &quot;undefined&quot;&amp;&amp;(document.addEventListener||document.attachEvent)&amp;&amp;document.getElementsByTagName&amp;&amp;document.getElementById) {
//...
}else{
    //...
}
</code></pre></div><p>在这里，我们测试一下几个方面:</p> <ul><li>浏览器是否加载了文档。</li> <li>浏览器是否提供了事件绑定处理的方法。</li> <li>通过标签名称，浏览器是否可以找到元素。</li> <li>通过ID，浏览器是否可以找到元素。</li></ul> <p>任何一个测试失败，我们都会采用备用方案。备用方案中的内容取决于代码使用者的期望以及放置代码的要求。有如下几个选项可以考虑。</p> <ul><li>可以执行进一步的对象检测，找出仍然可以使用一些JavaScript的缩减体验。</li> <li>可以选择不执行任何JavaScript，退回到一点脚本都没有的HTML页面。</li> <li>可以将用户重定向到网站的普通版。比如，Google在做Gmail的时候就是这样。</li></ul> <p>由于对象检测的开销非常效，并且代码实现也相对简单，如果要提供基础备用方案，这是一耳光很好的方式，不管是在API级别还是应用程序级别。这是图片编写可重用代码的第一道防线的一个很好的选择。</p> <h4 id="特征仿真"><a href="#特征仿真" class="header-anchor">#</a> 特征仿真</h4> <p>处理回归的另一种形式，也是检测浏览器bug修复的最有效手段，它就是特征仿真。与只是进行对象/属性查找的对象检测相比，特征仿真要执行完整的特征运行，以确保它可以按期望运行。</p> <p>对于检测一个特征是否存在来说，对象检测是一个很好的方式，但它不保证特征的行为符合预期。但如果我们知道特定的bug，在特征bug修复时，我们可以快速构建测试来验证它，并且可以在修复之前编写代码暂时解决该bug。</p> <ul><li>举例来说，如果我们执行getElementsByTagName(&quot;*&quot;)，Internet Explorer 8和早期版本会将元素和注释一起返回。没办法使用对象检测来判断是否会发生这种情况，就像经常希望的那样，该bug已经被Internet Explorer团队在IE9版本中修复掉了。</li> <li>让我们编写一个特征仿真，确定getElementsByTagName()方法是否能按我们期望的那样工作:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>window.findByTagWorksAsExpected = (function(){
    var div = document.createElement(&quot;div&quot;);
    div.appendChild(document.createComment(&quot;test&quot;));
    return div.getElementsByTagName(&quot;*&quot;).length===0;
})();
</code></pre></div><p>在本例中，我们编写了一个即使函数，如果getElementsByTagName(&quot;*&quot;)函数调用能按预期执行，就返回true，否则返回false。这个函数的测试步骤十分简单。</p> <ul><li>创建一个分离的<code>&lt;div&gt;</code> 元素。</li> <li>向<code>&lt;div&gt;</code>添加注释节点。</li> <li>调用该函数，看看返回了多少个值，根据结果返回true或false。
是的，知道有问题只是成功的一半。利用这些知识，我们怎样能让我们得代码变得更好？如下代码清单，展示了一个使用上述特征仿真片段的实例:解决该bug。</li></ul> <p>实践特征仿真功能来修复浏览区bug:</p> <p><img src="/book/1601788873982.jpg" alt=""></p> <p>在这段代码中，我们设置了一写含有注释节点的<code>&lt;div&gt;</code>元素，稍后用于测试。然后开始编写业务脚本。</p> <p>由于直接使用document.getElementsByTagName(&quot;<em>&quot;)是不可靠的，所以这里定义一个替代方法getAllElements()，在需要使用getElementsByTagName的时候使用该替代方法。我们希望，在浏览器正确支持document.getElementsByTagName(&quot;</em>&quot;)的时候，该方法直接调用document.getElementsByTagName(&quot;*&quot;)，如果不支持，则使用备用方案来生成正确的结果。</p> <p>该方法首先要做的第一件事是，使用在签名编写的即使函数，该函数用于判断特征是否按预期进行工作。注意，我们将执行结果保存在一个window作用域变量上了，以便稍后可以对其引用，判断他是否已经被设置，这样我们只需运行一次特征仿真检查。</p> <p>检查之后，调用document.getElementsByTagName(&quot;*&quot;)，并且将结果保存在一个变量中。</p> <p>此时，我们的节点列表包含了所有的元素，而且此时我们也知道我们是否在操作有注释节点问题的浏览器。如果确定有这个问题，我们就遍历所有的节点，剔除所有的非元素节点。如果浏览器没有这个问你题，则跳过遍历过程。</p> <h5 id="注意-元素节点的nodetype是1-而注释节点的nodetype是8-现代浏览器为此在node对象上定义了一组常量-比如node-element-node和node-commnet-node。由于要在旧浏览器中触发我们的修复代码-我们不能假设这些常量存在-因此要使用硬编码。"><a href="#注意-元素节点的nodetype是1-而注释节点的nodetype是8-现代浏览器为此在node对象上定义了一组常量-比如node-element-node和node-commnet-node。由于要在旧浏览器中触发我们的修复代码-我们不能假设这些常量存在-因此要使用硬编码。" class="header-anchor">#</a> 注意:元素节点的nodeType是1，而注释节点的nodeType是8，现代浏览器为此在Node对象上定义了一组常量，比如Node.ELEMENT_NODE和Node.COMMNET_NODE。由于要在旧浏览器中触发我们的修复代码，我们不能假设这些常量存在，因此要使用硬编码。</h5> <p>最后通过新方法的应用来测试该新方法，并断言验证返回的节点列表只包含元素节点。</p> <p>该例子分两个阶段演示了特征仿真的工作原理。</p> <p>首先，运行一个简单的测试，确定一个特性是否能按预期进行工作。验证一个特征的完整性是很重要的，而不是显示测试bug的存在。虽然这可能只是一个语义上的区别，但要记住这一点。</p> <p>其次，测试 的结果在稍后的程序中用于加速变量数组中的元素。因为能够正常工作的浏览器不需要循环遍历每个节点，我们完全可以跳过它，在正常工作的浏览器上没有任何性能损失。</p> <p>最常见的特征仿真说法是:确保特征能按预期工作，为不能按预期工作的浏览器提供一个备用操作。</p> <p>使用特征仿真时要考虑的最重要一点就是折衷。在初始仿真中支付的艾崴性能开销，以及我们程序中的额外代码，带给我们的好处是，可以让一个可疑特性在所有支持的浏览器中都能按预期工作，并且使我们的代码不因未来的bug修复而收到破坏。这种豁免权对创建可重用代码库来说绝对是无价的。</p> <p>在测试一个浏览器是否损坏了的时候，特征仿真是很有用的，但对于顽固抵抗测试的浏览器问题，我们该如何做解决？</p> <h4 id="不可检查的浏览器问题"><a href="#不可检查的浏览器问题" class="header-anchor">#</a> 不可检查的浏览器问题</h4> <p>很可惜，在JavaScript和DOM上，有很多可能出现的问题没有办法进行测试或测试很昂贵。还好，这些情况不是很常见，但当遇到这些问题的时候，还是应该花一些时间研究一写，看看有什么可以做的。</p> <h4 id="事件处理绑定"><a href="#事件处理绑定" class="header-anchor">#</a> 事件处理绑定</h4> <p>浏览器中一个令人恼火的失误是，无法确定一个事件处理程序是否被绑定。浏览器没有提供任何方法用于确定一个函数是否被绑定到一个事件监听器上。正因为如此，也没有办法删除一个元素上的所有事件处理程序，除非对我们所有已创建的绑定处理程序的引用进行维护。</p> <h4 id="事件触发"><a href="#事件触发" class="header-anchor">#</a> 事件触发</h4> <p>另外一个更重要的问题是，无法确定一个事件是否被触发。虽然可以确定一个浏览器是否支持一种事件绑定，但不可能知道浏览器是否会触发一个事件。有几个地方可能会成为问题。</p> <p>首先，如果一个脚本在页面本身加载之后进行了动态加载，它可能会视图监听一个window的load事件，但实际上，谈事件已经触发过了。由于没办法确定事件是否已经触发了，最终可能会导致代码永远的等待执行。</p> <p>其次，在一个脚本使用自定义事件作为浏览器事件替代的时候。例如，Internet Explorer提供了mouseenter和mouseleave事件，用于在用户鼠标进入或离开一个元素边界时，简单确定该事件的发生。这些都是作为mouseover和mouseout事件的常用替代，因为它们比标准事件更直观。但如果不首先绑定这些事件并等待一些用户交互的话，是没有办法确定这些事件是否被触发的，因为很难在可重用代码中使用它们。</p> <h4 id="css属性效果"><a href="#css属性效果" class="header-anchor">#</a> CSS属性效果</h4> <p>另外一个难点是，确定修改特定的CSS属性是否会影响页面展示。大量的CSS属性只会影响页面可视化描述的战术，除此之外就没有别的了，它们不会改变周围的元素或影响其他元素上的属性。比如:color,backgroundColor以及opacity。</p> <p>正因为如此，所以没有办法以变成方式确定，改变这些样式属性是否会产生影响。验证影响的唯一途径是检查页面的外观。</p> <h4 id="浏览器崩溃"><a href="#浏览器崩溃" class="header-anchor">#</a> 浏览器崩溃</h4> <p>测试脚本导致浏览器崩溃是另外一个难题。导致浏览器崩溃的代码就更严重了，因为它们不像异常那样很容易发现和处理，这些代码总是会导致浏览器崩溃。</p> <p>举例来说，在一个旧版本的Safari浏览器中，使用Unicode字符集创建正则表达式的时候，总是会导致浏览器崩溃，示例如下所示:<code>new RegExp(&quot;[\\w\u0128-\uFFFF*_-]+&quot;);</code></p> <p>这里的问题是，不可能使用特征仿真来测试是否存在这个问题，因为在旧版本浏览器中，测试本身总是会导致崩溃。</p> <p>此外，导致崩溃的bug永远会变得纠缠不清，因为在浏览器的某些地方禁用JavaScript，可能是可以接受的，但永远不可能接受浏览器的彻底崩溃。</p> <h4 id="不一致的api"><a href="#不一致的api" class="header-anchor">#</a> 不一致的API</h4> <p>在前面我们了解了，jQuery是如何因为IE浏览器的一个bug而决定在所有浏览器中都不允许修改type属性的。我们可以对该功能进行测试并只是IE中禁止修改，但折将会建立一个不一致的API，导致在不同的浏览器有不同的工作方式。在这样的情况下，如此糟糕的一个错误会导致API遭受破坏，唯一的选择就是对该问题进行变通，提供一个不同的解决方案。</p> <h4 id="api性能"><a href="#api性能" class="header-anchor">#</a> API性能</h4> <p>有时候，有些特定API在不同浏览器中的速度有的快，有的慢。在编写可重用且健壮的代码时，尽量让这些API提供良好的性能是非常重要的。但是，到底是哪个API却不是显而易见的。</p> <p>对一些特征计较进行有效的性能分析，通常需要大量的数据以及较长的时间。隐藏，这不是像使用特性仿真那样所能够做到的。</p> <h4 id="ajax问题"><a href="#ajax问题" class="header-anchor">#</a> AJAX问题</h4> <p>判断Ajax请求是否能够正常工作是另外一个难题。在IE7中，IE浏览器破坏了通过XMLHttpRequest对象请求本地文件的能力。我们可以测试该bug是否被修复，但是如果要这样做，在每个页面上进行Ajax请求之前，都需要发送一个额外的请求先验证一下。这不是最佳方案。</p> <p>不仅如此，在库中还必须包含一个额外的文件，唯一的原因是因为该文件要作为额外请求的目标文件。这些重要的开销都是禁止的，当然花费额外的时间和资源也是不值得的。</p> <p>不可测试的特性是很麻烦的，其妨碍了我们编写可重用的JavaScript，但通过一些努力和智慧，通常也可以让它们正常工作。利用替代技术，或首先排除这些问题来构建我们的API，我们还是能够构建有效的代码的，尽管机会不大。</p> <h3 id="减少假设"><a href="#减少假设" class="header-anchor">#</a> 减少假设</h3> <p>编写跨浏览器，可重用代码是一场假设战，但通过利用明智的检测和创作，我们可以在代码中减少很多假设。当我们对所编写代码做出假设时，未来编码时还会一直遇到问题。</p> <p>举例来说，假设一个问题或bug总是存在于一个特定的浏览器，这是一个巨大且危险的假设。而对该问题进行测试则被证明时更有效的。在我们的编码中，我们应该努力较少所做的假设，有效的减少出错的可能性，以及出现一写会在背后攻击我们的问题的可能性。</p> <p>在JavaScript中，最常见的假设是用户代理检测。具体来说，分析浏览器提供的用户代理，并使用它来假设一个浏览器的行为----换句化说，就是浏览器检测。可惜的是，绝大多数的user-agent字符串分析，都被证明是未来出现错误的一个根源。假定bug，问题或专有特性都将与特定浏览器有关，这是消除灾难的秘诀。</p> <p>举例来说，让我们重新审视一下已经看过很多次的事件附加嗲吗:</p> <div class="language- extra-class"><pre class="language-text"><code>function bindEvent(element,type,handle){
    if(element.addEventListener){
        element.addEventListener(type,handle,false);
    }else if (element.attachEvnet) {
        element.attachEvnet(&quot;on&quot;+type,handle);
    }
}
</code></pre></div><p>不用展望未来，看看能不能从这段代码中得出三个假设。继续，我们等等看。</p> <p>在上述代码中，我们至少做出了三个假设。</p> <ul><li>假设有需要检测的属性，实际上是可以调用的函数。</li> <li>假设它们是正确的函数，能够执行我们期望的行为。</li> <li>假设折两种方法是可以绑定事件的唯一方式。</li></ul> <p>通过检测属性是否存在，我们可以很容易的摆脱第一个假设。处理剩下的两个假设则有一个困难。</p> <p>在我们的代码中，我们总是需要决定有多少个假设可以适合我们的需求，目标受众以及我们自己。通常，减少假设的数量会增加代码库的大小和复杂性。这是完全可能的，而且很容易，试图减少假设到完全疯狂的地步，但在某种程度上，我们不能不停下来观察一下我们所做的，然后说&quot;已经很好了&quot;，并到此为止。记住，即便使用了最少的假设，在引入浏览器的时候，也仍然希望在做一下回归。</p> <h2 id="洞悉特性-属性和样式"><a href="#洞悉特性-属性和样式" class="header-anchor">#</a> 洞悉特性，属性和样式</h2> <p>除了上一章以外，到目前为止，本书的大部分内容都是关于JavaScript语言的处理。尽管将纯JavaScript作为一门语言来说有很多细微的差别，但是，如果我们把浏览器DOM再引入进来，事情就会变的更让人困惑了。</p> <p>理解DOM概念，JavaScript与这些概念之间的关系，是成为JavaScript忍者的重要条件，尤其是要用一些令人困惑的方式去理解一些似乎不符合常理的DOM概念。在DOM特性和DOM属性方面，会让很多JavaScript页面开发人员感到战栗。在特性和属性之间不仅会有一些非常细微的行为差别，在其他一些方面也会有很多bug以及跨浏览器问题。</p> <p>但特性和属性都是很重要的概念:特性是DOM构建的一个组成部分，而属性是元素保持运行时信息的主要手段，并且通过属性可以访问这些运行时信息。</p> <p>让我们来看一个简单的示例，演示特性和属性的区别:</p> <p><img src="/book/1601799823991.jpg" alt=""></p> <p>在上述代码中，我们创建一个图像标签，获取它的引用，并将它的src属性修改为一个新值。这看起来非常简单，但我们运行两个测试来验证一下。</p> <ul><li>测试src属性的值就是我们新赋的值。毕竟，如果我们赋值x=213，当然希望x的值就是213.</li> <li>我们并没有改变其特性，所以它应该保持不变。对吧？</li></ul> <p>但当我们在浏览器中运行上述代码时，两个测试都失败了。</p> <p>我们看到，src属性的值不是我们所赋予的值，而是类似如下这样的值:<code>http://localhost/ninja/images/ninja-with-pole.png</code> 给一个属性赋值，难道不应该期望那个属性就是所赋予的值吗？</p> <p>更奇怪的是，即使我们并没有元素上的特性，失败的测试表明，src特性的值已经变成如下内容了:<code>../images/ninja-with-pole.png</code> 到底发生了什么事情？</p> <p>在本章，我们将检查与元素属性和特性相关的所有浏览器难题，我们会研究为什么结果不是我们所预期的。</p> <p>这同样适用于CSS和元素样式。构造一个动态Web应用程序时，我们会在设置或获取元素样式方面遇到很多的困难。</p> <p>让我们首先了解元素的特性和属性分别是什么。</p> <h3 id="dom特性和dom属性"><a href="#dom特性和dom属性" class="header-anchor">#</a> DOM特性和DOM属性</h3> <p>在访问元素的特性值时，有两种选择:使用传统的DOM方法getAttribute和setAttribute，或使用DOM对象上与之对应的属性。</p> <p>举例来说，一个元素保存在变量e中，要获取其id特性的话。我们可以使用如下方式:<code>e.getAttribute('id') e.id</code>无论哪种方式，都能获取id的值。</p> <p>让我们来看下面的代码，更好的了解特性值与之对应属性的行为。</p> <p>通过DOM方法和属性访问特性值:</p> <p><img src="/book/1601810955783.jpg" alt=""></p> <p>上述示例显示了一些元素属性和特性方面的一些有趣的行为。首先定义一个简单的<code>&lt;div&gt;</code>元素作为测试对象。在页面加载处理程序中，获取唯一<code>&lt;div&gt;</code>元素的引用，接着在运行一些测试。</p> <p>在第一个测试中，通过setAttribute()方法将id特性的值设置为&quot;ninja-1&quot;。然后断言getAttribute()在该特性上可以返回同样的值。在加载页面时，该测试正常通过，应该时意料之中的事情。</p> <p>同样，在接下来的测试中，我们将id属性的值设置为&quot;ninja-2&quot;，然后验证该属性的值确实时改变了。测试通过，没有问题。</p> <p>下一次测试就变得有趣了。再次将id属性的值设置为一个新值&quot;ninja-3&quot;，然后再一次验证该属性的值被改变了。然后还断言，不就属性值发生了变化，id特性值(attribute)也发生了变化。这两个断言测试都通过了。通过这些测试，我们知道id属性和id特性时以某种方式联系在一起的。修改id属性的值，也会改变id特性的值。</p> <p>下一个测试证明了另外一个方式也是对的:设置特性的值，也会改变属性的值。</p> <p>但不要被这个结论欺骗，认为属性和特性共享一个相同的值----其实并没有。我们稍后将看到，特性和对应的属性虽然有联系，但并不总是相同。</p> <p>在特性和属性方面，有五个要点需要考虑。</p> <ul><li>跨浏览器命名。</li> <li>命名限制。</li> <li>HTML和XML之间的差异。</li> <li>自定义特性的行为。</li> <li>性能注意事项。</li></ul> <h4 id="跨浏览器命名"><a href="#跨浏览器命名" class="header-anchor">#</a> 跨浏览器命名</h4> <p>在谈到特性和相应属性的命名时，属性的名称在不同的浏览器上通常更加一致。如果在一个浏览器中，我们用特定的名称能够访问一个属性，那么在其他浏览器中，很有可能也可以用同样的名称访问该属性。属性命名之间虽然会有一些差异，但特性和属性命名之间的差异则会更多。</p> <p>举个例子，在大多数浏览器中都可以用class获取到class特性，但IE却要使用className。这可能时因为该属性的名称时className，所以在IE中，特性名称和属性名称时一致的。一致性通常是一件好事，但在不同的浏览器中有不同的命名，却让人十分恼火。</p> <p>像jQuery这样的库，能够帮助我们规范化这些命名差异，允许我们使用一个特定的名称而不用关注浏览器平台，jQuery会在幕后在必要的转换工作。但如果没有库的支持，我们也应该可以意识到它们之间的差异，相应的也可以编写出自己的代码。</p> <h4 id="命名限制"><a href="#命名限制" class="header-anchor">#</a> 命名限制</h4> <p>特性，表示为传递给DOM方法的字符串，其命名规范是非常自由的，但属性名称，由于可以作为标识符使用点表示法进行访问，所以其命名规范是更受限的，属性命名必须符合标识符的规范，而且还有一些保留关键字也不能用。</p> <p>ECMASscipt规范指出，由于某些关键词不能作为属性名称，所以定义了一些替代方法。例如，<code>&lt;label&gt;</code>元素的for特性可以用htmlFor属性进行表示，因为for是一个保留字；并且所有元素的class属性是由className属性表示的，因为class也是保留字。另外，由多个单词组成的特性名称由&quot;骆峰式&quot;的属性名称来表示，例如，特性readonly的属性名称就是readOnly。在表中，可以找到更多关于这种差异的例子。</p> <p><img src="/book/1601813251756.jpg" alt=""></p> <h4 id="xml与html之间的差异"><a href="#xml与html之间的差异" class="header-anchor">#</a> XML与HTML之间的差异</h4> <p>属性自动和特性对应的整体概念是HTML DOM的一个特性。但在处理一个XML DOM时，不会在元素上自动创建属性值来表示特性值。因此，我们需要使用传统的DOM特性方法来获取特性的值。这不是一种强迫的做法，因为XML文档通常不会表现我们在HTML文件中看到的DOM特性那样的错误。</p> <h5 id="注意-如果不熟悉xml-dom术语的话-它就是一个描述xml文档的内存对象结构-其描述方式与html-dom描述html文档的方式是一样的。"><a href="#注意-如果不熟悉xml-dom术语的话-它就是一个描述xml文档的内存对象结构-其描述方式与html-dom描述html文档的方式是一样的。" class="header-anchor">#</a> 注意:如果不熟悉XML DOM术语的话，它就是一个描述XML文档的内存对象结构，其描述方式与HTML DOM描述HTML文档的方式是一样的。</h5> <p>最好是通过代码的形式检查一个元素(或文档)是否是一个XML元素(或文档)，以便进行相应的处理。如下函数，是这种类型检查的一个实例:</p> <div class="language- extra-class"><pre class="language-text"><code>function isXML(elem){
    return (elem.owerDocument || elem.documentElement.nodeName.toLowerCase() !== &quot;html&quot;);
}
</code></pre></div><p>如果元素是XML元素，该函数将返回true，否则返回false。</p> <h4 id="自定义特性的行为"><a href="#自定义特性的行为" class="header-anchor">#</a> 自定义特性的行为</h4> <p>并不是所有的特性都由元素的属性来表示。虽然折通常适用于HTML DOM的原生特性，但我们在页面元素上定义的自定义特性，则不会自动转换为元素属性的表达方式。要想访问这些自定义特性值，需要使用DOM方法getAttribute()和setAttribute()。</p> <p>如果不确定一个特性的属性是否存在，可以对其进行测试，如果不存在的话再使用DOM方法。这里有一个例子:<code>var value = element.someValue?element.someValu:element.getAttribute('someValue');</code></p> <h5 id="提示-在html5中-对所有的自定义特性使用data-前缀-以便遵守html5的规范。即便使用的是html4-也同样建议使用这种方式-以便将标签适应未来。除此之外-这是分高自定义特性和原生特性的一个很好的约定。"><a href="#提示-在html5中-对所有的自定义特性使用data-前缀-以便遵守html5的规范。即便使用的是html4-也同样建议使用这种方式-以便将标签适应未来。除此之外-这是分高自定义特性和原生特性的一个很好的约定。" class="header-anchor">#</a> 提示：在HTML5中，对所有的自定义特性使用data-前缀，以便遵守HTML5的规范。即便使用的是HTML4，也同样建议使用这种方式，以便将标签适应未来。除此之外，这是分高自定义特性和原生特性的一个很好的约定。</h5> <h4 id="性能注意事项"><a href="#性能注意事项" class="header-anchor">#</a> 性能注意事项</h4> <p>总得来说，属性的访问速度比相应的DOM特性方法的访问速度要快，特别是在IE浏览器中。让我们来证明一下。</p> <p>DOM方法和DOM属性之间的性能比较:</p> <p><img src="/book/1601815697028.jpg" alt=""></p> <p>上述代码，实现的是对DOM的getAttribute()和setAttribute()方法所进行的性能测试，并对相应的属性也进行类似操作。</p> <p>在多个浏览器上运行上述测试，收集的结果如图所示。所有的时间值都以毫秒为单位。正如大家可以看到的，属性的获取和设置操作机会总比getAttribute()和setAttribute()快。</p> <p><img src="/book/1601816104027.jpg" alt=""></p> <p>上述测试的一个实例结果。</p> <p><img src="/book/1601816175773.jpg" alt=""></p> <p>速度方面的差异对单次操作来说不会有太大的影响，上述代码可以执行很多次----例如，在严格的循环中。要提高性能，我们可能想要实现一个方法，在属性值存在的时候访问属性值，属性值不存在的时候利用DOM方法作为后备。考虑如下示例代码。</p> <p>设置/获取特性值的函数:</p> <p><img src="/book/1601816390701.jpg" alt=""></p> <p><img src="/book/1601816453323.jpg" alt=""></p> <p>上述示例，不仅创建了一个特性/属性值的设置/获取函数，还展示了一些我们在其他代码中可以重用的重要概念。</p> <p>在该函数中，由于需要将表中列出的属性和特性进行转换，所以我们创建了一个转换映射。但我们不想因为该映射来污染全局命名空间，我们希望它只在函数的局部作用域内才能使用，其他地方则不能使用。</p> <p>我们可以将map、映射定义和函数声明封装在一个即时函数内来实现次目的，该即时函数可以创建一个局部作用域。在即时函数之外，映射map是不可访问的，但是在即时函数中定义的set/get函数通过闭包却可以访问map。</p> <p>attr()函数展现出来的另外一个重要原则是----通过检查自身参数列表，该函数即可以作为设置器(setter)，也可以作为访问器(getter)。如果给函数传递了value参数，则该函数就作为一个设置器(setter)，将传入的值设置为特性的值；如果省略了value参数，也就是只传递了前两个参数，该函数就会作为访问器(getter)来获取指定特性的值。</p> <p>如果两种情况都不是，也会返回该特性的值，这使得可以很容易的以函数调用链的方式进行使用。</p> <p>应该注意的是，上述实现没有过多的考虑特性访问在跨浏览器方面的问题。让我们来找一下都是什么问题。</p> <h3 id="跨浏览器的attribute问题"><a href="#跨浏览器的attribute问题" class="header-anchor">#</a> 跨浏览器的attribute问题</h3> <h4 id="dom中的id-name膨胀"><a href="#dom中的id-name膨胀" class="header-anchor">#</a> DOM中的id/name膨胀</h4> <p>DOM处理中的最严重bug是浏览器对DOM代码实现的遗憾。</p> <p>前面一章我们指出的问题，&quot;五大&quot;浏览器都会将表单input元素的id和name特性作为<code>&lt;form&gt;</code>元素的属性值进行引用。产生的这些属性，会主动覆盖<code>&lt;form&gt;</code>元素上已经存在的同名属性。</p> <p>此外，IE浏览器不仅会替换属性值，甚至还会替换该属性上的特性值。</p> <p>浏览器&quot;强暴&quot;form元素的示例:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 创建测试对象 --&gt;
&lt;form id=&quot;testForm&quot; action=&quot;/&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;id&quot;/&gt;
    &lt;input type=&quot;text&quot; name=&quot;action&quot;/&gt;
&lt;/form&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
        var form = document.getElementById(&quot;testForm&quot;);
        //测试属性是否被&quot;蹂躏&quot;了
        assert(form.id === 'testForm',&quot;the id property is untouched&quot;);
        assert(form.id === '/',&quot;the id property is untouched&quot;);
        //测试特性是否被&quot;蹂躏&quot;了
        assert(form.getAttribute('id') === 'testForm',&quot;the id attribute is untouched&quot;);
        assert(form.getAttribute('action') === '/',&quot;the id attribute is untouched&quot;);


    }

&lt;/script&gt;
</code></pre></div><p>本系列的测试显示了，这个不幸的特性会导致标签数据的损失。首先，定义一个HTML表单以及两个input子元素。其中一个input的ID设置为id，另外一个input的那么设置为action。</p> <p>第一个测试是断言表单的id和action属性就是在HTML标签里设置的值，第二个测试则断言特性值也反应了标签值。</p> <p>但在Chrome六安来请你中运行这些测试，我们看到了如图所示的结果。</p> <p><img src="/book/1601818743923.jpg" alt=""></p> <p>在所有的现代浏览器中，由于这些input元素定义的id和name值，表单的id和action属性都会被input元素的引用所替代。原来的属性值都丢失了。除了IE以外，其他浏览器还可以用DOM特性的方法来获取原有的值，但在IE中，这些特性值也都被替换掉了。</p> <p>尽管浏览器尽最大努力不让我们看到这些值，但我们还是藏了一手的。我们可以获取描述元素的特性本身的原始DOM节点。该节点仍然没有被浏览器所修改。要获取DOM特性节点的值，比如说，获取action特性的值，可以这样表示:<code>var actionValu = element.getAttributeNode(&quot;action&quot;).nodeValue;</code>作为练习，看看是否可以利用这种方式来增强我们在代码中的编写的attr()方法，判断表单元素节点的特性值是否被其他元素的引用替换了，如果被替换掉了，就使用获取DOM节点的值这种后备方法。</p> <p>该问题不能被认为是一个bug，因为这是浏览器预期的行为。当元素的引用很容易使用向document.getElementById()或其他类似的方法获取到时，该问题就很具有破坏性，是完全不必要的。</p> <h4 id="url规范化"><a href="#url规范化" class="header-anchor">#</a> URL规范化</h4> <p>在所有的现代浏览器中，有一个违反最少意外原则的&quot;特性&quot;:在访问一个引用了URL的属性时(例如，href，src或action)，该URL值会自动将原始值转换成完整规范的URL。</p> <p>关于自动规范化，我们已经有过警告。不过让我们编写一个测试，在如下代码清单中再来演示一下这个问题。</p> <p>演示URL规范化问题:</p> <p><img src="/book/1601862591180.jpg" alt=""></p> <p>在这个测试中，我们创建了一个连接标签，并定义了href属性，将其引用到页面自身。接着获取该元素的一个引用进行测试。</p> <p>在前面我们学到的一个技巧----通过DOM的原始节点找出该标签的原始值----然后利用该值。在盲目认为这种技巧能用之前，我们要对该值进行验证。</p> <p>然后对该属性进行测试，看是否匹配。该测试在所有的浏览器中都失败了，因为该值被转换成规范的URL值了。</p> <p>最后，测试看特性值是否被修改了。除了旧版IE之外，该测试在所有的浏览器上都通过了。</p> <p>这些测试的结果，不仅展示了问题的本质，同时也提供了解决方案:当我们想获取不被修改的特性值时，我们可以使用DOM节点法这样的技巧来获取这样的值。</p> <p>对于旧版本IE(IE8之前的版本)，IE浏览器对getAttribute()方法还有另外一个专有扩展。向该方法传递第二个参数，值为2，强制获取未被规范化的值:<code>var original = link.getAttribute('href',2);</code></p> <p>我们可以在现代浏览器中使用这种方法:因为DOM节点法可以适用于所有的浏览器，而且IE之外的现代六安来请你都会忽略传递给getAttribute()的第二个参数。不过，在传递第二个参数时，Opera会无缘无故崩溃，所以如果需要支持该浏览器，就需要避免使用这种方法。</p> <p>URL规范化问题在代码中出现问题的可能性很小，除非编写的代码需要获取非规范值。</p> <h4 id="style特性"><a href="#style特性" class="header-anchor">#</a> style特性</h4> <p>style时一个非常重要的元素特性，在设置或获取其值时特别具有挑战性。HTML DOM元素有一个style属性，通过该属性我们可以获取元素的样式信息，例如，element.style.color。但是，如果我们想获取在元素上设置的原有style字符串的话，则更具有挑战性。举个例子，考虑如下标签:<code>&lt;div style='color:red;'&gt;&lt;/div&gt;</code> 如果要获取原来的color:red;字符串，该怎么办？</p> <p>style属性根本没用，因为它是一个对象，将包含原始字符串的解析结果。尽管getAttribute(&quot;style&quot;)可以在大多数浏览器上使用，但在IE浏览器上却无法使用。而在IE中的style对象上，有一个名为cssText的属性记录的时原始字符串，例如，element.style.cssText。</p> <p>虽然直接获取style特性的原始值的操作可能是相对少见，但它确实时一个问题，可能会影响运行时创建DOM元素的页面。</p> <h4 id="type特性"><a href="#type特性" class="header-anchor">#</a> type特性</h4> <p>另外还有一个IE陷阱，IE8以及之前的版本对<code>&lt;input&gt;</code>元素的type特性的影响。没有任何合理的解决方案。一旦<code>&lt;input&gt;</code>元素被插入到文档，它的type特性就不能在改变了。起始，如果要修改它，IE浏览器会抛出一个异常。</p> <p>举个例子，思考下面的代码，在input元素插入到DOM以后，我们尝试修改它的type。</p> <p><img src="/book/1601863833207.jpg" alt=""></p> <p>在本测试中，我们创建了一个新的<code>&lt;input&gt;</code>元素，将type设置为text，断言type的赋值是成功的，然后将该新元素插入到DOM中。插入之后，将type的值修改未hidden，然后断言修改的结果。</p> <p>除了IE，在所有的现代浏览器上进行测试，测试都通过了，没有任何问题。然后，对于IE8和之前版本的浏览器，在赋值时抛出了异常，并且第二个测试根本就没有执行。</p> <p>虽然不存在简单的解决方案，但我们可以采取如下两个应急措施。</p> <ul><li>不要尝试修改type，而是新创建一个<code>&lt;input&gt;</code>元素，将原有元素的所有属性和特性都赋值到新元素上，然后使用该新元素替换原有元素。这个解决方案似乎很容易，但也有问题。首先，新元素没办法知道在原有元素上使用DOM level2方案所绑定的事件处理程序，除非我们一直都在跟踪这些事件处理程序；其次，所有原有元素的引用都会失效。</li> <li>对于任何修改属性和特性的API，在该API内简单拒绝type的修改即可。</li></ul> <p>这两种方式，都不是100%完美。</p> <p>jQuery使用了第二种方法，如果一个元素已经被插入文档中了，在尝试修改type特性时，会抛出一个信息异常。很显然，这是一个折衷的&quot;解决方案&quot;，但至少用户体验在所有的平台上都是一致的。值得庆幸的是，该问题已经在IE9中得到了解决。</p> <h4 id="tab-index问题"><a href="#tab-index问题" class="header-anchor">#</a> tab index问题</h4> <p>确定元素的tab index是浏览器抛出给我们的另一个奇怪的问题，没有什么达成一致的解决方案。对于已经显示声明的tab index的元素，也许可以使用元素的tabIndex属性或tabindex特性获取该元素的tab index值，但如果没有显示声明，tabIndex属性会返回0，而tabindex特性则返回null。这就是说，如果不显示设置tab index，我们就无法获取到一个元素的tab index。</p> <p>这是一个复杂的问题，在可用性和可访问性方面，它是一个重要的问题。</p> <p>最后一个与特性相关的问题，其实根本不是一个真正的特性问题。</p> <h4 id="节点名称"><a href="#节点名称" class="header-anchor">#</a> 节点名称</h4> <p>具体来说，节点名称大小写敏感性的变化取决于检查的文件类型。如果是一个普通的HTML文档，nodeName属性返回的元素名称都将是大写(如HTML或BODY)。但如果是在一个XML或XHTML文档中，nodeName属性返回的名称则是用户指定的名称，也就是大写或任何组合。</p> <p>解决该问题的传统解决方案是，在比较之前进行规范化，如都转换成小写。举个例子，如果我们只想在<code>&lt;div&gt;</code>和<code>&lt;ul&gt;</code>元素上执行一些操作，如果不知道节点名称时，可能会得到&quot;div&quot;或&quot;DIV&quot;甚至是&quot;dIv&quot;,我们可以像如下代码这样规范化这些名称:</p> <div class="language- extra-class"><pre class="language-text"><code>var all = document.getElementsByTagName(&quot;*&quot;)[0];

for(var i=0;i&lt;all.length;i++){
    var nodeName = all[i].nodeName.toLowerCase();
    if(nodeName === &quot;div&quot;||nodeName === &quot;ul&quot;){
        all[i].className = &quot;found&quot;;
    }
}
</code></pre></div><p>当我们明确知道代码执行的文档类型时，就没有必要在担心大小写的情况了，但如果我们要编写在任何环境中都可以运行的可重用代码时，最好谨慎一些并执行规范化。</p> <h3 id="令人头疼的样式特性"><a href="#令人头疼的样式特性" class="header-anchor">#</a> 令人头疼的样式特性</h3> <p>与一般特性的获取和设置相比，样式特性的获取和设置可谓是让人相当头痛。就像我们在前面研究的特性和属性一样，本节我们也是才用两种方式来处理style值:特性值，以及从特性值中创建的元素属性。</p> <p>最常用的是style元素属性，它并不是一个字符串，而是一个对象，该对象包含的属性对应元素标签内设置的样式值。此外，我们还会发行有一个API可以访问一个元素的计算样式，该&quot;计算样式&quot;是对所有继承样式和应用样式求值以后，在该元素上应用的实际样式。</p> <h4 id="样式在何处"><a href="#样式在何处" class="header-anchor">#</a> 样式在何处</h4> <p>元素的样式信息位于DOM元素中的style属性上，该属性的初始值是在元素的style特性上设置的。例如，style=&quot;color:red;&quot;,将会把该样式信息保存在样式对象上。在页面执行期间，脚本可以对样式对象中的值进行设置或修改，并且这些修改将主动影响元素的显示。</p> <p>很多脚本作者失望的发现，他们获取不到<code>&lt;style&gt;</code>元素的值，而且外部样式表也无法在元素的style对象上使用。但是我们不会失望太久----不久就可以看到一种获取这类信息的方式。</p> <p>但现在，先让我们来看一下style属性是如何获取到值的。阅读如下代码。</p> <p><img src="/book/1601885088570.jpg" alt=""></p> <p>在本例中，创建一个<code>&lt;style&gt;</code>元素使之成为一个内部的样式表，其值将应用在页面的元素上。该样式表指定所有<code>&lt;div&gt;</code>元素的字体大小是默认字体大小的1.8倍，并且还有一个宽度未0的solid gold边框。也就是说，任何应用了该样式的元素都有一个边框，只不过由于其宽度为0，所以是不可见的。</p> <p>然后，我们创建一个带有style特性的<code>&lt;div&gt;</code>元素的引用后，我们测试style特性接收了一个描述元素颜色的color属性。注意，即便在内敛样式里color设置的是#000，但在大多数浏览器内，将其设置到style属性的时候，该颜色会抓换成规范化RGB值。如图所示，测试通过。</p> <p><img src="/book/1601885561073.jpg" alt=""></p> <h5 id="警告-颜色规范化在跨浏览器时并不总是一致的-甚至在特定浏览器上也不一致。大多数颜色都会转换成规范化的rgb颜色符号-但一些浏览器会将颜色转换为颜色的名称-例如-black-。"><a href="#警告-颜色规范化在跨浏览器时并不总是一致的-甚至在特定浏览器上也不一致。大多数颜色都会转换成规范化的rgb颜色符号-但一些浏览器会将颜色转换为颜色的名称-例如-black-。" class="header-anchor">#</a> 警告：颜色规范化在跨浏览器时并不总是一致的，甚至在特定浏览器上也不一致。大多数颜色都会转换成规范化的RGB颜色符号，但一些浏览器会将颜色转换为颜色的名称(例如，black)。</h5> <p>接着，我们天真的测试内联样式表中定义的font-size和borde宽度都被记录到style对象上了。如上图，即便我们看到页面上的字体样式已经应用到该元素上了，但测试仍未通过，这是因为style对象不反映从CSS样式表中继承的任何样式信息。</p> <p>接下来，使用一个赋值语句，将style对象的borderWidth属性值修改未4像素，并且测试该修改被应用了。如上图，我们可以看到该测试通过了，以前看不见的边框现在也已经应用到该元素上了。该赋值语句导致borderWidth属性出现在元素的style属性上了，这一点已经测试证明了。</p> <p>应该指出的是，一个元素的style属性中的任何一个样式的优先级都要高于样式表中所继承的样式(即便样式表中使用了!important注解规则)。</p> <h4 id="样式属性命名"><a href="#样式属性命名" class="header-anchor">#</a> 样式属性命名</h4> <p>用CSS特性进行跨浏览器访问样式时，出现的跨浏览器问题相对较少。但是，CSS样式名称和脚本中使用的名称之间的差异确实是存在的，并且有些样式名称在不同的浏览器中还不一样。</p> <p>CSS特性将多于一个单词的样式用连字符进行分隔，例如:font-weight,font-size,background-color。在JavaScript中，可以使用带有连字符的样式名称，但是如果使用连字符，就不能使用点运算符来访问样式了。</p> <p>看一下这个例子:<code>var color = elemnt.style['font-size'];</code></p> <p>上述代码完全有效。但是这段代码却不行:<code>var color = elemnt.style.font-size;</code></p> <p>JavaScript解析器会将连字符作为减法运算符，没人希望有这样的结果。为了不强迫页面开发人员总用一般的属性访问形式，多个单词的CSS样式名称作为属性名称时，会转换未驼峰格式。因此，font-size会转换为fontSize，background-color会转换为backgroundColor。</p> <p>我们可以记住这种做法，或者也可以编写一个简单的API自动将样式转换未驼峰格式，从而设置或获取样式，示例如下所示。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div style=&quot;color:red;font-size:10px;background-color:#eee&quot;&gt;

&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
//自定义style函数
    function style(element,name,value){
        //转换未驼峰格式
        name = name.replace(/-([a-z])/ig,function(all,letter){
            return letter.toUpperCase();
        });
        //提供了样式值的话，就进行设置
        if(typeof value!=='undefined'){
            element.style[name] = value;
        }
        //返回该样式的值
        return element.style[name];
    }
    window.onload = function(){
        var div = document.getElementsByTagName('div')[0];
        assert(true,style(div,'color'));
        assert(true,style(div,'font-size'));
        assert(true,style(div,'background-color'));
    }

&lt;/script&gt;
</code></pre></div><p>该函数尽管包含了很多许多assert()调用，但我们没对该函数执行任何测试----我们只是使用断言作为一种懒惰的方式在页面上输出结果而已，如图所示:</p> <p><img src="/book/1601889010498.jpg" alt=""></p> <h4 id="float样式属性"><a href="#float样式属性" class="header-anchor">#</a> float样式属性</h4> <p>在style特性中，一个让人头痛的问题是float特性的处理方式。该属性需要进行特别处理，因为float是JavaScript的保留关键字。浏览器需要提供另外一个替代名称。</p> <p>由于经常发生这些情况，因此符合标准的浏览器用的是一种方式，而IE浏览器用的却是另外一种方式。几乎所有的浏览器都选择使用cssFloat这个名字作为替代名称，但IE浏览器却选择使用styleFloat。</p> <h4 id="像素值的转换过程"><a href="#像素值的转换过程" class="header-anchor">#</a> 像素值的转换过程</h4> <p>设置样式时需要考虑的另外一个要点是，表示像素值的数值赋值。在废弃特性上指定像素值时，我们指定一个数字，然后让浏览器来处理数字的单位，如<code>&lt;img&gt;</code>标签的height特性。但给style属性设置像素值时，这种放肆却给我们带来了很多麻烦。</p> <p>为style属性设置数字值时，必须要指定单位，以便在所有浏览器上都能工作。举个例子，如果我们要为一个元素的height样式设置为10像素。在跨浏览器方面，如下两种方式都是安全的。<code>element.style.height=&quot;10px&quot;;element.style.height=10+&quot;px&quot;;</code> 但如下方式却是不安全的:<code>element.style.height=10;</code></p> <p>大家可能会认为，在前面代码style()函数中，简单的在数值后面加一个&quot;px&quot;就行了。但是没有这么快就能解决问题!并不是所有的数值都表示像素!有很多style的属性值表示的不是像素尺寸。</p> <ul><li>z-index。</li> <li>font-weight。</li> <li>opacity。</li> <li>zoom。</li> <li>line-height。</li></ul> <h4 id="测量元素的高度和宽度"><a href="#测量元素的高度和宽度" class="header-anchor">#</a> 测量元素的高度和宽度</h4> <p>height和width这样的style属性造成了另外一个特殊问题，因为如果不指定值的话，它们的默认值就是auto，以便让元素的大小根据其内容进行决定。因此，除非显式提供特性字符串，我们是不能使用height和width来获取准确的值的。</p> <p>值得庆幸的是，offsetHeight和pffsetWidth属性都提供了这样的功能：可以相当可靠的访问实际元素的高度和宽度。但是请注意，这两个属性的值都包含了元素的padding值。如果我们想将一个元素相对于另外一个元素进行定位，这些信息通常是我们所需要的。但有的时候，我们想获取的元素尺寸，可能包括也可能不包括边框(border)或者内边距(padding)。</p> <p>然而，需要当心的是，在高度交互的网站中，元素的隐藏(display设置为none时)可能会花一些时间，而且一个元素如果不显示的话，它就没有尺寸。在非显式元素上，只要尝试获取offsetWidth或offsetHeight属性值，结果都是0。</p> <p>对于这样的隐藏元素，如果希望获取它在非隐藏状态时的尺寸，我们可以使用一个技巧，暂时取消元素的隐藏，然后获取值，然后在将其隐藏。当然，我们希望这种做法不会有明显的视觉效果，而只是幕后做。如何才能将一个隐藏的元素，在不可见的情况下变成不隐藏呢？</p> <p>使用我们的忍者技艺，我们可以做到!方法如下。</p> <ul><li>将display属性设置为block。</li> <li>将visibility设置为hidden。</li> <li>将position设置为absolute。</li> <li>获取元素尺寸。</li> <li>恢复先前更改的属性。</li></ul> <p>将display属性修改为block，可以让我们获取offsetHeight和offsetWidth的真实值，但它将元素变成显示状态而因此可见。要让该元素不可见，需要将visibility设置为hidden。但是这种做法将导致在元素的位置上显示一片空白，所以我们需要将position属性设置为absolute，以便将元素移出正常的显示流。</p> <p>获取隐藏元素的尺寸:</p> <p><img src="/book/1601897567171.jpg" alt=""> <img src="/book/1601897654841.jpg" alt=""></p> <p>该代码清单非常长，但大多数都是测试代码，新尺寸获取函数的实现代码只有十几行而已。</p> <p>让我们来逐步分析一下。首先，我们创建一些要测试的元素:一个<code>&lt;div&gt;</code>元素包含一大段嵌有两个图片的文本。通过外部样式表将其左对齐。这些图像元素就有我们要测试的内容:一个是可见的，一个是隐藏的。</p> <p><img src="/book/1601897937659.jpg" alt=""></p> <p>运行脚本之前，上述元素的显式状态如上图。如果第二个图片不隐藏，就会在第一个忍者右边显示。</p> <p>其次，开始定义新函数。我们使用一个哈希来保存一些重要的信息，所以重复使用前面所将的代码中的技巧，将局部变量和函数声明放在即时函数内，从而创建一个局部作用域和闭包。局部的哈希中包含了我们要进行修改的属性，分别是三个属性和它们的替换值。</p> <p>然后声明新的尺寸获取函数，并接收要进行尺寸测量的元素。在该函数中，首先创建一个名为previous的哈希，在该哈希内我们保存style属性的原有值，以便稍后可以恢复它们。循环变量要替换的属性，先记录之前的值，在替换成新值。</p> <p>替换完毕，然后就可以对元素进行测量了，该元素此时是显示状态，但不可见，且绝对定位。元素的尺寸保存在变量result中。</p> <p>这时候，偷来的东西可以还回去了，将修改过的属性的值恢复成原有的值，然后将包含width和height属性的result值进行返回。</p> <p>代码不错，但是实际能用吗？我们来验证一下。</p> <p>在load处理程序中，我们在一个3秒的定时器回调中进行测试。大家可能会问为什么？因为load处理程序确保我们在DOM构建完成以后才开始执行，定时器则确保在测试运行时能看到显示结果，确保我们在修改隐藏元素时没有显示故障。毕竟，如果运行测试时，页面显示收到任何干扰，则就达不到测试目的了。</p> <p>在定时器回调中，首先获取测试对象的引用，可以断言我们可以通过offset属性获取可见图片的尺寸。测试通过。</p> <p>然后对隐藏元素进行同样的测试，错误的假设offset属性在隐藏图像中也能使用。毫不奇怪，因为我们已经知道offset属性不能正常工作了，所以测试失败了。</p> <p><img src="/book/1601899101307.jpg" alt=""></p> <p>接下来，在隐藏元素上调用我们的新函数，并重新运行上述测试。测试通过！</p> <p>运行测试的时候，如果我们查看页面的显示----记得，我们在DOM加载之火3秒才开始运行测试----我们可以看到对隐藏元素的属性调整不会影响页面的显示。</p> <h5 id="提示-检查offsetwidth和offsetheight属性值是否为0-可以非常有效的确定一个元素的可见性。"><a href="#提示-检查offsetwidth和offsetheight属性值是否为0-可以非常有效的确定一个元素的可见性。" class="header-anchor">#</a> 提示:检查offsetWidth和offsetHeight属性值是否为0，可以非常有效的确定一个元素的可见性。</h5> <h4 id="通过opacity看透明度"><a href="#通过opacity看透明度" class="header-anchor">#</a> 通过opacity看透明度</h4> <p>opacity属性是另外一个需要以不同方式进行跨浏览器处理的特殊情况。所有的现代浏览器，包括IE9，都原生支持opacity属性，但IE9之前的版本则使用专用的alpha过滤法。</p> <p>正因为如此。我们经常看到在样式表中都是按如下方式声明opacity样式的:<code>opacity:0.5;flutter:alpha(opacity=50);</code></p> <p>标准用法是，取值范围是从0.0到1.0来表示元素的 不透明度，而alpha过滤法则使用整数百分比从0到100来表述不透明度。上述代码指定的不透明度值为50%。</p> <p>假设有一个元素，用两个方式都定义了不透明度，示例如下:<code>&lt;div style=&quot;opacity:0.5;flutter:alpha(opacity=50);&quot;&gt;Hello&lt;/div&gt;</code></p> <p>当尝试获取这些值时，我们面对的问题是双重的。</p> <ul><li>除了alpha之外，有很多不同类型的过滤器，如转换，所以我们必须处理很多过滤器类型，不能假定过滤器总是指定透明度。</li> <li>尽管IE8和早期版本不支持opacity，通过style.opacity属性取值时，返回的依然是opacity值，即使浏览器完全忽略了opacity值。</li></ul> <p>后面这一点使得我们难以确认浏览器是否原始支持opacity。但我们可以再次利用我们的技巧，傲视这些顽固问题。</p> <p>事实证明，支持opacity的浏览器，总会将opacity值规范成小于1.0且以0开头的值。例如，如果将opacity指定为:.5，原始支持opacity的浏览器就会将该值规范为0.5,而不原始支持opacity的浏览器则直接返回原有的形式.5。</p> <p>这意味着，我们可以使用特性仿真来判断浏览器是否原生支持opacity。代码如下:</p> <p><img src="/book/1601950825319.jpg" alt=""></p> <p>在本例中，我们定义了一个图像元素，并将opacity值设置为.5。我们不会在示例中使用这个元素:它只是为我们提供了一个视觉判断，判断浏览器是否应用了opacity的值。</p> <p>接下来是测试代码，我们创建一个未来DOM上附加的元素，然后为该元素增加一个opacity属性，值为.5。然后重新读取该值，判断该值是等于原始值还是等于修改后的0.5，根据判断结果来确定浏览器是否原生支持opacity。</p> <p>最后，断言该结果变量，如果测试通过，则表示浏览器支持opacity，不通过则表示不支持opacity。</p> <p>运行结果如下:</p> <p><img src="/book/1601952352975.jpg" alt=""></p> <h4 id="颜色属性"><a href="#颜色属性" class="header-anchor">#</a> 颜色属性</h4> <p>通过不同的计算样式方法访问这些颜色值的时候，各种浏览器的返回值几乎没有一致的格式。因此，任何试图获取部分颜色值----红，蓝，绿的方式，以及我们将看到的alpha方式----都会产生很大的麻烦。</p> <p>很多格式的颜色可以在现代浏览器中进行渲染。总结列表如图:</p> <p><img src="/book/1601952737999.jpg" alt=""></p> <p>从上图中的信息可以看到，页面开发人员在表达颜色信息方面有很大的灵活性，如果浏览器将这些类型的值保存在style的时候都转换成一致格式的话，就不会有什么问题。但是它们没有转换，所以我们遇到问题了。</p> <p>编写一个测试，看看浏览器是如何捉弄我们的。阅读如下代码:</p> <p><img src="/book/1601953020956.jpg" alt=""></p> <p>首先创建一些列的<code>&lt;div&gt;</code>元素，在这些元素上以不同的格式设置不同的背景颜色样式属性。然后获取这些元素的引用，并遍历这些元素，显示存储在style.backgroundColor属性上的值。</p> <p>针对不同方式声明的颜色，上述代码可以测试除浏览器执行的哪种方式转换。如图所示，所有的保存格式都进行了转换。</p> <p><img src="/book/1601953346387.jpg" alt=""></p> <p>该方法应该接受一个元素和一个颜色属性(如color或background-color)，并返回一个颜色关键字，该关键字包含red，green，blue和alpha属性，或者是包含hue，lightness，saturation和alpha属性。</p> <h3 id="获取计算样式"><a href="#获取计算样式" class="header-anchor">#</a> 获取计算样式</h3> <p>在任何时候，一个元素的计算样式都是应用在该元素上的所有样式的组合，这些样式包括样式表，元素的style特性，以及脚本对style属性的各种操作。</p> <p>W3C指定的标准API，所有现代浏览器都实现了，实现方法为:window.getComputedStyle()。该方法接受一个要进行样式计算的元素，并返回一个可以进行属性查询的接口。返回接口提供了一个名为getProptertyValue()的方法，用于检索特定样式属性的计算样式。</p> <p>与元素的style对象中的属性不同，getPropertyValue()方法接受CSS属性名称，而不是&quot;骆峰式&quot;格式的名称。</p> <p>IE9之前的版本提供了一个专有技术来访问元素的计算样式:附加到所有元素上的currentStyle属性，它的表现就像style属性一样，唯一的不同是它提供的信息是实时的计算样式信息。</p> <p>已经有足够的信息可以编写一个fetchComputedStyle()方法，来计算一个元素的任何一个样式属性了。</p> <p>如下代码清单，实现了我们的计算样式函数。如果标准方式可用时，就使用标准方式，否则就使用专有方式。</p> <p><img src="/book/1601954088360.jpg" alt=""></p> <p>要测试新创建的函数，我们先创建一个元素并在其标签内指定样式信息，然后定义一个样式表用于将样式规则应用到该元素上。我们期望的是，该元素的计算样式是同时应用两种样式的结果。</p> <p>接下来，开始定义新函数，它接受一个元素和一个样式属性来查找要计算的值。为了表示友好，我们允许传入不同格式的多单词属性名称:连字符格式的，或者骆峰式的。换句话说，不仅接受backgroundColor，还接受background-color。我们将看到如何实现这一点。</p> <p>首先要做的事情就是，检查标准方式是否可用----所有浏览器都会返回true。如果支持标准方式，就继续获取计算样式接口，然后将其保存在一个变量中稍后进行引用。我们这样做的目的是因为我们不知道这个调用有多昂贵，所以要尽量避免不必要的重复。</p> <p>如果成功了，就调用接口的getPropertyValue()方法来获取计算样式的值。但首先我们调整属性的名称，以适应&quot;骆峰式&quot;或连字符式的属性名。getPropertyValue()方法期望连字符格式的属性名称，所以我们使用了String's的replace()方法，利用一个简单而灵活的正则表达式，在每个大写字母签插入一个连字符，然后将所有的字符都转换成小写。</p> <p>如果检查到标准方式并不可用，我们就继续测试IE专有的currentStyle属性是否可用，如果可用，就将所有的前面有连字符的替换成小写字母的大写形式，并返回该属性的值。</p> <p>在任何情况下，如果出了什么错误，我们就什么值也不返回。</p> <p>要测试该函数，以不同的格式传入不同的样式名称，对该函数进行多次调用，并显示结果，如图所示:</p> <p><img src="/book/1601954735312.jpg" alt=""></p> <p>注意，不论样式是在元素上显示声明的，还是继承自样式表的，都可以获取得到。还要注意，两种方式都指定了color属性，但是返回的是在元素上显式指定的值。元素的style特性指定的样式优先级永远高于继承的样式，即便继承的样式标记为!important也没用。</p> <p>在处理样式属性的时候，还有一个问题我们需要注意:混合属性。CSS允许我们使用快捷方式表示混合属性，比如border-属性。不必强迫单独对四个边框都指定颜色，宽度，边框样式，只需要使用如下规则即可:<code>border:1px solid crimson;</code></p> <p>在上图中使用了该规则。这种规则节省了大量的输入，但是我们需要注意，在获取属性时，我们需要检索的是底层的单个属性。我们不能检索border，而是应该检索像border-top-color和border-top-width这样的属性，就像在示例中所做的那样。</p> <h2 id="不老事件"><a href="#不老事件" class="header-anchor">#</a> 不老事件</h2> <h3 id="绑定和解绑事件处理程序"><a href="#绑定和解绑事件处理程序" class="header-anchor">#</a> 绑定和解绑事件处理程序</h3> <p>在DOM Level2 Event Model下，对于兼容于DOM的现代浏览器，我们绑定和解绑事件处理程序使用的是addEventListener()和removeEventListener()方法；而对IE老版本使用的则是attachEvent()和detachEvent()方法。</p> <p>为了清晰起见，我们将简单的将DOM Level2 Event Model成为DOM Model，将IE旧版的模型成为IE Model。前者在五大浏览器的所有现代版本上都可用；而后者则在所有IE版本上都可用，但这里的所有是值IE9之前的版本。</p> <p>在大多数情况下，这两个方法都很类似，只有一个明显的例外:IE Model没有提供事件捕获阶段的监听方式。IE Model只支持事件处理过程中的冒泡阶段，</p> <p>此外，IE Model的实现给绑定处理程序设置了错误的上下午，使得处理程序内的this引用的是全局上下文(window)，而不是事件目标元素。另外，IE Model没有将事件信息传递给处理程序，而是将事件信息定死是在全局上下文上了----window对象。</p> <p>这意味着，在处理如下类型的事件时，我们需要根据不同的浏览器来指定不同的方式。</p> <ul><li>绑定一个处理程序时。</li> <li>解绑一个处理程序时。</li> <li>获取事件信息时。</li> <li>获取事件目标时。</li></ul> <p>很难编写强大且可重用的代码，在事件处理的每个步骤内，我们都需要进行浏览器检测然后在根据不同的方式进行处理。让我们看看怎么样才能创建一组通用的API来打破这种混乱。</p> <p>绑定事件处理程序时，设置正确的上下文:</p> <p><img src="/book/1601956834659.jpg" alt=""></p> <p>上述代码在全局上下文中添加了两个方法:addEvent()和removeEvent()，这两个方法根据不同的浏览器环境有不同的代码实现。如果DOM Model存在，就使用DOM Model，如果不存在，并且IE Model存在，则使用IE Model。</p> <p>上述代码实现是非常简单的。检查DOMModel是否定义之后，就定义了包装函数来封装标准的DOM方法:一个用于绑定事件处理程序，另外一个用于解绑事件处理程序。</p> <p>注意，绑定函数的返回值是事件处理程序，并且传递给DOM事件API方法的第三个参数值是false。该标识说明使用冒泡处理程序，因为它们要用于跨浏览器环境，所以我们的函数无法支持捕获阶段。</p> <p>如果DOM Model不存在，然后在判断IE Model是否已定义，如果定义了，就使用该模型来定义上述两个函数。</p> <p>在IE Model下，解绑函数只是IE Model解绑函数的一种简单包装，但绑定函数就是另外一回事了。</p> <p>还记得吗？定义包装函数的主要原因之一是，除了定义一个统一的API以外，还要解决在事件目标上正确设置上下文的问题。所以，在绑定函数内不能简单的将处理程序函数(fn函数)传递给模型函数，首先要将其包装在一个匿名函数内，使用apply()方法调用的时候强制将上下文设置为目标元素，然后将该匿名包装函数作为处理程序传递给模型函数。这样，在包装函数被事件触发时，处理程序调用的时候就会有正确的上下文了。和其他函数一样，我们将处理程序作为函数值进行返回，但是我们这次返回的是匿名包装函数，而不是传递fn函数。</p> <p>返回该函数是很重要的，是因为稍后要解绑该处理程序的时候，需要传入根据模型函数而设置的处理程序的引用。</p> <p>如下代码，让我们来测试一下如何进行解绑。该测试需要用户的干预，所以我们不会使用断言。我们将简单的与页面进行交互，并观察测试结果。</p> <div class="language- extra-class"><pre class="language-text"><code>//声明一个load处理程序
addEvent(window,&quot;load&quot;,function(){
    //获取测试元素
    var elems = document.getElementsByTagName(&quot;div&quot;);
    //声明测试处理程序
    for(var i=0;i&lt;elems.length;i++){
        (function(elem){
            this.style.backgroundColor = this.style.backgroundColor==''?'green':'';
            //解绑处理程序
            removeEvent(elem,'click',handler);
        })(elems[i]);
    }
});
</code></pre></div><p>需要等到DOM加载以后才能进行测试，所以我们先用我们正在测试的API建立一个load事件处理程序，然后在内部在绑定其他事件。如果绑定函数不起作用，其他测试则永远不会有机会运行。</p> <p>在load处理程序中，我们获取页面上所有<code>&lt;div&gt;</code>元素的引用作为我们的测试目标，并遍历集合中的元素。</p> <p>对于每一个目标元素，我们使用addEvent()给该元素建立一个单击(click)处理程序，将返回的函数引用保存在名为handle的变量上。我们是在闭包里建立该处理程序的，因为我们要在处理函数内部引用函数自身。请注意，在这种情况下我们不能依赖于callee，因为在IE Model模式下，返回的函数和我们传入的函数是不同的。</p> <p>在单击(click)处理程序中，通过this引用目标元素，判断是否设置了元素的背景颜色，如果没有设置，就将其设置为绿色。如果就这样设置的话，每次单击都会让元素的背景颜色在绿色和无色之间进行切换。</p> <p>但我们并不仅仅这样设置。在处理程序退出之前，调用removeEvent()函数，并将handler变量绑定到闭包上，从而删除该处理程序。因此，处理程序一旦被触发一次，就不在被触发了。</p> <p>如果在页面中添加如下元素，并确保没有应用样式表的话，我们预计，单击每个<code>&lt;div&gt;</code>都会将其变成绿色，再单击的话，则不会切换背景:</p> <p><img src="/book/1601961845245.jpg" alt=""></p> <p>在浏览器中加载该页面，并手工验证我们的函数能按预期运行。如下图，该显示结果是首先在Chrome中加载页面，然后对第一个元素进行多次单击，而第二个元素则根本不单击。</p> <p><img src="/book/1601961952294.jpg" alt=""></p> <p>在不支持DOM Model的IE8中加载相同的页面，执行相同的行为后，其测试结果如下图。</p> <p><img src="/book/1601962224034.jpg" alt=""></p> <p>这是一个好的开始，但是它展示了一些弱点。主要的问题示因为，需要在老版本IE下包装处理程序，所以API用户需要仔细记录addEvent()函数返回的处理程序引用。如果做的不对，则会导致稍后无法解绑该处理程序。</p> <p>另一个缺点是，这种解决方案没有解决事件信息访问的问题。</p> <p>我们已经取得了进步，但还未达到我们所期望的效果。</p> <h3 id="event对象"><a href="#event对象" class="header-anchor">#</a> Event对象</h3> <p>正如我们已经指出的那样，我们需要在老版本浏览器里被迫处理的IE Model，在很多方面和DOM Model都不相同。其中之一就是让Event对象的实例在处理程序中可用。在DOM Model中，Event对象实例是作为第一个参数传入到处理程序中的；而在IE Model中，则是通过全局上下文(window.event)的event属性来获取到的。</p> <p>让事情更糟的是，这两个模型中，Event实例的内容是不相同的。</p> <p>解决该问题的唯一合理方案是创建一个新的对象来模拟浏览器的原始事件对象，将原始事件的属性进行规范化以匹配DOM Model。大家可能想知道,为什么不直接修改现有对象？但这是不可能的，因为原生事件对象中有很多属性不能被覆盖。</p> <p>克隆事件对象的另外一个优点是，它解决了IE Model在全局上下文中保存对象的问题。新事件开始时，前一个事件的Event对象就消失了。将事件属性转移到一个新对象上，我们可以控制新对象的生命周期，从而可以解决任何潜在问题。</p> <p>规范化Event对象实例：</p> <div class="language- extra-class"><pre class="language-text"><code>function fixEvent(event){
    //预定义常用的函数
    function returnTrue(){return true;}
    function returnFalse(){return false;}
    //测试是否需要修复
    if(!event || !event.stopPropagation){
        var old = event||window.event;
        //Clone the old object so that we can modify the values
        event = {};
        //克隆现有的属性
        for (var prop in old) {
            event[prop] = old[prop];
        }
        //The event occurred on this element
        if(!event.target){
            event.target = event.srcElement || document;
        }
        //Handle which other element the event is related to
        event.relatedTarget = event.fromElement === event.target?event.toElement:event.fromElement;

        //Stop the default browser action
        event.preventDefault = function(){
            event.returnValue = false;
            event.isDefaultPrevented = returnTrue;
        };

        event.isDefaultPrevented = returnFalse;
        //Stop the event from bubbling
        event.stopPropagation = function(){
            event.cancelBubble = true;
            event.isPropagationStopped = returnTrue;

        }
        event.isPropagationStopped = returnFalse;

        //Stop the event from bubbling and executing other handlers
        event.stopImmediatePropagation = function(){
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        };

        event.isImmediatePropagationStopped = returnFalse;

        //Handle mouse position
        if(event.clientX!=null){
            var doc = document.documentElement,body = document.body;
            event.pageX = event.clientX+(doc&amp;&amp;doc.scrollLeft||body&amp;&amp;body.scrollLeft||0)-(doc&amp;&amp;doc.clientLeft||body&amp;&amp;body.clientLeft||0);
            event.pageY = event.clientY+(doc&amp;&amp;doc.scrollTop||body&amp;&amp;body.scrollTop||0)-(doc&amp;&amp;doc.clientTop||body&amp;&amp;body.clientTop||0);
        }
        //Handle key presses
        event.which = event.charCode || event.keyCode;

        //Fix buttom for mouse clicks;
        //0==left;1==middle;2==right
        if(event.button!=null){
            event.button = (event.button&amp;1?0:(event.button&amp;4?1:(event.button&amp;2?2:0)));
        }
    }
    //返回修复后的实例
    return event;
}
</code></pre></div><p>尽管该代码非常长，但大部分代码都很简单，所以我们不打算进行逐行分析，但是会花时间指出最重要的方面。</p> <p>从本质上讲，这个函数的目的是接受一个Event实例，并检查其是否符合DOM model。如果不符合，我们就尽力让它符合。</p> <p>在函数中，首先要做的事情是定义两个函数。记住JavaScript是允许我们这么做的，它会将这两个函数的作用域限制在父函数作用域内，以便不用担心污染全局命名空间。返回true或false的这两个函数会经常在修复代码中用到，所以为了避免冗余的函数字面量，我们预先定义了这两个函数:一个始终返回true，另外一个始终返回false。</p> <p>然后，测试是否需要对event进行修复。如果event实例不存在，或者存在，但是缺少标准stropPropagation属性，那么我们就认为需要对其进行修复。</p> <p>如果确定需要对event进行修复，首先获取现有event对象的一个副本----可能是传入的event对象，也可能是全局上下文的event对象----并且将其保存在一个名为old的变量中。如果不需要修复，则忽略函数中的所有代码，并直接返回现有的event对象。</p> <p>在开始修复的时候，先创建一个空对象作为修复的event对象，然后将old事件中的所有属性都赋值到新对象上。然后继续解决W3C DOM Event对象和IE Model产生的event对象之间的差异问题、</p> <p>如下DOM Model中的一些重要属性，在该过程中进行了&quot;修复&quot;。</p> <ul><li>target----表示事件原始源的属性。在IE Model中，原始源保存在srcElement中。</li> <li>relatedTarget----事件触发时的关联元素，在IE中则是toElement和fromElement。</li> <li>preventDefault----该属性在IE Model中是不存在的，其阻止默认浏览器行为的发生。在IE中阻止默认行为的发生时,需要将returnValue属性置为false。</li> <li>stopPropagation----该属性在IE Model中也是不存在的，它的目的时进一步阻止事件冒泡。在IE中，需要将cancelBubble属性设置为true才能阻止事件冒泡。</li> <li>pageX和pageY----这两个属性在IE Model中不存在。它们提供鼠标相对于整个文档的位置，但可以很容易的从其他信息中获取。在IE中，clientX/Y提供鼠标相对于窗口的为止，而scrollTop/Left则给出了文档滚动的位置，并且clientTop/Left给出了文档的偏移量。综合这三个属性，我们可以得出最后的pageX/Y值。</li> <li>which----相当于键盘事件时所按键的键盘码。在IE Model中，可以通过charCode和keyCode属性获取到。</li> <li>button----表示鼠标事件发生时，用户单击的鼠标按键，IE Model使用了拉掩码(左单击是1，右单击是2，中间单击是4)，所以需要将其转换成DOM Model的等价值(分别是0，1，2)；</li></ul> <h3 id="处理程序的管理"><a href="#处理程序的管理" class="header-anchor">#</a> 处理程序的管理</h3> <p>由于诸多原因，不将事件处理程序直接绑定在元素上是有利的。如果我们使用一个中间事件处理程序，并将所有的处理程序保存在一个单独的对象上，我们可以最大化的控制处理过程。除此之外，我们还能够做到如下几点。</p> <ul><li>规范处理程序的上下文。</li> <li>修复Event对象的属性。</li> <li>处理垃圾回收。</li> <li>过滤触发或删除一些处理程序。</li> <li>解绑特定类型的所有事件。</li> <li>克隆事件处理程序。
我们将需要访问一个元素所绑定处理程序的完整列表以达到预期目的，从而避免直接绑定事件，并且可以自己处理这些绑定。</li></ul> <h4 id="集中存储相关信息"><a href="#集中存储相关信息" class="header-anchor">#</a> 集中存储相关信息</h4> <p>管理与DOM元素相关联的处理程序的最好方式是每个元素都指定一个唯一标识符，然后将所有相关的数据和该标识符一起保存在一个集中的对象上。虽然将信息单独保存在每个元素上似乎更自然，但是将所有的数据都保存在一个集中对象上可用避免IE浏览器的潜在内存泄漏问题，这些潜在问题在某些情况下会丢失信息。(例如，在IE中的DOM元素上绑定的函数如果在某一个元素节点上有闭包关联的话，离开页面时会导致内存回收失败。)</p> <p>实现一个重要对象用于保存DOM元素信息:</p> <p><img src="/book/1601978441667.jpg" alt=""> <img src="/book/1601978484697.jpg" alt=""></p> <p>在本例中，我们设置了两个通用函数getData()和removeData()，分别用于获取DOM元素的数据块，以及在不需要的时候删除这些数据块。</p> <p>我们需要一些变量，但又不想污染全局作用域，所以我们在一个即时函数里进行设置。这样可以将我们声明的变量都限制在即时函数的作用域内，但同时依然可以通过闭包让我们的函数进行引用。</p> <p>在即时函数内，我们声明了三个变量。</p> <ul><li>cache----保存和元素相关联的数据。</li> <li>guidCounter----一个用于生成元素GUID的计数器。</li> <li>expando----一个属性名称，我们将其作为元素的GUID进行保存。使用当前时间戳做名称可以访问与用户自定义名称有潜在的冲突。</li></ul> <p>然后，开始定义getData()方法，该函数所做的第一件事情就是获取已经赋值给元素的GUID，该GUID是在前一次调用getData()方法的时候生成的。如果该方法在该元素上第一次调用，GUID就不会存在，所以此时需要创建一个新的GUID(每次计数器都增加1)，然后使用expando属性名称其赋值给该元素。而且在cache中，我们还给该GUID创建了一个新的空对象。</p> <p>不管元素的缓存数据是否是新创建的，它都会作为函数的值返回。函数调用者可以自由的在该缓存中添加任何数据，示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>var elemData = getData(element)；
elemData.someName = 213;
elemData.someOtherName = 2058;
</code></pre></div><p>由于函数也是数据，所以我们甚至可以间接将函数和元素关联起来:<code>elemData.somFunction = function(x){/* do something */}</code> getData()函数声明之后，我们又穿喝个酒了removeData()函数，利用该函数可以删除该时间中所有不在需要的数据。</p> <p>在removeData()函数内，首先获取所传入元素的GUID，如果没有GUID，则说明该元素没有用getData()获取过数据，或者该数据已经被删除了。</p> <p>其次，可以从缓存中删除相关的数据块，并尝试删除expando。在某些情况下，也可能会失败，所以这种情况下，我们要捕获异常错误，然后在尝试从特性中删除表示expando的特性。</p> <p><img src="/book/1601979337745.jpg" alt=""></p> <p>该函数可以删除所有用getData()创建的数据:缓存的数据块以及设置在元素上的expando。</p> <p>这些代码是比较简单的，我们要确保它能用。首先创建两个<code>&lt;div&gt;</code> 元素作为测试对象，每个元素都有一个独立的title特性。获取这些元素的引用，然后进行遍历，为每个元素创建一个数据属性值给它。</p> <p>然后再次遍历这些元素，检查每个元素都有一个与之关联的数值(名称为ninja)，并且和title特性的值相同。</p> <p>最后，再次对集合进行遍历，遍历时在每个元素上都调用removeData()，并验证ninja数据已经不存在了。</p> <p>上图显示，所有这些测试都通过了。</p> <p>这些函数在处理程序管理之外可能也非常有用的。使用这些函数，我们可以在元素上附加任何数据。但是这里我们创建这些函数，是用于将事件处理信息与元素进行关联的。</p> <h4 id="管理事件处理程序"><a href="#管理事件处理程序" class="header-anchor">#</a> 管理事件处理程序</h4> <p>为了完全控制事件处理过程，我们需要创建自己的函数来包装事件的绑定和解绑操作。这样做，我们可以尽可能的在所有平台上，将事件处理模型进行统一。</p> <h4 id="绑定事件处理程序"><a href="#绑定事件处理程序" class="header-anchor">#</a> 绑定事件处理程序</h4> <p>编写一个函数来处理绑定事件，而不是直接绑定处理程序，可以让我们有机会来跟踪处理程序并且在处理流程中进行拦截操作。我们将提供一个函数，在函数内创建两个子函数，一个是作为添加处理程序(绑定)，另外一个是作为删除处理程序(解绑)，甚至还会使用一些有用的使用函数。</p> <p>一个事件处理程序并进行跟踪的函数:</p> <p><img src="/book/1601980538927.jpg" alt=""></p> <p>首先，由于需要一些本地存储(不要与HTML5的存储混淆)，我们使用一管的技巧，在一个即时函数内定义所有的东西。要保存的内容是一个表示GUID值的运行计数器，该GUID保存在变量nexGuid中。</p> <p>其次，定义addEvent()函数，该函数接受三个参数，一个是用于绑定处理程序的元素，一个是事件的类型，一个是处理程序自身。</p> <p>进入函数要做的第一件事情是，使用前面实现一个中央对象用于保存DOM元素信息代码中定义的函数，获取与该元素相关的数据，并将数据保存在data变量中，这么做有两个原因。</p> <ul><li>我们会多次引用该数据，所以将其保存在一个变量中以便将引用保存短小。</li> <li>获取数据时可能会有很大开销，所以我们只做一次获取。</li></ul> <p>由于我们想自由控制事件的绑定过程，而不是直接给元素传递处理程序，所以我们要创建自己的超级处理程序作为实际的事件处理程序。将该超级处理程序注册到浏览器，它就可以跟踪绑定的处理程序了，以便在适当的时候，我们可以执行这些事件处理程序。</p> <p>我们将该超级处理程序称之为调度器，以区别于用户传递过来进行绑定的处理程序。在函数结束之前我们会创建这个调度器，但首先必须创建存储，用于保存需要跟踪的处理程序。</p> <p>对于存储，我们将使用大量的即时创建，需要的时候在创建，而不是预分配。毕竟，如果不需要mouseover事件，我们为什么要创建一个数组来保存它呢？</p> <p>通过数据块(可以很方便的通过data变量进行获取)，我们将把处理程序与元素绑定在一起，所以这里，先判断data是否有一个名为handlers的属性，如果没有，就先创建它。该函数在之后进行调用的时候会在同一元素上检查该对象是否存在，所以该属性就不会被再次创建了。</p> <p>在该对象中，我们将创建一个数组，保存需要执行的处理程序引用，每个事件类型都创建一个数组。但是，正如我们前面所说的，我们需要根据性需要巧妙的分配它们，所以首先判断handlers对象中是否有名为type的属性，如果没有再创建它。其结果就是每个类型都对应一个数组，但只有已经有了处理程序的事件才有数组，这是资源的高效利用。</p> <p>接下来，我们要对进行调用的处理函数进行标识，所以为每个传入的函数都添加一个guid属性，并将累加计数器的值赋值给它。注意，我们会再次进行代码检查，确保每个函数都赋值一次，因为只要开发人员愿意，每个函数都可以作为处理程序被绑定多次。</p> <p>此时，我们知道已经有了一个handlers对象，该对象包含一个数组，用于跟踪所传入事件类型的多个处理程序，所以将传入的处理程序保存到数组的尾部。这几乎是该函数中的唯一操作行为，用于保证函数在调用时的执行。</p> <p>现在，可以开始编写dispatcher函数了。第一次调用即时函数时，dispatcher函数还不存在。但是我们只需要一个dispatcher函数，所以先检查它是否存在，只有不存在的时候才进行创建。</p> <p>dispatcher函数将在事件发生时触发绑定的函数，触发时首先检查是否有禁用标记disabled，如果有就终止触发操作。然后是在前面代码中创建的fiexEvent()函数，然后根据Event实例的类型，我们查找并遍历对应的处理程序，遍历的时候，调用这些处理程序，同时将元素设置为函数的上下文，并将Event对象作为唯一的参数进行传入。</p> <p>最后，判断是否为元素创建了第一个这种类型的处理程序，如果是，就在运行的浏览器中根据适当的方法，将dispatcher函数作为该类型的事件处理程序进行绑定。</p> <h5 id="提示-如果我们将该判断语句放在事件处理程序数组初始定义地方的话-就可以忽略上述判断了-我们强制这么做-主要是为了更容易的解释代码是如何工作-创建dispatcher函数之前-先创建好预先使用的所有数据构造-在生成环境代码中-移除多余的必要性检查是明智的做法。"><a href="#提示-如果我们将该判断语句放在事件处理程序数组初始定义地方的话-就可以忽略上述判断了-我们强制这么做-主要是为了更容易的解释代码是如何工作-创建dispatcher函数之前-先创建好预先使用的所有数据构造-在生成环境代码中-移除多余的必要性检查是明智的做法。" class="header-anchor">#</a> 提示:如果我们将该判断语句放在事件处理程序数组初始定义地方的话，就可以忽略上述判断了，我们强制这么做，主要是为了更容易的解释代码是如何工作(创建dispatcher函数之前，先创建好预先使用的所有数据构造)，在生成环境代码中，移除多余的必要性检查是明智的做法。</h5> <p>最后结果就是，传入的函数从来就没有成为实际的事件处理程序，相反，它们通过委托函数进行保存，并在事件发生时进行调用，真正的处理程序是委托函数。这使得我们可以有机会，确保无论在哪个平台都能做到如下事情。</p> <ul><li>Event实例被修复。</li> <li>将函数上下文设置成目标元素。</li> <li>Event实例作为唯一的参数传递给处理程序。</li> <li>事件处理程序永远按照其绑定顺序进行执行。</li></ul> <h4 id="清理资源"><a href="#清理资源" class="header-anchor">#</a> 清理资源</h4> <p>已经有一个绑定事件的方法，所以还需要一个解绑事件的方法。由于我们是使用委托处理程序来控制处理流程，而不是直接绑定处理程序，所以也不能使用浏览器提供的解绑函数来解绑事件处理程序，所以我们要提供自己的解绑方法。</p> <p>除了对处理程序进行解绑以外，还要确保小心清理对象资源。在绑定函数中，对于不必要的初始化工作，我们花了很多心思，所以如果不把这些由于解绑而变得无用的数据进行清理的话，那就太愚蠢了。</p> <p>事实证明，使用这种清理方法的地方不止一处，所以我们将清理工作放在一个单独的函数内，示例如下所示。</p> <p><img src="/book/1601987602610.jpg" alt=""></p> <p>创建一个名为tidyUp()的函数，并接受一个元素和一个事件类型作为参数。该函数将判断，在该事件类型下是否还存在任何处理程序，如果没有了，就尽可能清理并释放任何不必要的存储资源。这是一个安全的操作，因为我们在addEvent()函数中可以看到，如果再次需要这些存储资源，该函数会自动创建它。</p> <p>我们需要在几个地方，都判断一下一个对象是否还有任何属性(即是否为空)。由于在JavaScript中没有isempty操作符，所以需要编写自己的检查代码。由于我们只会在tidyUp()函数中使用这个检测函数，所以就在该函数内部定义一个isEmpty()函数，以尽量保持更近的作用域。</p> <p>首先，判断所传入事件类型关联的处理程序数组是否为空。如果为空，就不在需要了，我们可以清理掉它。此外，由于对该事件类型已经不在有任何处理程序了，所以在浏览器上针对该事件类型的委托处理程序也就没有必要了。</p> <p>既然已经删除了特性事件类型的一个处理程序数组，那么很有可能这个数组是剩余的唯一一个数组了，随着该数组的删除，handlers对象很有可能是空对象了。验证一下handlers是否为空，如果为空，也就毫无用途了，所以就可以将handlers属性进行删除了。而此时，也不在需要委托函数了，所以也可以一并删除。</p> <p>最后，测试是否由于上述的各种删除操作，使得该元素上的相关数据变得毫无意义了，如果是这样，那么也把它删除掉。</p> <h4 id="解绑事件处理程序"><a href="#解绑事件处理程序" class="header-anchor">#</a> 解绑事件处理程序</h4> <p>现在已经知道可以进行清理资源了，可以零&quot;Mr.Clean&quot;和Yoda满意了。现在可以将addEvent()函数绑定的处理程序进行解绑了。</p> <p>为了尽可能的保持灵活，该函数将为调用者提供以下功能。</p> <ul><li>将一个元素的所有绑定事件进行解绑。</li> <li>将一个元素特定类型的梭鱼事件进行解绑。</li> <li>将一个元素的特定处理程序进行解绑。</li></ul> <p>通过一个可变长度的参数列表，我们可以实现上述功能，调用者提供的信息越多，删除操作就可以越具体。</p> <p>例如，将一个元素上的所有事件绑定都删除，可以这样编写:<code>removedEvent(element)</code></p> <p>要删除一个特定类型的所有事件绑定的话，则可以这样编写:<code>removedEvent(element,&quot;click&quot;);</code></p> <p>如果要删除一个特定的处理程序实例，代码则应该这样编写:<code>removedEvent(element,&quot;click&quot;,handler);</code></p> <p>后者则假设我们维护了原有处理程序的引用。实现上出所有功能的解绑函数，代码如下:</p> <p><img src="/book/1601989190628.jpg" alt=""> <img src="/book/1601989237744.jpg" alt=""></p> <p>首先定义一个函数前面，并接收三个参数:元素，事件类型，回调函数。调用者调用的时候可以省略前面所说的参数。接下来，是获取与元素相关联的数据。</p> <p>一旦获取了数据，就检查该数据上是否包含任何处理程序，如果不包含任何处理程序，则直接返回。请注意，我们不需要检查handlers对象内部是否为空，或者其包含的列表是否为空，因为在清理处理程序代码中编写的的清理函数已经将空资源进行清理了。通过清除空数据结构和复杂的检查需要，会使该函数变得很整洁。</p> <p>如果通过了上述检查，我们知道，可能要根据事件类型来删除绑定的事件处理程序----可能是所有的事件类型(如果忽略type参数的话)，也可能是特定的事件类型(传入了type参数)。在这两种情况下，会在多个位置根据类型进行删除，所以为了避免不必要的重复代码，我们定义了一个实用函数，接收一个类型t，通过将数组替换成一个空数组，从而将该事件类型的所有处理程序全部删除，然后针对该事件类型再调用tidyUp()函数。</p> <p>有了这个函数，再继续判断type参数是否被省略了，如果被省略了，则删除该元素所有事件类型的处理程序。再本例中，删除以后直接返回,因为工作已经做完了。</p> <p>代码编写到这里，我们知道可以根据事件类型删除所有的事件处理程序，也可以删除该类型下的特定处理程序。为了减少代码量，我们获取该事件类型的处理程序列表，并将其保存再一个名为handlers的变量中。如果没有任何东西，则不用做什么，直接返回即可。</p> <p>如果fn参数被忽略了，则可以调用实用函数删除该特定事件类型的所有处理程序，并返回。</p> <p>如果上述删除操作的检查都失败了，那我们就知道了，其是需要删除传入的特定处理程序。但是，如果它不是我们曾经处理过的处理成程序，那就不需要做什么事情了，所以首先要查看guid属性是否添加到该函数上了，如果没有添加，则直接忽略执行。</p> <p>如果我们曾经处理过的处理程序，就开始遍历处理程序列表，找到该处理程序其将其删除，接着，像往常一样，返回之前需要清理资源。</p> <h4 id="冒烟测试"><a href="#冒烟测试" class="header-anchor">#</a> 冒烟测试</h4> <p>让我们对绑定函数和解绑函数做一个简单的冒烟测试。代码如下，和之前一样，通过手工交互来进行简单的冒烟测试。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;testSubject1&quot; title=&quot;Click once&quot;&gt;111111&lt;/div&gt;
&lt;div id=&quot;testSubject2&quot; title=&quot;mouse over&quot;&gt;222222&lt;/div&gt;
&lt;div id=&quot;testSubject3&quot; title=&quot;many times&quot;&gt;333333&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    addEvent(window,&quot;load&quot;,function(){
        var subjects = document.getElementsByTagName(&quot;div&quot;);
        for(var i=0;i&lt;subjects.length;i++)(function(elem){
            addEvent(elem,&quot;mouseover&quot;,function handler(e){
                this.style.backgroundColor = 'red';
            });
            addEvent(elem,&quot;click&quot;,function handler(e){
                this.style.backgroundColor = 'green';
                removeEvent(elem,&quot;click&quot;,handler);
            });
        })(subjects[i]);
        
    });

&lt;/script&gt;
</code></pre></div><p>在上述简单的测试中，我们绑定了三种不同类型的事件，并且解绑了其中一种。首先，我们为页面的load事件建立一个处理程序----然后在代码块后面定义我们的测试对象(3个<code>&lt;div&gt;</code>元素)，然后其他代码则需要再DOM加载之后才能运行。</p> <p>事件触发时，load处理程序将收集所有的<code>&lt;div&gt;</code>元素，并进行遍历。对每个元素，都做两件事。</p> <ul><li>定义一个mouseover处理程序，将元素背景设置为红色。</li> <li>定义一个click处理程序，将元素背景设置为绿色，然后将自身进行解绑，这样每个元素只能应对一次单击。</li></ul> <p>在浏览器中加载该页面，然后执行如下步骤。</p> <ul><li>将鼠标划过元素，可以看到它们都变成红色了。这说明了mouseover事件可以正常绑定并激活。</li> <li>单击其中一个元素，可以看到它变成绿色了。这说明了click事件可以正常绑定并激活。</li> <li>将鼠标划过该单价的元素，可以看到该元素又变成红色了，然后再次单击该元素。</li> <li>如果click处理程序正确的被解绑，那就不会再触发了，并且该元素依然是红色的，验证测试结果，也正是如此。</li></ul> <h3 id="事件触发-2"><a href="#事件触发-2" class="header-anchor">#</a> 事件触发</h3> <p>在正常情况下，事件触发一般会发生在这几种情况下:用户交互时，浏览器行为发生时，网络活动发生时。但有时，我们可能需要用脚本来触发事件。举例来说，可能有一个单击(click)处理程序，我们不仅想在用户单击按钮的时候触发该处理程序，而且还想在其他一些执行脚本的活动发生时也能触发它。</p> <p>一个可行的方法时将通用代码放在一个命名函数内，以便可以在任何位置进行调用。但是该解决方案也并非没有名称空间问题，而且可能会破坏代码库的明确性。此外，在通常情况下，我们要这样做的时候，不会想到调用一个函数，而是会想到模拟一个事件。所以触发一个没有&quot;真正&quot;事件的事件处理程序，是我们要给自己的一个有优势解决方案。</p> <p>在触发一个处理函数时，要确保发生如下事情。</p> <ul><li>触发绑定在该元素上的目标处理程序。</li> <li>让DOM事件进行冒泡，并触发其他的处理程序。</li> <li>触发该模板元素的默认行为(如果有的话)。</li></ul> <p>在元素上触发一个冒泡事件:</p> <p><img src="/book/1602040456116.jpg" alt=""></p> <p>triggerEvent()函数接受两个参数。</p> <ul><li>事件触发的目标元素。</li> <li>要触发的事件。</li></ul> <p>后者可以时一个事件对象或一个表示事件类型的字符串。</p> <p>要触发该事件，从事件目标元素开始遍历，一直冒泡遍历到DOM顶部，然后执行在遍历过程中找到的事件处理程序。到达document元素时，冒泡执行结束，然后，判断如果元素有针对当前事件类型的默认行为，就执行该默认行为。</p> <p>注意，在事件冒泡期间，我们要确保没有阻止冒泡传播，并且在执行默认行为之前。要检查默认行为没有被禁用。另外还要注意，我们在执行默认行为的时候禁用了事件调度器，因为我们已经执行了相关的处理程序，而不想再重复执行了。</p> <p>要触发默认的浏览器行为，需要在原始目标元素上实用合适的方法。例如，如果要触发一个focus事件，要先看看原始目标元素是否有一个.focus()方法，如果有就执行它。</p> <p>实用脚本触发事件是非常有用的。不过我们还发现，可以隐式实用自定义事件。</p> <h4 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件</h4> <p>想象这样一个场景:要执行一个行为，但是要在不同的代码条件下执行，甚至共享脚本文件中的代码。</p> <p>新手会导出重复使用代码，中级开发人员会创建一个全局函数，并在需要的地方进行调用。</p> <h4 id="松耦合"><a href="#松耦合" class="header-anchor">#</a> 松耦合</h4> <p>想象一个这样的场景，我们用共享代码来执行操作，我们想让页面代码知道什么时候对条件做出反应。如果实用全局函数，其缺点时需要为共享代码定义一个固定的函数名称，并且所有需要该共享代码的页面都需要定义这样的一个函数。</p> <p>此外，如果触发条件发生时需要做多件事件该怎么办？使用多个通知的话，会很费力并且很混乱。</p> <p>我们看到的这些缺点就是紧耦合造成的结果，其中的代码在检测条件的时候必须要知道触发事件的代码细节。</p> <p>而另一方面，松耦合在触发条件代码的时候，不需要知道任何触发事件的具体细节，或者不需要知道要做出什么反应。</p> <p>事件处理程序的优点之一是，我们想创建多少就可以创建多少，并且这些处理程序是完全独立的。所以事件处理是松耦合的一个很好例子。当一个按钮单击事件触发时，触发事件的代码不知道页面上定义了什么样的处理程序，甚至也不知道有没有定义。而浏览器只是将单击事件推送到事件队列上了，并且不管什么东西触发了事件都不会关注后续要发生什么事情。如果已经为单击事件创建了事件处理程序，它们最终将分别进行调用。</p> <p>关于松耦合有很多要说的内容。在本例场景中，当共享代码检查到一个有趣的情况时，只是会触发一个信号，&quot;这里发生了有趣的事情，任何人如果感兴趣都可以对它进行处理&quot;，并且它不会关心别人是否有兴趣。</p> <h4 id="一个ajax示例"><a href="#一个ajax示例" class="header-anchor">#</a> 一个Ajax示例</h4> <p>假设我们编写了一些共享代码用于执行一个Ajax请求。页面上的代码，希望在执行Ajax开始或结束时得到通知。在这些&quot;事件&quot;发生时，每个页面都要处理自己的事情。</p> <p>例如，在一个页面上使用该代码包，在Ajax请求开始时，我们要显示一个转轮的GIF动画，并且在请求结束时将动画进行隐藏，以便在请求处理时给用户一些视觉反馈。</p> <p>如果将开始条件作为一个事件命名为ajax-start，并将停止条件也作为一个事件命名为ajax-complete，那我们岂不是就可以在页面上简单的这些事件创建事件处理程序了吗？并且可以在恰当的时候用这些处理程序显示和隐藏图像。</p> <p>思考如下代码:</p> <div class="language- extra-class"><pre class="language-text"><code>var body = document.getElementsByTagName('body')[0];
addEvent(body,'ajax-start',function(e){
    document.getElementById('whirlyThing').style.display = 'inline-block';
});

addEvent(body,'ajax-complete',function(e){
    document.getElementById('whirlyThing').style.display = 'none';
});
</code></pre></div><p>只不过很遗憾，这些事件并不存在。</p> <p>但是我们开发过添加事件处理程序以及模拟触发事件程序的代码，所以我们可以使用这些代码来模拟自定义事件，而不需要依赖浏览器来理解我们的自定义事件类型。</p> <h4 id="触发自定义事件"><a href="#触发自定义事件" class="header-anchor">#</a> 触发自定义事件</h4> <p>自定义事件是模拟真实事件的体验，而无需得到浏览器底层事件的支持。我们已经做了一些工作来支持跨浏览器事件，并支持了一些我们自己已经实现了的自定义事件！</p> <p>在已经编写的addEvent(),removeEvent()及triggerEvent()中，我们不需要在代码上做什么修改就可以支持自定义事件。从功能上来说，自定义事件和浏览器触发的真正浏览器事件没有区别，并且自定义事件并不真正存在，只有手动触发时才触发事件。</p> <p>如下代码清单，是一个触发自定义事件的示例。</p> <p><img src="/book/1602042270528.jpg" alt=""> <img src="/book/1602042277012.jpg" alt=""></p> <p>在上述手动测试中，我们大概的检查了一下自定义事件:在一个Ajax操作期间，动态滚轮图片需要显示。该操作是通过单击一个按钮来触发的。</p> <p>以完全解耦的方式，为名为ajax-start的自定义事件创建一个处理程序，同样也为ajax-complete自定义事件创建一个处理程序。这些事件处理程序会分别显示和隐藏滚轮图片。</p> <p>注意，三个处理程序不知道彼此的存在。特别是，按钮单击处理程序并没有对图片的显示和隐藏进行负责。</p> <p>Ajax操作本身的代码是通过如下代码进行模拟的:</p> <div class="language- extra-class"><pre class="language-text"><code>function performAjaxOperation(target){
    triggerEvent(target,'ajax-start');

    window.setTimeout(function(){
        triggerEvent(target,'ajax-complete')
    },5000);
}
</code></pre></div><p>该函数触发了ajax-start事件，然后假装一个Ajax请求。让按钮作为事件的初始目标是任意的。</p> <p>由于处理程序是建立在body上的，所有事件最终都将冒泡到这个地方，所以处理程序最终将会被触发。</p> <p>接着该函数执行了一个5秒的定时器函数，来模拟一个持续5秒钟的Ajax请求。在定时器到期时，我们假装已经返回了响应，并触发一个ajax-complete事件表示Ajax操作已完成了。</p> <p>注意这个例子中的高度解耦。共享的Ajax操作代码，不知道页面代码在事件触发时要做的事情，甚至也不知道是否有触发事件的代码。页面代码被模块化成很小的处理程序，而互相不了解对方。此外，页面代码也不知道共享代码是如何做事的，它只对可能触发，也可能不会触发的事件做出响应。</p> <p>这种程度的解耦有助于保持代码模块化，易编写，并且在出错时容易调试。它也容易进行代码共享，以及可以随便移动代码，而不用担心违反代码片段之间的耦合依赖关系。在代码中实用自定义事件时，解耦是一个基本的优势，而且它可以让我们以更加富有表现力且灵活的方式来开发应用程序。</p> <h3 id="冒泡与委托"><a href="#冒泡与委托" class="header-anchor">#</a> 冒泡与委托</h3> <p>简单的说，委托是表示在DOM上层定义事件处理程序，而不是在触发事件的元素本身上定义。</p> <p>回想一下，即使我们要用自定义事件触发的图像，是定义一个DOM元素中，我们绑定处理程序的时候却是在body元素上绑定的，这样也可以操作图像的显示与隐藏。这是一个将图像元素委托给祖先元素的委托例子，在本例中，委托的祖先元素是body元素。</p> <p>但仅限与自定义标签，甚至是body元素。让我们想象一个实用更多事件类型和元素的场景。</p> <h4 id="将事件委托给祖先元素"><a href="#将事件委托给祖先元素" class="header-anchor">#</a> 将事件委托给祖先元素</h4> <p>假设一个表格在初始化加载的时候，所有的单元格都是白色背景，我们很想直观的表明，表格中的哪个单元格在用户交互的时候被单击了。听起来貌似很容易。我们可以遍历所有的单元格，并为每个单元格创建一个处理程序，用于改变当前单元格的背景色属性:</p> <div class="language- extra-class"><pre class="language-text"><code>var cells = document.getElementsByTagName('td');
for(var n=0;n&lt;cells.length;n++){
    addEvent(cells[n],'click',function(){
        this.style.backgroundColor = 'yellow';
    });
}
</code></pre></div><p>这样肯定能用，但代码优雅吗？不是很优雅。我们可能会在上百个元素上创建一样的事件处理程序，而且这些处理程序做的都是相同的事情。</p> <p>有一个更优雅的方式是，在单元格更高一层的元素上创建一个单一的处理程序，这样就可以使用浏览器提供的事件冒泡来处理所有的单元格单击事件。我们知道所有的单元格都是封装在表格元素里的，而且还知道一个元素被单击的时候可以通过event.target获取该元素引用。这样就可以像如下代码这样，温和的将事件处理委托给表格元素了:</p> <div class="language- extra-class"><pre class="language-text"><code>var table = document.getElementById('#someTable');
addEvent(table,'click',function(event){
    if(event.target.tagName.toLowerCase()=='id'){
        event.target.style.backgroundColor = 'yellow';
    }
});
</code></pre></div><p>在这段代码中，我们创建了一个处理程序，用于处理表格中的单元格在单击后的背景色。这种方式更加高效和优雅。</p> <p>事件委托是一种开发更高性能，且可伸缩Web应用程序的最好技术。</p> <p>因为事件冒泡是唯一一种在所有浏览器中都可以使用的技术，所以重要的是要确保将委托应用到事件目标元素的祖先元素上。这样，才能确信最终冒泡到所委托的元素上。</p> <h4 id="修复浏览器的不足"><a href="#修复浏览器的不足" class="header-anchor">#</a> 修复浏览器的不足</h4> <p>可惜的是，在很多浏览器中，submit，change,focus以及blur事件的冒泡实现都有很严重的问题。如果我们使用事件委托----我们必须解决如何客服这些缺陷问题。</p> <p>在老版本的IE浏览器中，submit和change事件根本没有冒泡，而兼容W3C DOM的浏览器对两个事件都一致的实现了冒泡。我们可以使用一种技术很优雅的判断该问题是否存在以及是否需要处理。当前这种情况，我们需要判断一个事件是否可以冒泡至父元素。</p> <p><img src="/book/1602056097523.jpg" alt=""></p> <p>该冒泡监测技术是通过在<code>&lt;div&gt;</code>元素上检查是否已经存在ontype(这里的type是事件类型)属性来判断。这里使用<code>&lt;div&gt;</code>元素，是因为通常各种各样的事件都可以冒泡到这种类型的元素上(包括change和submit)。</p> <p>我们不能指望页面上已经存在的<code>&lt;div&gt;</code>元素----即便可以，我们也可以不能指染别人的元素----所以我们创建了一个临时元素来检测。</p> <p>如果这个快速而简单的测试未通过，还可以尝试更多的侵入式检测。如果ontype属性不存在，就创建一个ontype特性并给它一点代码，然后在判断该元素是否可用将其转换成一个函数。如果可以转换成一个函数，则可以很好的说明该元素知道如何解释冒泡事件。</p> <h4 id="冒泡submit事件"><a href="#冒泡submit事件" class="header-anchor">#</a> 冒泡submit事件</h4> <p>submit事件是老版IE浏览器中为数不多的不支持冒泡的几个事件之一，但值得庆幸的是，这也是最容易模拟的一个事件。</p> <p>submit事件可以通过如下方法进行触发。</p> <ul><li>触发type=submit的input元素或button元素，或者触发type=image的图像元素。这些元素可以通过单击触发，或者在有焦点时通过回车键或空格键进行触发。</li> <li>在文本或密码输入框里，按回车键进行触发。</li></ul> <p>知道了这两种触发场景，我们可以获取click和keypress两个触发事件，通常这两个事件都可以正常冒泡。</p> <p>我们才去的方式是，通过创建特殊的函数来绑定和解绑submit事件。如果确定是因为浏览器缺乏支持而需要对submit事件进行特殊处理的话，我们就会创建一个借道处理程序，如果不需要特殊处理，则可以用普通的方式对处理程序进行绑定和解绑。</p> <p><img src="/book/1602057232261.jpg" alt=""> <img src="/book/1602057144331.jpg" alt=""></p> <p>首先，使用现在应该很熟悉的即时函数技术，为代码创建一个独立的环境。在为submit事件添加特殊支持之前，我们需要预先定义一些稍后要用到的东西。</p> <p>其次，由于需要在几个地方判断一个元素是否在表单内，所以我们定义一个名为isInForm()的函数来判断。该函数只是遍历元素的祖先树，并判断其中一个祖先是否是form元素。</p> <p>然后我们定义两个即将要用作事件处理程序的函数:一个用于click，一个用于keypress。第一个函数判断如果目标在表单内并且有submit语义(type为submit，或者是一个input图像元素)，就触发一个submit事件。第二个函数判断如果按键是回车键，目标元素在表单内，并且是一个文本输入框或密码输入框时，就触发一个submit事件。</p> <p>定义了这些辅助函数后，就可以开始编写绑定和解绑函数了。</p> <p>addSubmit()绑定函数，首先以正常方式用addEvent()函数创建一个submit处理程序，并判断如果浏览器已经支持submit冒泡的话，就直接返回不在继续执行了，如果不支持冒泡，则确保我们绑定的不是一个form元素(form元素是没有冒泡问题的)，并且查看是否是第一个submit处理程序，如果都成立，则说明支持submit冒泡的，然后就可以为click和keypress创建相应的借道处理程序了。</p> <p>removeSubmit()解绑函数的工作方式类似。正常解绑submit事件，并判断浏览器是否支持submit冒泡。如果不支持，在目标元素不是form并且该处理程序是最后一个要解绑的submit处理程序时，就解绑该借道处理程序。</p> <h4 id="冒泡change事件"><a href="#冒泡change事件" class="header-anchor">#</a> 冒泡change事件</h4> <p>change事件是另外一个旧版IE浏览器不支持冒泡的事件。可惜的是，change的冒泡实现明显比submit事件难很多。要实现可冒泡的change事件，我们必须绑定不同的事件。</p> <ul><li>focusout事件用于检查表单元素失去焦点之后的值。</li> <li>click和keydown事件用于检查元素值的瞬时改变。</li> <li>beforeactivate事件获取一个元素被替换之前的旧值。</li></ul> <p>如下代码，展示了一些特殊函数的实现，这些函数通过借道上述事件，可以对change处理程序进行绑定和解绑。</p> <p><img src="/book/1602057960894.jpg" alt=""> <img src="/book/1602058059380.jpg" alt=""> <img src="/book/1602058145507.jpg" alt=""> <img src="/book/1602058366866.jpg" alt=""></p> <p>getVal()方法返回所传入元素状态的序列化版本数据。在beforeactivate事件发生时，该返回值将保存元素data对象的_change_data属性上，供以后使用。</p> <p>triggerChanged()函数用于确定前面保存的_change_data值和新设置的值是否发生了真正的变化，如果两个值不同就触发change事件。</p> <p>除了检查focusout(blur)发生时元素值是否发生了变化以外，还要判断是否非textarea元素上按了回车键，或者是否checkbox和radio按钮上按了空格键。还要判断在复选框(check box),单选按钮(radio button)，下拉元素上是否发生了单击事件，因为这些事件也会触发change事件。</p> <h4 id="实现focusin和focusout事件"><a href="#实现focusin和focusout事件" class="header-anchor">#</a> 实现focusin和focusout事件</h4> <p>focusin和focusout事件是IE浏览器引入的专有事件，用于检查标准focus或blur事件，在元素或元素的子元素上是合适发生的。这些事件发生在focus和blur发生之前，使得它们的功能相当于捕获事件而不是冒泡事件。</p> <p>这些非标准事件值得我们考虑的原因是因为focus和blur事件没有冒泡功能，由于W3C DOM的建议所有浏览器都实现了它。最终来看，与尝试绕过浏览器标准让事件获取冒泡功能相比，在跨浏览器上实现focusin和focusout的克隆功能要更容易。</p> <p>实现focusin和focusout事件的最好办法是修改现有addEvent()函数，在内部对这些事件类型进行处理，示例如下:</p> <div class="language- extra-class"><pre class="language-text"><code>if(document.addEventListener){
    elem.addEventListener(
        type==='focusin'?'focus':type==='focusout'?'blur':type,
        data.handler,
        type==='focusin'||type=='focusout';
    )
}else if(document.attachEvent){
    elem.attachEvent('on'+type,data.handler);
}
</code></pre></div><p>然后，修改removeEvent()函数，相应的在解绑事件:</p> <div class="language- extra-class"><pre class="language-text"><code>if(document.addEventListener){
    elem.removeEventListener(
        type==='focusin'?'focus':type==='focusout'?'blur':type,
        data.handler,
        type==='focusin'||type=='focusout';
    )
}else if(document.attachEvent){
    elem.attachEvent('on'+type,data.handler);
}
</code></pre></div><p>最终的结果是所有的浏览器都支持了非标准的focusin和focusout事件。当然，我们也可能希望在addEvent和removeEvent中保持特定事件逻辑的分离。在这种情况下，我们可以以某种形式的可扩展性，覆盖浏览器针对特性事件类型提供的原始绑定机制和解绑机制。</p> <h4 id="实现mouseenter和mouseleave事件"><a href="#实现mouseenter和mouseleave事件" class="header-anchor">#</a> 实现mouseenter和mouseleave事件</h4> <p>mouseenter和mouseleave事件是IE浏览器引入的另外两个自定义事件，用于简化确定鼠标的当前位置何时处于一个元素的内部或外部的过程。</p> <p>通常我们会与浏览器提供的标准mouseenter和mouseleave事件进行交互，但通常它们并没有真正提供我们所要的东西。问题是，鼠标在父元素内的子元素直接进行移动时会触发该事件。这是典型的事件冒泡模型，但在实现菜单或其他交互元素时则会经常出问题，因为我们关心的是我们仍然在该元素内，我们不行因为只是进入子元素就被任何离开了该元素。</p> <p><img src="/book/1602061188969.jpg" alt=""></p> <p>上图说了这个问题。</p> <p>当鼠标光标从父元素移动到子元素边界时，会触发一个mouseout事件，即便我们可能认为光标依然在父元素的边界被。同样离开子元素时，会触发一个mouseover事件。</p> <p>这种情况下，使用Mouseenter和mouseleave事件是非常方便的。它们只会在绑定的主要元素上触发，只有在真正离开父元素的时候才告诉我们已经离开了。由于目前只有IE浏览器实现了这些有用的事件，所以我们对其它浏览器也需要模拟完整的事件交互。</p> <p>在上图中，展示了一个名为hover()的函数实现，该函数使得mouseenter和mouseleave事件可用于所有的浏览器。</p> <p><img src="/book/1602061449999.jpg" alt=""> <img src="/book/1602061501427.jpg" alt=""></p> <p>处理mouseenter和mouseleave事件的大部分灵感是来自withinElement()函数，在不支持这些非标准事件的浏览器中，该函数是作为mouseover和mouseout事件的处理程序来定义的。该函数检查事件的relatedTarget，也就是mouseout事件发生时要进入的元素或者mouseover事件发生时要离开的元素。在这两种情况下，如果该相关元素在悬停元素内，就忽略它，否则，该元素就是要离开或进入的悬停元素，那么就触发处理程序。</p> <h3 id="文档就绪事件-document-ready"><a href="#文档就绪事件-document-ready" class="header-anchor">#</a> 文档就绪事件(document ready)</h3> <p>我们最后要考虑的事件，称之为&quot;就绪(ready)&quot;事件。在W3C DOM兼容性浏览器中时作为DOMContentLoaded来实现的。</p> <p>该就绪(ready)事件是在整个DOM文档加载完毕后触发，表明可以遍历和操作DOM文档了。该事件已经成为很多现代框架的一个组成部分，运行对代码进行非侵入式的分层。它在页面显示之前执行，并且不需要等待其他资源的加载----资源加载会延迟load事件的触发。</p> <p>在跨浏览器中使用该事件，避免不了需要再做一次支持旧版本IE(IE9之前的版本)的工作。</p> <p>在DOM就绪时，W3C浏览器很容易引发DOmContentLoaded事件，但对于旧版本IE浏览器，在DOM就绪时，我们需要依赖一个多管齐下的方式，以便尽快得到通知。</p> <p>其中一个技巧时使用Diego Perini创建的一种方法，地址:http://javascript.nwbox.com/IEContentLoaded/,我们尝试将文档滚动到最左边。该尝试会一致失败，一直到DOM加载完为止，所以如果我们不断尝试执行该操作(使用一个定时器，确保不阻止事件循环)，在操作成功时，我们就会知道DOM已经就绪了。</p> <p>在旧版IE上使用的第二个技巧是，在文档上监听onreadystatechange事件。这个特定事件与doScroll技巧不太一致----DOm就绪时，该事件会一直触发，但有事它会触发很长一段时间。即便如此，它也是IE的一个很好的备份，至少确保在load事件触发之前发生了一点事情。</p> <p>第三中技巧时检查document.readyState属性。该属性可在所有的浏览器中使用，用于记录当时的DOM加载状态。我们要知道什么时候到了&quot;complete&quot;状态。加载的时候有很长的延迟，尤其是在IE浏览器中，readyState有可能会过早的报告成&quot;complete&quot;状态，这就是为什么不能完全依赖它的原因。但是文档加载时检查该属性，可以帮我们在DOM达到就绪状态时避免不必要的事件绑定。</p> <p>实现跨浏览器的DOMredy事件:</p> <p><img src="/book/1602062372612.jpg" alt=""> <img src="/book/1602062418912.jpg" alt=""></p> <h2 id="dom操作"><a href="#dom操作" class="header-anchor">#</a> DOM操作</h2> <h3 id="像dom中注入html"><a href="#像dom中注入html" class="header-anchor">#</a> 像DOM中注入HTML</h3> <p>首先看一些向文档中任意位置注入HTML的有效方式，注入的HTML是字符串形式。我们研究这个特殊技术，是因为很多地方都会经常用到它。</p> <ul><li>向页面注入任意HTML，并操作和插入客户端模板。</li> <li>检索服务端发送的HTML，并进行注入。</li></ul> <p>要正确的实现该功能，在技术上却是有一定的挑战，尤其是与面向对象风格的DOM构建API相比的时候(面向对象风格的确更容易实现，但它需要一个额外的抽象层，而不是通过注入HTML来实现)。</p> <p>已经有一个可以注入任意HTML字符串的API方法了，该API由IE浏览器提供，并且现在已经是W3C HTML5规范的一部分了。该方法存在于所有的HTML DOM元素上，其名称为insertAdjacentHTML()。</p> <p>问题是我们不能依赖于该API来支持所有的浏览器。尽管该方法在所有现代浏览器中都有广泛使用，是大多数浏览器最近补充的功能，但很有可能支持矩阵的一些旧版浏览器不支持该方法。即便旧版IE令人难以置信的实现了该功能，但也只能在所有可用元素的一个子集上使用。</p> <p>即使我们大方的支持了最新最好的浏览器版本，了解HTML注入的原理，也是JavaScript忍者应该掌握的一种技能。</p> <p>基于这些原因，我们要从头开始实现一个干净的DOM操作API。实现将包括很多步骤。</p> <ul><li>将任意一个有效的HTML。XHTML字符串转换成DOM结构。</li> <li>尽可能有效的将该DOM结构注入到DOM中的任意位置。</li> <li>执行源字符串中的内联脚本。</li></ul> <p>将这三个步骤综合在一起，就可以给页面开发人员提供一个注入HTML的只能API了。</p> <h4 id="将html转换成dom"><a href="#将html转换成dom" class="header-anchor">#</a> 将HTML转换成DOM</h4> <p>将HTML字符串转换成DOM结构不会涉及太多的魔法知识。事实上，它使用的是一个我们可能已经非常熟悉的工具方法:DOM元素的innerHTML属性。</p> <p>innerHTML属性的使用是一个多步骤的过程。</p> <ul><li>确保HTML字符串包含有效的HTML/XHTML(或者可以友好的调整它，以便更接近于有效)。</li> <li>根据浏览器规则，将所需字符串包装在任意封闭标签内。</li> <li>使用innerHTML，将HTML字符串插入到一个虚拟DOM元素中。</li> <li>提取该DOM节点。</li></ul> <h4 id="预处理xhtml-html源字符串"><a href="#预处理xhtml-html源字符串" class="header-anchor">#</a> 预处理XHTML/HTML源字符串</h4> <p>首先，需要清理HTML源来满足我们的需求。清理的具体内容取决于产品需求和上下文，例如，要构建jQuery库的话，支持XML风格的自关闭元素是很重要的，如<code>&lt;table/&gt;</code>。</p> <p>只有HTML元素的一小部分元素才能应用自关闭元素，尝试在其他情况下使用该语法，会在IE这样的浏览器中导致问题出现。</p> <p>其次，我们可以对HTML字符串做一个快速的预解析，将<code>&lt;table/&gt;</code>这样的元素转换为<code>&lt;table&gt;&lt;table/&gt;</code>(这样在所有浏览器中都能一致处理了)，如图所示:</p> <p><img src="/book/1602082491973.jpg" alt=""></p> <h4 id="html包装"><a href="#html包装" class="header-anchor">#</a> HTML包装</h4> <p>现在已经有了转换后的HTML字符串了，但在注入页面之前还有一个步骤需要做。有些HTML元素在被注入之前，必须存放在特定的容器元素中。例如，<code>&lt;option&gt;</code>元素必须放在<code>&lt;select&gt;</code>中。</p> <p>有两种方法可以解决这个问题，这两种方法都需要构建一个问题元素及其容器元素的映射。</p> <ul><li>方法1：如果某些特定父元素之前是使用createElement构建，是可以使用innerHTML将字符串注入到该特定父元素中的，虽然某些情况下，在有些浏览器上能用，但不能全部保障能用。</li> <li>方法2:字符串需要使用合适的标签进行包装，然后再直接注入到其他容器元素中(如<code>&lt;div&gt;</code>)，这是很简单的，但还有更多的工作需要做。</li></ul> <p>第二种方法是优先使用的，与第一种方法相比，它涉及很少的浏览器特定代码，而第一种方法则需要大量的浏览器特定代码。</p> <p>幸运的是，需要使用特定；容器元素进行包装的问题元素只有七个。如下列表中，省略号(...)表示的是元素需要注入的地方:</p> <ul><li><code>&lt;option&gt;</code>和<code>&lt;optgroup&gt;</code>需要包含在<code>&lt;select multiple=&quot;multiple&quot;&gt;...&lt;/select&gt;</code>里。</li> <li><code>&lt;legend&gt;</code>需要包含在<code>&lt;fieldset&gt;...&lt;/fieldset&gt;</code>里。</li> <li><code>&lt;thead&gt;,&lt;tbody&gt;,&lt;tfoot&gt;,&lt;colgroup&gt;</code>以及<code>&lt;caption&gt;</code>需要包含在<code>&lt;table&gt;...&lt;/table&gt;</code>里。</li> <li><code>&lt;tr&gt;</code>需要包含在<code>&lt;table&gt;&lt;thead&gt;...&lt;/thead&gt;&lt;/table&gt;,&lt;table&gt;&lt;tbody&gt;...&lt;/tbody&gt;&lt;/table&gt;</code>或者<code>&lt;table&gt;&lt;tfoot&gt;...&lt;/tfoot&gt;&lt;/table&gt;</code>里。</li> <li><code>&lt;td&gt;</code>和<code>&lt;th&gt;</code>需要包含在<code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;...&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</code>里。</li> <li><code>&lt;col&gt;</code>必须包含在<code>&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;...&lt;/colgroup&gt;&lt;/table&gt;</code>里。</li> <li><code>&lt;link&gt;</code>和<code>&lt;script&gt;</code>需要包含在<code>&lt;div&gt;&lt;/div&gt;&lt;div&gt;...&lt;/div&gt;</code>里。</li></ul> <p>除了一下几点需要做一点解释之外，其他几乎都很简单:</p> <ul><li>使用multiple特性的<code>&lt;select&gt;</code>元素(相对的是非多选下拉框)，不会自动检查放在其中的选项(而单选下拉框会默认选择第一个选项)。</li> <li><code>&lt;col&gt;</code>需要一个额外的<code>&lt;tbody&gt;</code>进行修复，如果没有的话，<code>&lt;colgroup&gt;</code>无法正常生成。</li> <li><code>&lt;link&gt;和&lt;script&gt;</code>的修复很怪异:IE浏览器无法通过innerHTML生成<code>&lt;link&gt;和&lt;script&gt;</code>元素，除非将它们包含在另外一个节点中，并且还得有一个相邻节点。</li></ul> <h4 id="生成dom"><a href="#生成dom" class="header-anchor">#</a> 生成DOM</h4> <p>将一些标签生成一个DOM节点列表：</p> <p><img src="/book/1602083701125.jpg" alt=""> <img src="/book/1602083754105.jpg" alt=""></p> <p>在IE浏览器中，有两个bug需要在返回节点之前进行处理。第一，IE会在所有的空表格上添加一个<code>&lt;tbody&gt;</code>元素:要检查是否需要空表格，并删除所有的子节点作为充分修复。第二，IE会将传入innerHTML的字符串的前后空白都去除，并且通常在浏览器渲染文档的时候也不考虑空白。其验证方式是，检查生成的第一个节点是否是文本节点并且也包含了前导空白，如果不是，则显式创建一个新文本节点，并将空白填充进去。</p> <h4 id="将dom插入到文档中"><a href="#将dom插入到文档中" class="header-anchor">#</a> 将DOM插入到文档中</h4> <p>一旦生成了DOM节点，就可以将其插入到文档中了。</p> <p>我们有一个需要插入的元素数组----可能是文档中的任意地方----我们尝试将插入操作步骤减少到最少。</p> <p>我们可以使用DOM片段进行插入。DOM片段是W3C DOM规范的一部分，并且所有的浏览器都支持。这个有用的工具给我们提供了一个容器，可以存储DOM节点集合。</p> <p>这种方式本身是非常有用的，但它还有一个优点，那就是DOM片段可以一次性注入和克隆DOM节点集合，而不必在注入和克隆的时候，一次又一次的遍历操作。着有可能大大减少页面所需的操作次数。</p> <p>在上一个代码中使用的getNodes()代码，并进行调整，以有效利用DOM片段。代码调整很小，只是在参数列表中添加一个fragment参数，示例如下:<code>function getNodes(htmlString,doc,fragment){</code>如果传入了fragment参数，则期望将新节点注入到该fragment参数对应的DOM片段中，以便供以后使用。</p> <p>为此，在函数返回语句之前，我们简单添加fragment的判断，并将新节点添加到该fragment中:</p> <div class="language- extra-class"><pre class="language-text"><code>if(fragment){
    while(div.firstChild){
        fragment.appendChild(div.firstChild);
    }
}
</code></pre></div><p>现在，让我们来看看它的用法。</p> <p>在如下代码中，来自于jQuery，假设更新后的getNodes()函数也在作用域内，创建一个DOM片段并将其传递给该函数(可能你还记得，需要将传入的HTML转换为DOM元素)。此时，DOM已经附加到fragment上了。</p> <p>在DOM中的多个位置上插入DOM片段:</p> <p><img src="/book/1602084659321.jpg" alt=""></p> <p>还有重要的一点:如果我们将该元素插入到文档中的多个位置，我们需要一遍又一遍的对片段进行克隆。如果不使用片段，则每次都需要克隆所有的节点，而不是整个片段。</p> <p>还有最后一点需要注意，虽然这一点相对比较次要。在页面开发人员尝试将一个表格行直接注入到表格元素中时，通常是指，直接将表格行插入到表格的<code>&lt;tbody&gt;</code>中。可以编写一个简单的映射函数来对应这些问题。</p> <p>找出元素的插入点:</p> <div class="language- extra-class"><pre class="language-text"><code>function root(elem,cur){
    return elem.nodeName.toLowerCase() === &quot;table&quot;&amp;&amp;cur.nodeName.toLowerCase() === &quot;tr&quot;?
    (elem.getElementsByTagName(&quot;tbody&quot;)[0]||elem.appendChild(elem.ownerDocument.createElement(&quot;tbody&quot;))):elem;
}
</code></pre></div><h4 id="脚本执行"><a href="#脚本执行" class="header-anchor">#</a> 脚本执行</h4> <p>除了将结构化的HTML插入到文档中外，HTML片段中的内敛脚本元素的执行也是一个常见的需求。这种情况常见于，通过Ajax从服务器端获取HTML片段并执行该HTML片段内部的脚本。</p> <p>通常处理内联脚本的最好方法是，在DOM结构插入到文档中之前，将内敛脚本提取除了。在HTML字符串转换成DOM节点的函数内，我们可以使用类似如下这样的jQuery的代码。</p> <p><img src="/book/1602085224818.jpg" alt=""></p> <p>上述代码清单中的代码处理了两个数组:ret，用于保存生成的所有DOM节点，以及scripts，以文档顺序保存从片段里提取出来的脚本元素。此外代码只负责删除能够正常作为JavaScript进行执行的脚本(有隐式type，或type=text/javaScript的脚本)。接着，在DOM结构插入文档以后，代码就执行scripts中的内容。这更像是拖动着步子前行，而不只是应付复杂的代码，但它确实让我们看到了其中的巧妙部分。</p> <h4 id="全局上下文中的代码求值"><a href="#全局上下文中的代码求值" class="header-anchor">#</a> 全局上下文中的代码求值</h4> <p>内联脚本执行时，其期望在全局上下文内进行求值。这意味着，如果定义了一个变量，那么该变量就会成为全局变量，这也同样适用于其他函数。</p> <p>代码求值的标准方法参差不齐。在全局作用域内，能够跨浏览器执行代码的简单明了方式是创建一个新的脚本元素，然后从文档中快速注入并删除代码。</p> <p>如下代码，展示了jQuery中的一部分全局求值代码。</p> <p><img src="/book/1602086776983.jpg" alt=""></p> <p>使用这种方法，可以很容易才用一种通用方法对脚本元素进行求值。我们甚至可以在脚本中添加一些简单代码来实现动态加载并求值</p> <div class="language- extra-class"><pre class="language-text"><code>function evalScript(elem){
    if(elem.src){
        jQuery.ajax({
            url:elem.src,
            async:false,
            dataType:'script'
        })
    }else{
        jQuery.globalEval(elem.text||'');
    }
    if(elem.parentNode){
        elem.parentNode.removeChild(elem);
    }
}
</code></pre></div><p>对脚本求值以后，将脚本从DOM中删除。我们之前也做了同样的事情，那就是在脚本元素注入之前将其从片段中删除。之所以这样做，是因为要保证脚本不会再次意外执行。</p> <h3 id="克隆元素"><a href="#克隆元素" class="header-anchor">#</a> 克隆元素</h3> <p>在所有的浏览器中克隆一个元素(使用cloneNode DOM方法)都很简单，但旧版本IE除外。同时进行克隆时，旧版本IE产生让人伤脑筋的行为，会导致产生非常令人沮丧的克隆结果。</p> <p>首先，在克隆一个元素时，IE会将所有的事件都复制到克隆元素上。此外，元素上的自定义特性也都带过去了。在jQuery中，使用如下代码简单测试是否有这种情况。</p> <div class="language- extra-class"><pre class="language-text"><code>var div = document.createElement(&quot;div&quot;);
if(div.attachEvent&amp;&amp;div.fireEvent){
    div.attachEvent(&quot;onclick&quot;,function(){
        jQuery.support.noCloneEvent = false;
        div.detachEvent(&quot;onclick&quot;,arguments.callee);
    });
    div.cloneNode(true).fireEvent(&quot;onclick&quot;);
}
</code></pre></div><p>其次，阻止这种行为的明显方式是，删除克隆元素上的所有事件。但是在IE中，如果想从克隆元素中删除事件处理程序，原有元素上的事件处理程序也会被删除。</p> <p>同样，尝试删除克隆元素的自定义属性，也会同步删除原始元素的这些属性。</p> <p>最终解决方案也许就是先克隆元素，将其注入到另一个元素中，然后读取该元素的innerHTML，在将其转换回DOM节点。这是一个多步骤的过程，但它会产生一个无污染的克隆元素。还有一个IE bug:元素的innerHTML内容并不总是能反映元素特性的正确状态。一个常见的例子是，在动态改变input元素的name特性时，新改变的值不会在innerHTML中有表示。</p> <p>该解决方案还有另外一个说明:XML DOM元素并不存在innerHTML，所以我们要被迫使用传统的cloneNode调用(但幸好XML DOM元素还具有稀有的事件监听器)。</p> <p>用于IE浏览器最终解决方案是相当迂回的方法。它并没有使用简便的cloneNode调用，而是首先通过innerHTML进行序列化，然后将其转换为DOM节点，然后对任何携带u过啦跌特性进行修复。要修复多少特性取决于我们自己。</p> <p>jQuery中元素克隆功能的部分代码:</p> <p><img src="/book/1602121628257.jpg" alt=""></p> <p>注意，上述代码使用了jQuery的jQuery.clean方法，就像前面所讨论的，它会将一个HTML字符串转换成一个DOM结构。</p> <h3 id="删除元素"><a href="#删除元素" class="header-anchor">#</a> 删除元素</h3> <p>从DOM中删除一个元素应该是很简单的吧(快速调用removeChild())，当然不是了。将一个元素从COM中删除之前，我们必须做很多初步的清理工作。</p> <p>在DOM元素从DOM中删除之前，通常要做两步清理工作。</p> <p>首先要清理的是事件处理程序，可以通过将其从元素上删除来实现。如果一个框架涉及良好的话，一个元素在同一事件只能绑定一个处理程序，所以这个清理工作不应比删除一个函数更难了。在前面我们建立的事件管理框架。这一步非常重要，因为对引用了其他DOM元素的处理程序来说，IE有内存泄漏问题。</p> <p>第二步要清理的是与元素相关的外部数据。一个框架需要一个好的方式将数据与元素关联起来，而无需直接在扩展属性上附加数据。清理这些数据是一个好注意，主要是为了避免消耗太多的内存。</p> <p>这两点都需要在被删除的元素上完成才行，同样所有的后代元素也必须完成这两点，因为所有的后代元素也会被删除。</p> <p>如下代码，显示了jQuery中的相关代码。</p> <p>jQuery中的元素删除函数:</p> <div class="language- extra-class"><pre class="language-text"><code>function remove(){
    //遍历要删除的元素以及所有子元素
    jQuery(&quot;*&quot;,this).add([this]).each(function(){
        //删除所有的绑定元素
        jQuery.event.remove(this);
        //删除附加的数据
        jQuery.removeData(this);
    });
    //如果在DOM中，就将其删除
    if(this.parentNode){
        this.parentNode.removeChild(this);
    }
}
</code></pre></div><p>所有清理工作都完成之后，下一件考虑的事情是元素在DOM中的实际删除。大多数浏览器都可以完美的将元素从页面中删除(除了前面所说的IE)。</p> <p>在IE中，删除元素的时候，如果不能将该元素使用的内存全部回收，删除操作就会失败。这就意味着，长时间运行的页面，在删除元素时会发行，随着时间的推移，这些元素在IE中会使用更多的内存。</p> <p>有一部分解决方案私活可以解决这个问题。IE有一个名为outerHTML的专有属性，可以为元素返回一个HTML字符串的表示。不管什么原因，除了可以对outerHTML进行取值以外，还可以对其进行赋值。事实证明，如果我们执行如下语句:<code>outerHTML=&quot;&quot;;</code></p> <p>它将元素在IE中使用的内存更加彻底的清理掉，而不是仅调用removeChild().</p> <p>除了正常调用removeChild()以外，我们还可以额外做这一步工作。</p> <p>在IE中设置outerHTML，以便尝试清理更多内存:</p> <div class="language- extra-class"><pre class="language-text"><code>if(this.parentNode)
    this.parentNode.removeChild(this);
if(typeof this.outerHTML!==&quot;undefined&quot;)
    this.outerHTML = &quot;&quot;;
</code></pre></div><p>需要注意，outerHTML不是全部成功清理该元素所使用的内存，但它能清理一大部分。</p> <p>重要的是要记住，在页面删除一个元素时，最少也应该执行前面的三个步骤。其中包括将元素外部内容情况，替换元素内容(HTML或文本)，直接替换元素。记住，要让DOM永远保持整洁，就不必太担心内存问题。</p> <h3 id="文本内容"><a href="#文本内容" class="header-anchor">#</a> 文本内容</h3> <p>处理文本比处理HTML元素往往容易很多，特别是有一些处理文本的内置方法，可用于所有的浏览器。但像往常一样，有很多要处理的各种各样的浏览器bug，所以这些API不是我们所希望的完整解决方案。</p> <p>当涉及到文本处理时，有两种常见的场景。</p> <ul><li>获取元素的文本内容。</li> <li>设置元素的文本内容。</li></ul> <p>W3C兼容性浏览器很方便的在DOM元素上提供一个textContent属性。访问该属性的内容就可以得到该元素的文本内容，也包括其直接子节点以及后代节点的文本内容。</p> <p>旧版IE浏览器有自己的专有属性innerText，可以实现与textContent相同的行为。</p> <p>阅读如下代码:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;test&quot;&gt;&lt;b&gt;Hello&lt;/b&gt;,I'm a ninja!&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
        var b = document.getElementById(&quot;test&quot;);
        var text = b.textContent || b.innerText;
        assert(text === &quot;Hello,I'm ninja!&quot;,&quot;Examine the text contents of an element.&quot;);
        assert(b.childNodes.length === 2,&quot;An element and a text node exist.&quot;);
        if(typeof b.textContent !== &quot;undefined&quot;){
            b.textContent = &quot;Some new text&quot;;
        }else{
            b.innerText = &quot;Some new text&quot;;
        }
        text = b.textContent||b.innerText;
        assert(text===&quot;Some new text&quot;,&quot;Set a new text value.&quot;);
        assert(b.childNodes.length===1,&quot;Only one text node exists now.&quot;)
    }

&lt;/script&gt;
</code></pre></div><p>注意，在我们设置textContent/innerText属性时，原有的元素结构被删除了。因此，虽然这两种属性非常有用，但有一定数量的陷阱。</p> <p>首先，就像删除页面元素时所讨论的那样，没有考虑内存泄漏会带来不利的后果。此外，在这些属性中跨浏览器处理空白绝对是很糟糕的。没有任何一个浏览器有能力返回一致的结果。</p> <p>如果不关心保留空格(尤其是结束行)，可以随意使用textContent/innerText获取元素的文本值。要设置元素的文本值，我们需要设计一个替代方案。</p> <h4 id="设置文本"><a href="#设置文本" class="header-anchor">#</a> 设置文本</h4> <p>设置元素文本包括两个步骤。</p> <ul><li>将元素的内容清空。</li> <li>插入新的文本内容。</li></ul> <p>清空元素的文本内容很简单，在前面代码中，我们已经设计了一个方案。</p> <p>插入新的文本内容，我们需要使用一种方法对插入的字符串进行转义。插入HTML和插入文本的一个重要区别是，需要对插入文本中的有问题的HTML字符进行转义。例如&lt;必须要用<code>&amp;lt</code>;进行显示。</p> <p>幸运的是，可以使用DOM文档上内置的createTextNode()方法精确的实现该转义功能，代码如下所示。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;test&quot;&gt;&lt;b&gt;Hello&lt;/b&gt;,I'm a ninja!&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
        var b = document.getElementById(&quot;test&quot;);
        while(b.firstChild)
            b.removeChild(b.firstChild);
            b.appendChild(document.createTextNode(&quot;Some new text&quot;));
            var text = b.textContent||b.innerText;
            assert(text===&quot;Some new text&quot;,&quot;Set a new text value.&quot;);
            assert(b.childNodes.length===1,&quot;Only one text node exists now.&quot;)
    }

&lt;/script&gt;
</code></pre></div><h4 id="获取文本"><a href="#获取文本" class="header-anchor">#</a> 获取文本</h4> <p>要得到元素的精确文本值，必须要忽略textContext和innterText的结果。这些属性的最常见问题是结束符从返回的结果中被剥夺了。相反，我们必须手工收集所有文本节点来得到一个精确的结果。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;test&quot;&gt;&lt;b&gt;Hello&lt;/b&gt;,I'm a ninja!&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
        function getText(elem){
            var text = &quot;&quot;;
            for(var i=0;i&lt;elem.childNodes.length;i++){
                var cur = elem.childNodes[i];
                //文本节点的nodeType是3
                if(cur.nodeType===3){
                    text+=cur.nodeValue;
                }else if(cur.nodeType===1){
                    text+=getText(cur);
                }
            }
            return text;
        }
        var b = document.getElementById(&quot;test&quot;);
        var text = getText(b);
        assert(text === &quot;Hello,I'm a ninja!&quot;,&quot;Examine the text contents of an element.&quot;);
        assert(b.childNodes.length===2,&quot;An element and a text node exist.&quot;);
    }

&lt;/script&gt;
</code></pre></div><p>在应用程序中，如果不担心空格的话，应该坚持使用textContent/innerText属性，因为它们可以让代码变得更简单。但是最好在这些属性不符合需求时，提供备选方案。</p> <h2 id="css选择器引擎"><a href="#css选择器引擎" class="header-anchor">#</a> CSS选择器引擎</h2> <p>作为Web开发人员，好消息是所有的现代浏览器都支持W3C Selectors API。该API(有两个层次:Level1和Level2)给我们提供了querySelectorAll()和querySelector()方法以及其他内容，我们可以利用这些API在很多浏览器上进行快速的DOM遍历。</p> <p>大家可能会问，W3C Selectors API几乎在所有现代浏览器中都实现了，为什么还要花时间讨论纯JavaScript CSS选择器引擎是如何实现的呢？</p> <p>虽然标准API是一件好事，但大多数浏览器中的W3C Selectors API实现(至少在2012年中期是这样的状态)都是将内部CSS选择器引擎硬套在JavaScript/DOM接口中。为了实现这一点，与一个好的API有关联的很多细节都被忽略了。例如，选择器方法不使用已经构建的DOM缓存，就没办法提供正确的错误报告，并且它们也无法处理任何形式的可扩展性。</p> <p>JavaScript流行库中的CSS选择器引擎会考虑所有这些因素。它们使用DOM缓存提供更快的性能，它们提供其他水平的错误报告，并且它们是高度可扩展的。</p> <p>综上所述，问题是:为什么要理解一个纯JavaScript CSS选择器引擎是如何工作的？答案是，理解纯JavaScript CSS选择器引擎的工作原理，可以在性能上获得一些令人意想不到的结果。我们不仅能编写更好的遍历实现，通过DOM树进行更快的搜索，还可以了解CSS选择器引擎的工作原理，从而编写性能更好的选择器。</p> <p>CSS选择器引擎是这个时代中日常开发工作的一部分，理解它们是如何工作的，以及如何让它们的工作速度更快，可以为我们提供开发基础。比较，要想在页面上开发这种类型脚本，很多事情都要遵循如下这种模式。</p> <ul><li>查找DOM元素。</li> <li>对(使用)DOM元素做点什么事情。</li></ul> <p>除了新的Selectors API，查找DOM元素从来都不是浏览器JavaScript的强项，定位元素的可用方法几乎仅限于通过ID和标签名称才能进行查找。对第一步做一些简化，可以让我们关注更有意思的&quot;做点什么事情&quot;步骤。</p> <p>目前，选择器引擎要实现的CSS选择器标准，由W3C定义，地址:www.w3.org/TR/css3-selectors/。</p> <p>关于实现方式，有三种主要方式可以实现一个CSS选择器引擎。</p> <ul><li>使用前面提到的W3C Selectors API，该API在大多数现代浏览器中都有实现。</li> <li>使用XPath，一种在大多数现代浏览器中都内置的DOM查询语言。</li> <li>使用纯DOM作为CSS选择器引擎的主要部分，在上述两个机制不存在的时候，可以进行优雅降级。</li></ul> <h3 id="w3c-selectors-api"><a href="#w3c-selectors-api" class="header-anchor">#</a> W3C Selectors API</h3> <p>W3C Selectors API是一个相对较新的API，旨在较少JavaScript中实现一个完整CSS选择器引擎所需要做的大部分工作。</p> <p>浏览器厂商已经抓住这个新API的机会，并在所有主要浏览器上都有实现(从Safari3,Firefox3.1,Internet Explorer 8,Chrome(几乎从一开始)以及Opera10开始)。该APi的实现通常支持浏览器CSS选择器引擎实现的所有功能，因此如果浏览器完整支持CSS3，其Selectors API的试下将会反映出这一点。</p> <p>该API提供了很多有用的方法，其中两个方法在现代浏览器中进行实现的。</p> <ul><li>querySelector()接受一个CSS选择器字符串，并返回找到的第一个元素，或者如果没有找到匹配元素的话就返回null。</li> <li>querySelectorAll()接受一个CSS选择器字符串，并返回该选择器找到的所有元素组成的静态NodeList。</li></ul> <p>这两种方法存在于所有的DOM元素，DOM元素文档以及DOM片段上。代码如下，展示了使用这两种方法的几个实例。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;test&quot;&gt;&lt;b&gt;Hello&lt;/b&gt;,I'm a ninja!&lt;/div&gt;
&lt;div id=&quot;test2&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
        var divs = document.querySelectorAll(&quot;body&gt;div&quot;);
        //查找是body组元素的&lt;div&gt;元素
        assert(divs.length===2,&quot;Two divs found using a CSS selector.&quot;);
        var b = document.getElementById('test').querySelector(&quot;b:only-child&quot;);
        //只查找粗体子元素
        assert(b,&quot;The bold element was found relative to another element&quot;);
    }
&lt;/script&gt;
</code></pre></div><p>当前W3C Selectors API 可能存在一个陷阱，对浏览器支持的CSS选择器，该API只提供了有限的支持，而不是像先前JavaScript库的实现那样有广泛的支持。通过查看元素级查询的匹配规则可以看到(在一个元素上调用querySelector()或querySelectorAll())。</p> <p>元素级查询:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div id=&quot;test&quot;&gt;&lt;b&gt;Hello&lt;/b&gt;,I'm a ninja!&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
        var divs = document.getElementById('test').querySelector(&quot;div b&quot;);
        assert(b,&quot;Only the last part of the selector matters.&quot;);
    }
&lt;/script&gt;
</code></pre></div><p>注意这里的问题:执行一个元素级查询时，选择器只检查选择器的最后一部分是否包含在元素中。这似乎违反直觉。在上述代码中，我们可以验证在id为test的元素中没有任何<code>&lt;div&gt;</code>元素，即便选择器看起来是有div一样。</p> <p>这违背了大多数用户期望的CSS选择器引擎工作原理，所以我们必须提供一个解决方案。最常见的解决方案是，在目标元素上添加一个新的id，以强制改变根元素的上下文。</p> <p><img src="/book/1602131609362.jpg" alt=""></p> <p>首先，必须为元素赋予一个唯一id，并且稍后将原始id恢复回去，以确保构建选择器时的最终结果没有冲突。然后我们将id拼接在选择器前面(以&quot;#id&quot;的形式，此时的id是生成的唯一值)。</p> <p>正常情况下，该过程会简单删除id并且返回查询的结果，但是有一个问题需要注意:Selectors API方法可能会抛出异常(常出现于错误的选择器语法或不支持的选择器)。正因为如此，我们需要将其包装在try/catch块中。不过由于要恢复元素的原始id，所以我们可以额外添加 一个finally块。这是编程语言很有趣的一个特性:不管是在try中返回一个值，还是在catch中抛出异常，finally块中的代码永远都会在上述两个代码块结束以后进行执行(但在函数将值返回之前)。以这种方式，我们可以确保id总能正常恢复。</p> <p>近期，Selectors API绝对是W3C中最后前途的API之一。支持Selectors API的浏览器在获取主要市场份额和支持完整CSS3(或至少是大多数)以后，它有可能用一个简单的方法来完全取代大多数JavaScript库提供的大部分功能。</p> <h3 id="利用xpath查找元素"><a href="#利用xpath查找元素" class="header-anchor">#</a> 利用XPath查找元素</h3> <p>对于不支持Selectors API的浏览器，一个统一的替代方案是使用XPath查询。</p> <p>XPath是一种查询语言，用于在DOM文档中查询DOM节点。它比传统的CSS选择器更强大，并且大多数流行的浏览器(Firefox,Safari 3+,Opera 9+,Chrome)都提供了XPath对XML文档的支持(而不是HTML文档----最常见的目标)。</p> <p>如果要描述一下利用XPath表达式所做的事情，那就是XPath对复杂表达式的查询非常快。在实现一个纯DOM实现的选择器引擎时，我们经常利用浏览器的特性扩展所有的JavaScript和DOM操作。另外，XPath无法使用简单表达式。</p> <p>在使用XPath表达式比使用纯粹的DOM操作更有利方面，有某种不确定的门槛。虽然这个门槛可能以编程方式确定，但有几个条件:通过id或者简单的标签(<code>&lt;div&gt;</code>)查找元素的速度比纯DOM方式(使用getElementById()和getElementsByTagName())快。</p> <p>如果我们的目标受众对使用XPath表达式很接受(并且乐于将自己限制在支持Xpath的现代浏览器内)，那么我们可以利用如下代码清单所示的方法，而且完全可以忽视CSS选择器引擎的构建。</p> <div class="language- extra-class"><pre class="language-text"><code>if(typeof document.evaluate === &quot;function&quot;){
    function getElementsByXPath(expression,parentElement){
        var results = [];
        var query = document.evaluate(expression,parentElement || document,null,XPathResult.ORDERED_NODE_SNAPSHOT_TYPE,null);
        for(var i=0,length=query.snapshotLength;i&lt;length;i++)
            results.push(query.snapshotItem(i));
        return results;
    }
}
</code></pre></div><p>如果能将XPath用于所有的地方会很好，但那是不可信的。XPath功能强大，主要是供开发人员使用，并且与CSS选择器提供的简单用法相比，XPath的用法相当的复杂。虽然不能在这里列出所有的XPath，但下图中提供了一些最常见XPath表达式和相对应CSS选择器的快速概览。</p> <p><img src="/book/1602132812130.jpg" alt=""></p> <p>通过正则表达式对选择器进行解析，我们可以使用XPath表达式创建一个选择器引擎，而不是构建一个纯DOM选择器引擎。最重要的区别是，由正则表达式产生的CSS选择器会映射成相关XPath表达式并进行执行。</p> <p>这种方式并没有太多优点，因为其结果，在代码层面上，他和一个正常纯DOM的CSS选择器引擎的实现代码一样多。许多开发人员不愿使用XPath引擎，只是为了降低选择器引擎的复杂性。我们需要在XPath引擎的性能优势和代码大小之间进行权衡。</p> <h3 id="纯dom实现"><a href="#纯dom实现" class="header-anchor">#</a> 纯DOM实现</h3> <p>每个CSS选择器引擎的核心都是纯DOM方法的实现。这需要解析CSS选择器并使用现有的DOM方法(如getElementById()和getElementByTagName())来找到相应的元素。</p> <p>在CSS选择器引擎的实现里使用DOM方式是很重要的，其原因有如下几个。</p> <ul><li>IE6和IE7----虽然IE8和IE9支持qurySelectorAll()，但IE6和IE7缺乏对XPath或Selectors API的支持，这使得DOM实现变得很有必要。</li> <li>向后兼容----对于不支持Selectors API和XPath(如Safari2)的浏览器，如果想要代码以合适方式降级并支持它们的话，需要某种形式的DOM实现。</li> <li>速度----很多纯DOM实现的选择器引擎的速度也很快(比如按ID查找元素)。</li> <li>全覆盖----并不是所有的浏览器都支持同样的CSS3选择器。如果要在所有的浏览器上都完整支持----或最少支持一个常用子集的话，我们也得需要自己来实现查找。</li></ul> <p>记住上述要点，我们可以看一下两种可能的CSS选择器引擎实现方式:自上而下和自下而上。</p> <p>自上而下的引擎是通过对CSS选择器从左到右进行解析来实现的，以匹配文档中的元素，相当于对每个额外的选择器片段都进行查找一遍。这种类型的引擎，在大多数现代JavaScript库中都可以发行，一般来说，这是在页面上查找元素的首选方式。</p> <p>让我们看一个简单的示例。阅读如下代码:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;div class=&quot;ninja&quot;&gt;
        &lt;span&gt;Please&lt;/span&gt;&lt;a href=&quot;/ninja&quot;&gt;&lt;span&gt;Click me!&lt;/span&gt;&lt;/a&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre></div><p>如果要查找包含&quot;Click me!&quot;文本的<code>&lt;span&gt;</code>元素，我们可以使用如下选择器进行查找:div.ninja a span</p> <p>使用自上而下的方式在DOM上应用该选择器的描述，如图所示</p> <p><img src="/book/1602137463965.jpg" alt=""></p> <p>d第一段选择器div.ninja标识的是文档中的子树。在该子树下，下一段选择器a被应用了，标识的是以链接元素为根的子树。最后，span选择器标识了目标节点。请注意，这是一个简化示例，一般在查找的时候，任何阶段都有可能识别出多个子树。</p> <p>在开发选择器引擎时，有两个重要的注意事项需要考虑。</p> <ul><li>查询结果应该按照文档顺序进行排序(它们在文档中定义的顺序)。</li> <li>查询结果应该时唯一的(不应该返回重复元素)。</li></ul> <p>正因为有这些陷阱，开发自上而下引擎有时候可能会相当棘手。</p> <p>让我们来看一个简化的，自上而下的选择器引用实现，仅限于根据标签名称查找元素。</p> <p><img src="/book/1602137755006.jpg" alt=""> <img src="/book/1602137799111.jpg" alt=""></p> <p>在改代码清单中，我们实现了一个有局限性的，自上而下的选择器引擎，它只能按照标签名称来查找元素。该引擎可分解为几个部分:解析选择器，查找元素，过滤，递归并合并结果。</p> <h4 id="对选择器进行解析"><a href="#对选择器进行解析" class="header-anchor">#</a> 对选择器进行解析</h4> <p>在上述简化示例中，我们的解析仅限于转换一个由标签名称组成的CSS选择器，比如，将&quot;div span&quot;转换成一个字符串数组，数组结果是:[&quot;div&quot;,&quot;span&quot;]。</p> <p>上述实例，只能用空格分隔符对选择器字符串进行拆分，但CSS2和CSS3可用根据元素的特性或特性值来查找元素，所以在大多数选择器上可能有额外的空格。这种方式将会让我们的选择器拆分策略变得太过于简单。</p> <p>对于完整的实现，我们要指定一系列严格的解析规则来处理可能传入的任意表达式。这些规则可能大都汇才用正则表达式的形式。如下示例展示了一个更强大的解析器，它使用一个能够获取选择器并将其分解成多个部分的正则表达式(如果需要还会有逗号分隔)。</p> <p><img src="/book/1602138206228.jpg" alt=""></p> <p>很显然，这种选择器只是众多选择器中的一个。对于需要支持的每种表达式类型，我们都要提供额外的解析规则。大多数选择器引擎最终都会包含映射，该映射中一个正则表达式对应一个函数，选择器被哪个正则表达式匹配上了，就执行哪个正则表达式对应的函数。</p> <p>检查这样的表达式细节会花费相当长的事件。如果真想深入研究它是如何实现的，我们鼓励大家分析jQuery源码(或自己喜欢的其他库)中的选择器解析部分的代码。</p> <h4 id="查找元素"><a href="#查找元素" class="header-anchor">#</a> 查找元素</h4> <p>在页面上查找正确的元素只是拼图中的一块，查找方法有很多种。尽管有很多明显的方法，但要使用哪些技术，很大程度上取决于要支持的选择器以及浏览器支持哪些选择器。</p> <p>思考一下getElementById()。该方法只能在HTML文档的根节点上使用，并且只返回页面上的第一个id等于特定值的元素(也应该只有一个)。因此它对ID CSS选择器(#id)是有用的。可惜的是，IE浏览器和Opera也会查找页面上的第一个name等于id值的元素。如果只希望根据id查找元素，我们需要一个额外的验证步骤来排除这种&quot;有帮助的&quot;元素选择功能。</p> <p>如果希望查找和特定id匹配的所有元素(这种要求在CSS选择器中司空见惯，尽管通常HTML文档每页只允许一个特定的id)，我们需要遍历所有的元素来寻找正确的id，或者在支持id的浏览器中使用document.all[&quot;id&quot;]，其返回与id相匹配的所有元素组成的一个数组(即IE，Opera和Safari)。</p> <p>getElementsByTagName()方法执行的操作平淡无奇:查找匹配特定标签名称的元素。然而它还有另外一个目的:可以使用星号标签名称(*)查找一个文档(或元素)中的所有的元素。对于处理基于特定的选择器(没有提供特定的标签名称)来说，这种方法特别有用，比如.class和[attr]。</p> <p>使用*查找元素时有一个注意事项，除了元素节点以外，IE浏览器也会把注释节点返回(不管处于何种原因，在IE中，注释节点的标签名称是叹号(!)，因此就被返回了)。所以需要进行最基本的过滤操作，以确保注释节点被排除在外。</p> <p>getElementsByName()是一个实现良好的方法，有一个单一目的:查找具有特定name的所有元素(如含有name特性的<code>&lt;input&gt;</code>元素和其他表单控制元素)。对于单一选择器[name=name]的实现确实十分有用。</p> <p>getElementsByClassName()方法是浏览器实现的一种新HTML5方法，其基于class特性来查找元素。该方法极大的加速了class选择器的查询。</p> <p>对于元素查询，虽然有各种各样的技术可以选择，但上面几个方法是页面元素查找的主要方式。</p> <h4 id="过滤结果集"><a href="#过滤结果集" class="header-anchor">#</a> 过滤结果集</h4> <p>一个CSS表达式通常是由多个独立的部分组成。例如，表达式div.class[id]有三个部分:查找所有的div元素，并且这些div元素都有一个class样式名，而且还都有一个名为id的属性。</p> <p>第一步是确定要开始查询的根选择器。例如，看到div，我们就可以立即使用getElementsByTagName()在页面撒花姑娘查找所有的<code>&lt;div&gt;</code>元素，然后，必须对查询结果进行过滤，只保留含有特定class样式且定义了id属性的元素。</p> <p>该过滤过程，是一种大多数选择器都实现的常见功能。这些过滤内容主要是属性或元素在兄弟节点或其他关系上的位置。</p> <ul><li>属性过滤----这种方法是用于访问DOM属性(通常使用getAttribute()方法)，并验证它们的值。样式过滤(.class)是这种行为的一个子集(访问className属性并检查它的值)。</li> <li>位置过滤----例如:nth-child(event)或last-child，要在父元素上使用一系列方法额度组合。如果浏览器支持children(IE,Safari,Chrome,Opera,Firefox 3.1)，则使用children，该属性是一个包含所有子元素的列表。所有的浏览器都有一个childNodes属性，该属性是一个包含所有子节点(包括文本节点和注释节点)的列表。利用这两个方法，就可以实现各种形式的元素位置过滤。</li></ul> <p>构建一个过滤函数可以达到双重目的:作为一个简单的方法提供给用户来测试它们的元素，我们可以快速判断一个元素是否匹配特定的选择器。</p> <h4 id="递归和合并"><a href="#递归和合并" class="header-anchor">#</a> 递归和合并</h4> <p>在前面我们使用Selectors API示例中，选择器引擎需要进行递归(找到后代元素)并将结果合并在一起。但是我们的初始实现太简单了。我们在查询结果中得到的两个<code>&lt;span&gt;</code> 元素而不是一个。我们需要进行一次额外的检查，以确保返回的元素数组包含的都是不同的结果。大多数自上而下的选择器实现，都具备一些处理这种不同结果的方法。</p> <p>可惜的是，没有任何简单的方法可以确定一个DOM元素的唯一性，因此我们需要找出一种方法。我们将采取的方法是，遍历元素并给这些元素赋予一个临时的标识值，以便可以验证是否已经遇到了它们。</p> <p><img src="/book/1602143070272.jpg" alt=""></p> <p>该unique()方法给数组种的所有元素添加了一个扩展属性，将它们标记为&quot;已见到&quot;。变量结束的时候，只有不同的元素才能复制到新数组中。这种技术的变种几乎在所有的JavaScript库中都可以找到。</p> <h4 id="自下而上的选择器引用"><a href="#自下而上的选择器引用" class="header-anchor">#</a> 自下而上的选择器引用</h4> <p>如果不愿意考虑才用独特的方式识别元素，我们还有另外一种风格的CSS选择器引擎，不需要进行识别。自下而上选择器引擎的工作方式和自上而下的方向相反。</p> <p>举例来说，给定一个选择器div span，自下而上的选择器引擎会首先找到所有<code>&lt;span&gt;</code>元素，然后遍历每一个元素，再转向祖先方向查找<code>&lt;div&gt;</code>元素。这种风格的选择器引擎构建的匹配风格，在大多数浏览器引擎中都可以找到。</p> <p>这种引擎风格不像自上而下方式那样受欢迎。虽然适用于简单的选择器(子选择器)，但是祖先遍历需要付出相当高的代价，它不能很好的伸缩。但这种引擎提供的简单性，最终能够很好的权衡利弊。</p> <p>该引擎的构建十分简单。首先找到CSS选择器的最后一个表达式，然后查询相应的元素(就像自上而下的引擎一样，但使用的是最后一个表达式而不是第一个)。然后就开始执行一系列的过滤操作，并在操作中移除不符合条件的元素(代码如下).</p> <p><img src="/book/1602143952256.jpg" alt=""> <img src="/book/1602143997804.jpg" alt=""></p> <p>上述代码展示了一个简单的，自下而上的选择器引擎的构建。注意，它只能在一个层级的深度才能工作。要超过一层深度，要跟着当前深度的状态。这将会产生两个状态数组:其中一个元素数组包含的是要返回的元素(一些元素被设置为undefined，因为他不是匹配结果)，而另外一个元素数组则对应于当前测试的祖先元素。</p> <p>如前所述，这种额外祖先元素验证过程的最终可伸缩性略低于自上而下的方法，但它完全不需要使用unique方法产生非重复性元素的输出，而有些人则可能认为它是一个优势。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">8/25/2021, 3:56:53 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/interview/宝典四.html" class="prev">
        宝典(四)
      </a></span> <!----></p></div> </main></div><div class="global-ui"><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.61a85b1c.js" defer></script><script src="/assets/js/2.6b359b12.js" defer></script><script src="/assets/js/27.ea4375e5.js" defer></script>
  </body>
</html>
