<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Flutter知识 | 码农机器人</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="努力向前">
    
    <link rel="preload" href="/assets/css/0.styles.b8d0645b.css" as="style"><link rel="preload" href="/assets/js/app.61a85b1c.js" as="script"><link rel="preload" href="/assets/js/2.6b359b12.js" as="script"><link rel="preload" href="/assets/js/28.8e440e91.js" as="script"><link rel="prefetch" href="/assets/js/10.6bf522d2.js"><link rel="prefetch" href="/assets/js/100.a249a4e9.js"><link rel="prefetch" href="/assets/js/101.9d2465ad.js"><link rel="prefetch" href="/assets/js/102.5ea0ea92.js"><link rel="prefetch" href="/assets/js/103.ad073f03.js"><link rel="prefetch" href="/assets/js/104.afd1455c.js"><link rel="prefetch" href="/assets/js/105.5429d9b6.js"><link rel="prefetch" href="/assets/js/106.012719c5.js"><link rel="prefetch" href="/assets/js/107.fa002f10.js"><link rel="prefetch" href="/assets/js/108.9c70864a.js"><link rel="prefetch" href="/assets/js/109.ab6712ef.js"><link rel="prefetch" href="/assets/js/11.07adb038.js"><link rel="prefetch" href="/assets/js/110.3496849e.js"><link rel="prefetch" href="/assets/js/111.0708cccd.js"><link rel="prefetch" href="/assets/js/112.3ddda9ff.js"><link rel="prefetch" href="/assets/js/113.a826b4ec.js"><link rel="prefetch" href="/assets/js/114.54f06bf1.js"><link rel="prefetch" href="/assets/js/115.68bd2270.js"><link rel="prefetch" href="/assets/js/116.0e283e33.js"><link rel="prefetch" href="/assets/js/117.10ca7c11.js"><link rel="prefetch" href="/assets/js/118.0f21544b.js"><link rel="prefetch" href="/assets/js/119.3d5cdaf0.js"><link rel="prefetch" href="/assets/js/12.6a633ec9.js"><link rel="prefetch" href="/assets/js/13.2e8873e5.js"><link rel="prefetch" href="/assets/js/14.0ea5ac55.js"><link rel="prefetch" href="/assets/js/15.d24d1240.js"><link rel="prefetch" href="/assets/js/16.bfb99431.js"><link rel="prefetch" href="/assets/js/17.0bf6db21.js"><link rel="prefetch" href="/assets/js/18.f6a16197.js"><link rel="prefetch" href="/assets/js/19.15b1e095.js"><link rel="prefetch" href="/assets/js/20.56746f5a.js"><link rel="prefetch" href="/assets/js/21.5019bb92.js"><link rel="prefetch" href="/assets/js/22.36a83eaf.js"><link rel="prefetch" href="/assets/js/23.c1d826fa.js"><link rel="prefetch" href="/assets/js/24.66437f58.js"><link rel="prefetch" href="/assets/js/25.b5ef9760.js"><link rel="prefetch" href="/assets/js/26.1e34c193.js"><link rel="prefetch" href="/assets/js/27.ea4375e5.js"><link rel="prefetch" href="/assets/js/29.ffd2070e.js"><link rel="prefetch" href="/assets/js/3.a6d8cb97.js"><link rel="prefetch" href="/assets/js/30.c1451f4e.js"><link rel="prefetch" href="/assets/js/31.a21ecc83.js"><link rel="prefetch" href="/assets/js/32.5d1de9ff.js"><link rel="prefetch" href="/assets/js/33.f9eef1d1.js"><link rel="prefetch" href="/assets/js/34.edb8fde2.js"><link rel="prefetch" href="/assets/js/35.6950ed93.js"><link rel="prefetch" href="/assets/js/36.b394a848.js"><link rel="prefetch" href="/assets/js/37.f11aa33f.js"><link rel="prefetch" href="/assets/js/38.e86bdf7f.js"><link rel="prefetch" href="/assets/js/39.dbc9c882.js"><link rel="prefetch" href="/assets/js/4.f3783df1.js"><link rel="prefetch" href="/assets/js/40.470a2b37.js"><link rel="prefetch" href="/assets/js/41.bcffb885.js"><link rel="prefetch" href="/assets/js/42.484ee502.js"><link rel="prefetch" href="/assets/js/43.2a86b409.js"><link rel="prefetch" href="/assets/js/44.2b684e4d.js"><link rel="prefetch" href="/assets/js/45.4e6fb818.js"><link rel="prefetch" href="/assets/js/46.86268f46.js"><link rel="prefetch" href="/assets/js/47.84f7cda3.js"><link rel="prefetch" href="/assets/js/48.fd78be04.js"><link rel="prefetch" href="/assets/js/49.f5a6fc1e.js"><link rel="prefetch" href="/assets/js/5.892f2cf8.js"><link rel="prefetch" href="/assets/js/50.29919944.js"><link rel="prefetch" href="/assets/js/51.c1b5918c.js"><link rel="prefetch" href="/assets/js/52.c4ad64f8.js"><link rel="prefetch" href="/assets/js/53.df154372.js"><link rel="prefetch" href="/assets/js/54.4fee1b96.js"><link rel="prefetch" href="/assets/js/55.18c6e9f2.js"><link rel="prefetch" href="/assets/js/56.d5569485.js"><link rel="prefetch" href="/assets/js/57.9eb74b69.js"><link rel="prefetch" href="/assets/js/58.c8b7968e.js"><link rel="prefetch" href="/assets/js/59.a208d99c.js"><link rel="prefetch" href="/assets/js/6.a9a81823.js"><link rel="prefetch" href="/assets/js/60.c0f7048b.js"><link rel="prefetch" href="/assets/js/61.e06e2c12.js"><link rel="prefetch" href="/assets/js/62.3726a0b9.js"><link rel="prefetch" href="/assets/js/63.53a81692.js"><link rel="prefetch" href="/assets/js/64.ba6af384.js"><link rel="prefetch" href="/assets/js/65.2f165ffa.js"><link rel="prefetch" href="/assets/js/66.8c0a983a.js"><link rel="prefetch" href="/assets/js/67.74bf1c32.js"><link rel="prefetch" href="/assets/js/68.27c15e0b.js"><link rel="prefetch" href="/assets/js/69.5b78d6fb.js"><link rel="prefetch" href="/assets/js/7.a9e85c97.js"><link rel="prefetch" href="/assets/js/70.4772f9bd.js"><link rel="prefetch" href="/assets/js/71.2a2e89e4.js"><link rel="prefetch" href="/assets/js/72.3debedf0.js"><link rel="prefetch" href="/assets/js/73.c9ee93ce.js"><link rel="prefetch" href="/assets/js/74.7ec9495c.js"><link rel="prefetch" href="/assets/js/75.8c828ff5.js"><link rel="prefetch" href="/assets/js/76.986dc0d7.js"><link rel="prefetch" href="/assets/js/77.7e7e3c8e.js"><link rel="prefetch" href="/assets/js/78.200d9828.js"><link rel="prefetch" href="/assets/js/79.ee6b28e9.js"><link rel="prefetch" href="/assets/js/8.448002b9.js"><link rel="prefetch" href="/assets/js/80.93d03d67.js"><link rel="prefetch" href="/assets/js/81.eebcba15.js"><link rel="prefetch" href="/assets/js/82.3b0bb838.js"><link rel="prefetch" href="/assets/js/83.75234d18.js"><link rel="prefetch" href="/assets/js/84.1a897e55.js"><link rel="prefetch" href="/assets/js/85.8267b168.js"><link rel="prefetch" href="/assets/js/86.a7557c20.js"><link rel="prefetch" href="/assets/js/87.4f7e77b3.js"><link rel="prefetch" href="/assets/js/88.9b41f10e.js"><link rel="prefetch" href="/assets/js/89.662b9425.js"><link rel="prefetch" href="/assets/js/9.804860d0.js"><link rel="prefetch" href="/assets/js/90.6d84e2d8.js"><link rel="prefetch" href="/assets/js/91.650a7b6f.js"><link rel="prefetch" href="/assets/js/92.8568032c.js"><link rel="prefetch" href="/assets/js/93.0c300b40.js"><link rel="prefetch" href="/assets/js/94.f7ce23ff.js"><link rel="prefetch" href="/assets/js/95.e6c8272f.js"><link rel="prefetch" href="/assets/js/96.8f51c3ac.js"><link rel="prefetch" href="/assets/js/97.9cc683f5.js"><link rel="prefetch" href="/assets/js/98.6af1269f.js"><link rel="prefetch" href="/assets/js/99.97a09de8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b8d0645b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="码农机器人" class="logo"> <span class="site-name can-hide">码农机器人</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="/react/" class="nav-link">
  react
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>建立前端知识体系</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue源码分析</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>提效赋能 前端工程化篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>程序员PLUS篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Flutter</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/flutter/搭建Flutter开发环境.html" class="sidebar-link">搭建 Flutter 开发环境</a></li><li><a href="/note/flutter/Flutter知识.html" class="active sidebar-link">Flutter知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#flutter-是什么" class="sidebar-link">Flutter 是什么？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#flutter特性有哪些" class="sidebar-link">Flutter特性有哪些？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#flutter的优点是什么" class="sidebar-link">Flutter的优点是什么？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#flutter和dart的关系是什么" class="sidebar-link">Flutter和Dart的关系是什么？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#dart语言的特性" class="sidebar-link">Dart语言的特性？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#dart的一些重要概念" class="sidebar-link">Dart的一些重要概念？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#dart是值传递还是引用传递" class="sidebar-link">dart是值传递还是引用传递？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#widget和element和renderobject之间的关系" class="sidebar-link">Widget和element和RenderObject之间的关系？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#mixin-extends-implement之间的关系" class="sidebar-link">mixin extends implement之间的关系？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#使用mixins的条件是什么" class="sidebar-link">使用mixins的条件是什么？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#flutter-main-future-mirotask的执行顺序" class="sidebar-link">Flutter main future mirotask的执行顺序？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#future和isolate有什么区别" class="sidebar-link">Future和isolate有什么区别？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#stream-与-future是什么关系" class="sidebar-link">Stream 与 Future是什么关系？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#stream-两种订阅模式" class="sidebar-link">Stream 两种订阅模式</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#await-for-如何使用" class="sidebar-link">await for 如何使用?</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#flutter中的widget、state、context-的核心概念-是为了解决什么问题" class="sidebar-link">Flutter中的Widget、State、Context 的核心概念？是为了解决什么问题？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#widget的两种类型是什么" class="sidebar-link">Widget的两种类型是什么？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#state-对象的初始化流程" class="sidebar-link">State 对象的初始化流程？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#widget-唯一标识key有那几种" class="sidebar-link">Widget 唯一标识Key有那几种？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#什么是navigator-materialapp做了什么" class="sidebar-link">什么是Navigator? MaterialApp做了什么？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#statefulwidget的声明周期" class="sidebar-link">StatefulWidget的声明周期</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#flutter如何与android和ios通信" class="sidebar-link">Flutter如何与Android和iOS通信？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#什么是-widgets、renderobjects-和-elements" class="sidebar-link">什么是 Widgets、RenderObjects 和 Elements?</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#说一下什么是状态管理-为什么需要它" class="sidebar-link">说一下什么是状态管理，为什么需要它？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#如何统一管理错误页面" class="sidebar-link">如何统一管理错误页面？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#什么是scopedmodel-bloc模式" class="sidebar-link">什么是ScopedModel / BLoC模式？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#dart当中的-标识什么意思" class="sidebar-link">Dart当中的[..]标识什么意思？</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#dart的作用域" class="sidebar-link">Dart的作用域</a></li><li class="sidebar-sub-header"><a href="/note/flutter/Flutter知识.html#dart是不是单线程模型-是如何运行的" class="sidebar-link">Dart是不是单线程模型？是如何运行的？</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>忍者秘籍书</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="flutter知识"><a href="#flutter知识" class="header-anchor">#</a> Flutter知识</h1> <h2 id="flutter-是什么"><a href="#flutter-是什么" class="header-anchor">#</a> Flutter 是什么？</h2> <p>Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter完全免费，开源的。</p> <h2 id="flutter特性有哪些"><a href="#flutter特性有哪些" class="header-anchor">#</a> Flutter特性有哪些？</h2> <p>快速开发(毫秒级热重载)</p> <ul><li>绚丽UI(内建漂亮的质感设计Material Design和Cupertino Widget和丰富平滑的动画效果和平台感知)</li> <li>响应式(Reactive,用强大而灵活的API解决2D，动画，手势，效果等难题)</li> <li>原生访问功能</li> <li>堪比原生性能</li></ul> <h2 id="flutter的优点是什么"><a href="#flutter的优点是什么" class="header-anchor">#</a> Flutter的优点是什么？</h2> <ul><li>跨平台开发：此功能使Flutter可以编写一次代码, 进行维护并可以在不同平台上运行。它节省了开发人员的时间, 精力和金钱。</li> <li>更快的开发：Flutter应用程序的性能很快。 Flutter使用arm C / C ++库编译应用程序, 该库使其更接近于机器代码, 并为应用程序提供了更好的本机性能。</li> <li>良好的社区：Flutter具有良好的社区支持, 开发人员可以在其中提出问题并快速获得结果。</li> <li>实时和热重载：它使应用程序开发过程非常快速。此功能使我们能够在更改后立即更改或更新反映的代码。</li> <li>最少的代码：Flutter应用程序是由Dart编程语言开发的, 它使用JIT和AOT编译来缩短总体启动时间, 发挥作用并加速性能。 JIT增强了开发系统并刷新了UI, 而无需花费更多精力来构建新的。</li> <li>专注于UI：它具有出色的用户界面, 因为它使用了以设计为中心的小部件, 高级开发工具, 高级API和许多其他功能。</li> <li>文档：Flutter具有很好的文档支持。它井井有条, 内容更丰富。我们可以将所有想要编写的东西都放在一个地方。</li></ul> <h2 id="flutter和dart的关系是什么"><a href="#flutter和dart的关系是什么" class="header-anchor">#</a> Flutter和Dart的关系是什么？</h2> <p>Flutter是一个使用Dart语言开发的跨平台移动UI框架，通过自建绘制引擎，能高性能，高保真的进行移动开发。Dart囊括了多数编程语言的优点，它更符合Flutter构建界面的方式。</p> <h2 id="dart语言的特性"><a href="#dart语言的特性" class="header-anchor">#</a> Dart语言的特性？</h2> <ul><li>Productive(生产力高，Dart的语法清晰明了，工具简单但功能强大)</li> <li>Fast(执行速度快，Dart提供前优化编译，以在移动设备和Web上获得可预测的高性能和快速启动。)</li> <li>Protable(易于移植，Dart可编译成ARM和X86代码，这样Dart移动应用程序可以再iOS，Android和其他地方运行)</li> <li>Approachable(容易上手，充分吸收了高级语言特性，如果你已经知道C++，C语言，或者Java，你可以在短短几天内用Dart来开发)</li> <li>Reactive(响应式编程)</li></ul> <h2 id="dart的一些重要概念"><a href="#dart的一些重要概念" class="header-anchor">#</a> Dart的一些重要概念？</h2> <ul><li>在Dart中，一切都是对象，所有的对象都继承自Object</li> <li>Dart是强类型语言，但可以用var或dynamic来声明一个变量，Dart会自动推断其数据类型，dynamic类似c#</li> <li>没有赋初值的变量都会有默认值null</li> <li>Dart支持顶层方法，如main方法，可以在方法内部创建方法</li> <li>Dart支持顶层变量，也支持变量或对象变量</li> <li>Dart没有public protected private等关键字，如果某个变量以下划线(_)开头，代表这个变量在库中是私有的</li></ul> <h2 id="dart是值传递还是引用传递"><a href="#dart是值传递还是引用传递" class="header-anchor">#</a> dart是值传递还是引用传递？</h2> <p>dart中，基本数据类型是传值，类传引用。我们每次调用函数，传递过去的都是对象的内存地址，而不是这个对象的复制。</p> <h2 id="widget和element和renderobject之间的关系"><a href="#widget和element和renderobject之间的关系" class="header-anchor">#</a> Widget和element和RenderObject之间的关系？</h2> <ul><li>Widget是用户界面的一部分，并且是不可变得。</li> <li>Element是在树中特定位置Widget的实例。</li> <li>RenderObject是渲染树中的一个对象，它的层次结构是渲染库的核心。</li></ul> <p>Widget会被inflate(填充)到Element，并由Element管理底层渲染树。Widget并不会直接管理状态及渲染，而是通过State这个对象来管理状态。Flutter创建Element的可见树，相对于Widget来说，是可变的，通常界面开发中，我们不用直接操作Element，而是由框架层实现内部逻辑。就如一个UI视图树中，可能包含有多个TextWidget(Widget被使用多次)，但是放在内部视图树的视角，这些TextWidget都是填充到一个个独立的Element中。Element会持有renderObject和widget的实例。记住，Widget只是一个配置，RenderObject负责管理布局，绘制等操作。</p> <p>在第一次创建Widget的时候，会创建一个Element，然后将该元素插入树中。如果之后Widget发生了变化，则将其与旧的Widget进行比较，并且相应的更新Element。重要的是，Element不会被重建，只是更新而已。</p> <h2 id="mixin-extends-implement之间的关系"><a href="#mixin-extends-implement之间的关系" class="header-anchor">#</a> mixin extends implement之间的关系？</h2> <p>继承(关键字extends),混入mixins(关键字with),接口实现(关键字implements)。这三者可以同时存在，前后顺序是extends-&gt;mixins-&gt;implements。</p> <p>Flutter中的继承是单继承，子类重写超类的方法要用@Override,子类调用超类的方法要用super。</p> <p>在Flutter中，Mixins是一种在多个类层结构中复用类代码的方法。mixins的对象是类，mixins绝不继承，也不是接口，而是一种全新的特性，可以mixins多个类，mixins的使用需要满足一定条件。</p> <h2 id="使用mixins的条件是什么"><a href="#使用mixins的条件是什么" class="header-anchor">#</a> 使用mixins的条件是什么？</h2> <p>因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.1中使用mixins的条件:</p> <ul><li>mixins类只能继承自object</li> <li>mixins类不能有构造函数</li> <li>一个类可以mixins多个mixins类</li> <li>可以mixins多个类，不破坏Flutter的单继承</li></ul> <h2 id="flutter-main-future-mirotask的执行顺序"><a href="#flutter-main-future-mirotask的执行顺序" class="header-anchor">#</a> Flutter main future mirotask的执行顺序？</h2> <p>普通代码都是同步执行的，结束后会开始检查microtask中是否有任务，若有则执行，执行完继续检查microtask，直到microtask列队为空。最后会去执行event队列(future)。</p> <h2 id="future和isolate有什么区别"><a href="#future和isolate有什么区别" class="header-anchor">#</a> Future和isolate有什么区别？</h2> <p>future是异步编程，调用本身立即返回，并在稍后的某个时候执行完成时在获得返回结果。在普通代码中可以使用await等待一个异步调用结束。</p> <p>isolate是并发变成，Dart有并发时的共享状态，所有Dart代码都在isolate中运行，包括最初的main()。每个isolate都有它自己的堆内存，意味着其中所有内存数据，包括全局数据，都仅对该isolate可见，它们之间的通信只能通过传递消息的机制，消息则通过端口(port)收发。isolate只是一个概念，具体取决于如何实现，比如在Dart VM中一个isolate可能会是一个线程，在Web中可能会是一个Web Worker。</p> <h2 id="stream-与-future是什么关系"><a href="#stream-与-future是什么关系" class="header-anchor">#</a> Stream 与 Future是什么关系？</h2> <p>Stream 和 Future 是 Dart 异步处理的核心 API。Future 表示稍后获得的一个数据，所有异步的操作的返回值都用 Future 来表示。但是 Future 只能表示一次异步获得的数据。而 Stream 表示多次异步获得的数据。比如界面上的按钮可能会被用户点击多次，所以按钮上的点击事件（onClick）就是一个 Stream 。简单地说，Future将返回一个值，而Stream将返回多次值。Dart 中统一使用 Stream 处理异步事件流。Stream 和一般的集合类似，都是一组数据，只不过一个是异步推送，一个是同步拉取。</p> <h2 id="stream-两种订阅模式"><a href="#stream-两种订阅模式" class="header-anchor">#</a> Stream 两种订阅模式</h2> <p>Stream有两种订阅模式：单订阅(single) 和 多订阅（broadcast）。单订阅就是只能有一个订阅者，而广播是可以有多个订阅者。这就有点类似于消息服务（Message Service）的处理模式。单订阅类似于点对点，在订阅者出现之前会持有数据，在订阅者出现之后就才转交给它。而广播类似于发布订阅模式，可以同时有多个订阅者，当有数据时就会传递给所有的订阅者，而不管当前是否已有订阅者存在。</p> <p>Stream 默认处于单订阅模式，所以同一个 stream 上的 listen 和其它大多数方法只能调用一次，调用第二次就会报错。但 Stream 可以通过 transform() 方法（返回另一个 Stream）进行连续调用。通过 Stream.asBroadcastStream() 可以将一个单订阅模式的 Stream 转换成一个多订阅模式的 Stream，isBroadcast 属性可以判断当前 Stream 所处的模式。</p> <h2 id="await-for-如何使用"><a href="#await-for-如何使用" class="header-anchor">#</a> await for 如何使用?</h2> <p>await for是不断获取stream流中的数据，然后执行循环体中的操作。它一般用在直到stream什么时候完成，并且必须等待传递完成之后才能使用，不然就会一直阻塞。</p> <div class="language-js extra-class"><pre class="language-js"><code>Stream<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream</span><span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">fromIterable</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'不开心'</span><span class="token punctuation">,</span> <span class="token string">'面试'</span><span class="token punctuation">,</span> <span class="token string">'没'</span><span class="token punctuation">,</span> <span class="token string">'过'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> async<span class="token punctuation">{</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'上午被开水烫了脚'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> <span class="token keyword">for</span><span class="token punctuation">(</span>String s <span class="token keyword">in</span> stream<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">'晚上还没吃饭'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="flutter中的widget、state、context-的核心概念-是为了解决什么问题"><a href="#flutter中的widget、state、context-的核心概念-是为了解决什么问题" class="header-anchor">#</a> Flutter中的Widget、State、Context 的核心概念？是为了解决什么问题？</h2> <p><strong>Widget</strong> : 在Flutter中，几乎所有东西都是Widget。将一个Widget想象为一个可视化的组件（或与应用可视化方面交互的组件），当你需要构建与布局直接或间接相关的任何内容时，你正在使用Widget。</p> <p><strong>Widget树</strong> : Widget以树结构进行组织。包含其他Widget的widget被称为父Widget(或widget容器)。包含在父widget中的widget被称为子Widget。</p> <p><strong>Context</strong> : 仅仅是已创建的所有Widget树结构中的某个Widget的位置引用。简而言之，将context作为widget树的一部分，其中context所对应的widget被添加到此树中。一个context只从属于一个widget，它和widget一样是链接在一起的，并且会形成一个context树。</p> <p><strong>State</strong> : 定义了StatefulWidget实例的行为，它包含了用于”交互/干预“Widget信息的行为和布局。应用于State的任何更改都会强制重建Widget。</p> <p>这些状态的引入，主要是为了解决多个部件之间的交互和部件自身状态的维护。</p> <h2 id="widget的两种类型是什么"><a href="#widget的两种类型是什么" class="header-anchor">#</a> Widget的两种类型是什么？</h2> <p><strong>StatelessWidget</strong> : 一旦创建就不关心任何变化，在下次构建之前都不会改变。它们除了依赖于自身的配置信息（在父节点构建时提供）外不再依赖于任何其他信息。比如典型的Text、Row、Column、Container等，都是StatelessWidget。它的生命周期相当简单：初始化、通过build()渲染。</p> <p><strong>StatefulWidget</strong> : 在生命周期内，该类Widget所持有的数据可能会发生变化，这样的数据被称为State，这些拥有动态内部数据的Widget被称为StatefulWidget。比如复选框、Button等。State会与Context相关联，并且此关联是永久性的，State对象将永远不会改变其Context，即使可以在树结构周围移动，也仍将与该context相关联。当state与context关联时，state被视为已挂载。StatefulWidget由两部分组成，在初始化时必须要在createState()时初始化一个与之相关的State对象。</p> <h2 id="state-对象的初始化流程"><a href="#state-对象的初始化流程" class="header-anchor">#</a> State 对象的初始化流程？</h2> <p><strong>initState()</strong> : 一旦State对象被创建，initState方法是第一个（构造函数之后）被调用的方法。可通过重写来执行额外的初始化，如初始化动画、控制器等。重写该方法时，应该首先调用super.initState()。在initState中，无法真正使用context，因为框架还没有完全将其与state关联。initState在该State对象的生命周期内将不会再次调用。</p> <p><strong>didChangeDependencies()</strong> : 这是第二个被调用的方法。在这一阶段，context已经可用。如果你的Widget链接到了一个InheritedWidget并且/或者你需要初始化一些listeners（基于context），通常会重写该方法。</p> <p><strong>build(BuildContext context)</strong> : 此方法在didChangeDependencies()、didUpdateWidget()之后被调用。每次State对象更新（或当InheritedWidget有新的通知时）都会调用该方法！我们一般都在build中来编写真正的功能代码。为了强制重建，可以在需要的时候调用setState((){...})方法。</p> <p><strong>dispose()</strong> : 此方法在Widget被废弃时调用。可重写该方法来执行一些清理操作（如解除listeners），并在此之后立即调用super.dispose()。</p> <h2 id="widget-唯一标识key有那几种"><a href="#widget-唯一标识key有那几种" class="header-anchor">#</a> Widget 唯一标识Key有那几种？</h2> <p>在flutter中，每个widget都是被唯一标识的。这个唯一标识在build或rendering阶段由框架定义。该标识对应于可选的Key参数，如果省略，Flutter将会自动生成一个。</p> <p>在flutter中，主要有4种类型的Key：GlobalKey（确保生成的Key在整个应用中唯一，是很昂贵的，允许element在树周围移动或变更父节点而不会丢失状态）、LocalKey、UniqueKey、ObjectKey。</p> <h2 id="什么是navigator-materialapp做了什么"><a href="#什么是navigator-materialapp做了什么" class="header-anchor">#</a> 什么是Navigator? MaterialApp做了什么？</h2> <p>Navigator是在Flutter中负责管理维护页面堆栈的导航器。MaterialApp在需要的时候，会自动为我们创建Navigator。Navigator.of(context)，会使用context来向上遍历Element树，找到MaterialApp提供的_NavigatorState再调用其push/pop方法完成导航操作。</p> <h2 id="statefulwidget的声明周期"><a href="#statefulwidget的声明周期" class="header-anchor">#</a> StatefulWidget的声明周期</h2> <ul><li>initState():Widget初始化当前State，在当前方法中是不能获取到Context的，如果想要获取，可以事Flutter.delaved()。</li> <li>didChangeDependencies():在initState()后调用，State对象依赖关系发生变化的时候也会调用。</li> <li>deactivate():当state被暂时从视图树中移除时会调用这个方法，页面切换时也会调用该方法，和Android里的onPause差不多。</li> <li>dispose():Widget销毁时调用。</li> <li>didUpdateWidget:Widget状态发生变化的时候调用。</li></ul> <h2 id="flutter如何与android和ios通信"><a href="#flutter如何与android和ios通信" class="header-anchor">#</a> Flutter如何与Android和iOS通信？</h2> <p>Flutter通过PlatformChannel与原生进行交互，其中PlatformChannel分为三种:</p> <ul><li>BasicNessageChannel:用于产地字符串和半结构化的信息。</li> <li>MethodChannel:用于传递方法调用。Flutter主动调用Native的方法，并获取相应的返回值。</li> <li>EventChannel：用于数据流(event streams)的通信。</li></ul> <p>具体可以查看 <a href="https://www.jianshu.com/p/39575a90e820" target="_blank" rel="noopener noreferrer">闲鱼技术：深入理解 Flutter Platform Channe<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="什么是-widgets、renderobjects-和-elements"><a href="#什么是-widgets、renderobjects-和-elements" class="header-anchor">#</a> 什么是 Widgets、RenderObjects 和 Elements?</h2> <ul><li>Widget 仅用于存储渲染所需要的信息。</li> <li>RenderObject 负责管理布局、绘制等操作。</li> <li>Element 才是这颗巨大的控件树上的实体。</li></ul> <p>具体可以查看<a href="https://juejin.cn/post/6844903639119560711" target="_blank" rel="noopener noreferrer">Flutter，什么是 Widgets、RenderObjects 和 Elements?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="说一下什么是状态管理-为什么需要它"><a href="#说一下什么是状态管理-为什么需要它" class="header-anchor">#</a> 说一下什么是状态管理，为什么需要它？</h2> <p>首先状态其实是一个概念上的东西，区分全局状态和局部状态。</p> <p>局部状态比如说一个控件中输入的信息，全局状态比如是登陆后从后台请求回来的 userId。</p> <p>当全局状态越来越多，多个页面共享一个状态时，我们就需要管理它。</p> <p>常用的状态管理有：</p> <ul><li>ScopedModel</li> <li>BLoC</li> <li>Redux / FishRedux</li> <li>Provider</li></ul> <h2 id="如何统一管理错误页面"><a href="#如何统一管理错误页面" class="header-anchor">#</a> 如何统一管理错误页面？</h2> <p>我们都知道，如果在 Flutter 当中出错的话，那就是一片红。</p> <p>可以使用 ErrorWidget.builder 来自定义一个 Widget 就 ok 了。</p> <p>具体可以看一下 <a href="https://juejin.cn/post/6844903762398560270" target="_blank" rel="noopener noreferrer">小德 - 教你自定义Flutter错误页面<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="什么是scopedmodel-bloc模式"><a href="#什么是scopedmodel-bloc模式" class="header-anchor">#</a> 什么是ScopedModel / BLoC模式？</h2> <p>ScopedModel和BLoC（业务逻辑组件）是常见的Flutter应用程序架构模式，可帮助将业务逻辑与UI代码分离，并使用更少的状态窗口小部件。</p> <h2 id="dart当中的-标识什么意思"><a href="#dart当中的-标识什么意思" class="header-anchor">#</a> Dart当中的[..]标识什么意思？</h2> <p>Dart当中的<code>[..]</code>意思是<code>[级联操作符]</code>，为了方便配置而使用。<code>[..]</code>和<code>[.]</code>不同的是调用<code>[..]</code>后返回的相当于是this，而<code>[.]</code>返回的则是该方法返回的值。</p> <h2 id="dart的作用域"><a href="#dart的作用域" class="header-anchor">#</a> Dart的作用域</h2> <p>Dart没有public,private等关键字，默认就是公开的，私有变量使用下划线_开头。</p> <h2 id="dart是不是单线程模型-是如何运行的"><a href="#dart是不是单线程模型-是如何运行的" class="header-anchor">#</a> Dart是不是单线程模型？是如何运行的？</h2> <p>Dart是单线程模型，如图</p> <p><img src="/flutter/1608220395606.jpg" alt=""></p> <p>Dart在单线程中是以消息循环机制来运行的，其中包含两个任务队列，一个是&quot;微任务队列&quot;microtask queue,另一个叫做&quot;事件队列&quot;event queue。</p> <p>入口函数main()执行完后，消息循环机制便启动了。首先会按照先进先出的顺序逐个执行微任务队列中的任务，当所有微任务队列执行完后便开始执行事件队列中的任务，事件任务执行完毕后再去执行微任务，如此循环往复，生生不息。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">8/25/2021, 3:56:53 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/flutter/搭建Flutter开发环境.html" class="prev">
        搭建 Flutter 开发环境
      </a></span> <span class="next"><a href="/note/interview/知识点.html">
        知识点
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.61a85b1c.js" defer></script><script src="/assets/js/2.6b359b12.js" defer></script><script src="/assets/js/28.8e440e91.js" defer></script>
  </body>
</html>
